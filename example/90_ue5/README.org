- tutorial c++ unreal engine 5: https://youtu.be/nvruYLgjKkk
- apparently better video: https://www.youtube.com/watch?v=g9dU0eCy8RI&t=0s
  - starting C++ tutorial from blank project
- corresponding github: https://github.com/Ohjurot/UE5-Cpp-Tutorial

* How to install VS Code

  - https://docs.unrealengine.com/5.0/en-US/setting-up-visual-studio-code-for-unreal-engine/
  - Download VS Code
  - C/C++ extension
  - Compiler toolset LLVM/Clang
  - LLDB extension
    
  - Set up intellisense


* Build UE5 from source
  - download release from github (currently 5.1)
  - run some scripts
    - first one downloads 20GB
    - second generates build scripts (or something), takes 1min30sec
    - run make (needs 1.5GB ram per core, i can only use 8 cores)
      build time was ca 90min

* ChatGPT Experiments

- i had some conversations with the AI (it ran on some server by
  openai)
- looks like it can generate helpful example code for different
  problems.


** C++ UE5

 #+begin_example

Write a simple C++ example for Unreal Engine 5.

#include "Engine.h"

int main()
{
	// Create a new instance of the engine
	UEngine* Engine = NewObject<UEngine>();

	// Set the desired frame rate
	Engine->SetTargetFPS(60);

	// Begin the game loop
	while (Engine->IsRunning())
	{
		// Update the engine
		Engine->Tick();
	}

	// Cleanup
	Engine->Destroy();

	return 0;
}
 #+end_example


** UE5 Sphere

 #+begin_example

Write a simple C++ example for Unreal Engine 5. Draw a bouncing red sphere.


#include "Com#include "Components/StaticMeshComponent.h"
#include "Components/SceneComponent.h"
#include "GameFramework/Actor.h"

#include "DrawDebugHelpers.h"

#include "Engine/World.h"

class ABouncingSphere : public AActor
{
	GENERATED_BODY()

public:
	ABouncingSphere()
	{
		PrimaryActorTick.bCanEverTick = true;

		// Create the sphere mesh
		SphereMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("SphereMesh"));
		SphereMesh->SetStaticMesh(ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT("/Engine/BasicShapes/Sphere")).Object);
		SphereMesh->SetWorldScale3D(FVector(0.2f, 0.2f, 0.2f));
		SphereMesh->SetCollisionEnabled(ECollisionEnabled::QueryOnly);
		SphereMesh->SetCollisionObjectType(ECollisionChannel::ECC_WorldDynamic);
		SphereMesh->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore);
		SphereMesh->SetCollisionResponseToChannel(ECollisionChannel::ECC_WorldDynamic, ECollisionResponse::ECR_Overlap);
		RootComponent = SphereMesh;

		// Create the sphere physics
		SpherePhysics = CreateDefaultSubobject<USceneComponent>(TEXT("SpherePhysics"));
		SpherePhysics->SetMobility(EComponentMobility::Movable);
		SpherePhysics->SetupAttachment(RootComponent);

		// Set the sphere's color
		SphereMesh->SetMaterial(0, ConstructorHelpers::FObjectFinder<UMaterial>(TEXT("/Engine/BasicShapes/BasicShapeMaterial")).Object);
		SphereMesh->SetVectorParameterValue(FName("Color"), FLinearColor(1.0f, 0.0f, 0.0f));
	}

	void BeginPlay()
	{
		Super::BeginPlay();

		// Set the initial velocity
		SpherePhysics->SetPhysicsLinearVelocity(FVector(0.0f, 0.0f, 10.0f));
	}

	void Tick(float DeltaTime)
	{
		Super::Tick(DeltaTime);

		// Calculate the new velocity
		FVector Velocity = SpherePhysics->GetPhysicsLinearVelocity();
		Velocity.Z = Velocity.Z * -0.8f;
		SpherePhysics->SetPhysicsLinearVelocity(Velocity);

		// Draw a debug sphere
		DrawDebugSphere(GetWorld(), GetActorLocation(), 10.0f, 8, FColor(255, 0, 0));
	}

private:
	UStaticMeshComponent* SphereMesh;
	USceneComponent* SpherePhysics;

};


 #+end_example


** EMVA


- I want code that allows the calibration of a linear camera according to EMVA 1288.


- EMVA 1288 is a standard for measuring and reporting the performance
  of digital cameras. It is a comprehensive method that requires a
  test chart setup, camera settings, and a set of measurements taken
  with the camera.

- Unfortunately, there is no code that allows a linear camera to be
  calibrated according to EMVA 1288. Instead, you will need to use
  specialized software and/or hardware to complete the calibration
  process. For example, you can use software such as Photonfocus
  Calibration or hardware such as the Photonfocus EMVA 1288
  Calibration Kit to help you calibrate your linear camera.

- load PNG with R

#+begin_example
Write R code to load a sequence of 2D gray PNG image.

library(png)

img_list <- list.files(path = ".", pattern = "*.png", full.names = TRUE)

for (i in seq_along(img_list)){
  img <- readPNG(img_list[i])
  # add code to process the 2D gray PNG image
}

#+end_example


- compute statistics

#+begin_example

Write R code to load a sequence of 2D gray PNG image. Compute the variance and the mean of each pixel over all the images.

# Load packages
library(png)

# Create an empty vector to store the data
data <- vector(mode="numeric", length=1000)

# Loop through images
for (i in 1:1000) {
  # Load image and store into data vector
  img <- readPNG(paste0("image",i,".png"))
  data[i] <- img
}

# Compute the variance and the mean of each pixel over all images
pixel_variance <- apply(data, c(1,2), var)
pixel_mean <- apply(data, c(1,2), mean)
#+end_example

- continue:

#+begin_example

Plot variance against mean. Perform a linear fit. Print slope and intercept with error estimates.

# Plot variance against mean
plot(pixel_mean, pixel_variance, main="Variance vs Mean of Pixels")

# Perform linear fit
fit <- lm(pixel_variance ~ pixel_mean)

# Print slope and intercept with error estimates
summary(fit)
#+end_example


** Lane-Emden (star model, astronomy)
- python
#+begin_example
Implement a solver for the Lane-Emden equation in Python.

The Lane-Emden equation is a second-order nonlinear ordinary differential equation that describes the behavior of certain self-gravitating systems such as stars or gas clouds. It is given by:

d^2ξ/dθ^2 + (2/θ)dξ/dθ + ξ^n = 0

Where ξ(θ) is the unknown function and n is a constant.

The following code provides a solver for the Lane-Emden equation in Python:

import numpy as np

def lane_emden(n, theta):
    # Define the ODE
    def f(x, t):
        ξ, η = x
        return [η, -(2./t)*η - ξ**n]
    
    # Define the initial conditions
    x0 = [1, 0]
    
    # Solve the ODE
    soln = integrate.solve_ivp(f, [1e-6, theta], x0)
    
    # Return the solution
    return soln.y[0][-1]

# Test the solver
n = 3
theta = 10
print(lane_emden(n, theta)) # 0.08799616713117206

#+end_example

- continue
#+begin_example

# Plot results for three different positions in the Hertzsprung–Russell diagram
import matplotlib.pyplot as plt

# Define constants
n_values = [1, 3/2, 5]
theta_values = np.linspace(1e-6, 10, 100)

# Solve for each n value
for n in n_values:
    ξ_values = [lane_emden(n, theta) for theta in theta_values]
    
    # Plot the results
    plt.plot(ξ_values, theta_values, label=f'n = {n}')
    
# Label the plot
plt.xlabel('ξ')
plt.ylabel('θ')
plt.title('Lane-Emden Equation')
plt.legend()
plt.show()
#+end_example


- in go
  - does that make sense? i'm not sure
#+begin_example

Implement a solver for the Lane-Emden equation in Go.

//Function to solve Lane-Emden equation
func SolveLaneEmden(x float64, n float64) float64 {

	//Initialize variables
	var y float64 = 1
	var dy float64 = 0
	var h float64 = 1e-4

	//Iterate until x reaches 0
	for x >= 0 {
		//Calculate derivatives
		dy = y + (x*x*y)/(n-1)
		d2y := -2*x*dy/n - (x*x*dy)/(n-1)

		//Calculate new y value
		y += (h/2)*(dy + (h/2)*d2y)

		//Decrement x
		x -= h
	}

	//Return y
	return y
}
#+end_example

** Optical Fiber


- Derive the characteristic equation for a rotationally symmetric optical fiber with a core and infinite cladding.
 - That is not quite correct.
#+begin_example


The characteristic equation for a rotationally symmetric optical fiber with a core and infinite cladding is given by:

n_1^2 - n_2^2 = (2π/λ)^2n_1n_2(n_1^2 - n_2^2)r^2,

where n_1 is the refractive index of the core, n_2 is the refractive index of the cladding, λ is the wavelength of light, and r is the core radius.

#+end_example

- continue

#+begin_example


The solution for the scalar approximation is given by:

n_1 = n_2 + (2π/λ)^2n_1n_2r^2.
#+end_example


** Common Lisp socket

- Write Common Lisp code that listens on a socket. When it reads the
  string "Hello" the programm must return "World".

#+begin_example


(defun start-server ()
  (let ((s (socket:socket-server 8888 :element-type 'character :external-format '(:utf-8 :eol-style :crlf))))
    (loop (multiple-value-bind (str conn)
                        (socket:socket-accept s)
                      (if (string= "Hello" str)
                          (socket:socket-send conn "World")
                        (socket:socket-send conn "Error")))
           (sleep 5))))

(start-server)
#+end_example
** Forth socket

#+begin_example

Write forth code to listen on  a port. When it reads "Hello" it shall respond "World".

: listen ( port -- )
  begin
    accept port
    dup 0= if
      exit
    then
    ?dup "Hello" = if
      "World" emit
    then
    drop
  again ;

listen 80
#+end_example


** Android socket

#+begin_example

Write Kotlin code for an Android App that opens a socket and that listens on a socket. When it reads the string "Hello" the programm must return "World".

import java.net.ServerSocket
import java.io.BufferedReader
import java.io.InputStreamReader

fun main() {
    val serverSocket = ServerSocket(8080)
    println("Listening on port 8080")
    while (true) {
        val clientSocket = serverSocket.accept()
        val inFromClient = BufferedReader(InputStreamReader(clientSocket.getInputStream()))
        val inputLine = inFromClient.readLine()
        if (inputLine == "Hello") {
            println("Received: $inputLine")
            clientSocket.getOutputStream().write(("World\n").toByteArray())
        }
    }
}
#+end_example


** Common Lisp C++ generator

#+begin_example

Write Common Lisp code that reads s-expressions and generates C++ code.

(defun s-expr-to-cpp (expr)
  (cond
    ((atom expr) (format nil "~a" expr))
    ((eq (car expr) 'quote) (format nil "~a" (cadr expr)))
    ((or (eq (car expr) '+) (eq (car expr) '-))
     (format nil "(~a ~a ~a)"
             (s-expr-to-cpp (second expr)) (car expr) (s-expr-to-cpp (third expr))))
    ((or (eq (car expr) '*) (eq (car expr) '/))
     (format nil "(~a ~a ~a)"
             (s-expr-to-cpp (second expr)) (car expr) (s-expr-to-cpp (third expr))))
    (t (error "Unrecognized expression ~a" expr))))
#+end_example

- that is not what i want, i also don't see how i could fix that

** C++ popl

#+begin_example
Write C++ code that parses command line arguments with popl. It should support the verbose switch with the flag -v. If -h is given as an argument print the usage documentation and exit the program.

#include <iostream>
#include <string>
#include <popl.hpp>

int main(int argc, char* argv[]) {
    // Create a parser.
    popl::OptionParser parser;
    // Define the options.
    popl::Flag v{ parser, "v", "verbose", "enable verbose mode" };
    popl::Flag h{ parser, "h", "help", "print usage" };
    // Parse the command line arguments.
    try {
        parser.parse(argc, argv);
    }
    catch (const std::exception& e) {
        std::cerr << e.what() << "\n";
        return 1;
    }
    // Check if the -h flag was given.
    if (h.is_set()) {
        std::cout << parser << "\n";
        return 0;
    }
    // Check if the -v flag was given.
    if (v.is_set()) {
        std::cout << "Verbose mode enabled.\n";
    }
    // Do something with the command line arguments.
    // ...
    return 0;
}

#+end_example


- i want positional file arguments
#+begin_example

Write C++ code that parses command line arguments with popl. It should support the verbose switch with the flag -v. If -h is given as an argument print the usage documentation and exit the program. After the optional flags a sequence of one or more file arguments can follow.


#include <iostream>
#include <popl.hpp>

using namespace popl;

// Function to print usage documentation
void printUsageDoc() {
	std::cout << "Usage: myprogram [-v] file1 [file2 ...]" << std::endl;
	std::cout << "Flags:" << std::endl;
	std::cout << "-v   Enable verbose mode" << std::endl;
	std::cout << "-h   Print usage documentation and exit" << std::endl;
}

int main(int argc, char ** argv) {
	// Create option parser
	OptionParser op("myprogram");

	// Add verbose switch
	Switch verbose_switch(op, "v", "verbose", "Enable verbose mode");

	// Add help switch
	Switch help_switch(op, "h", "help", "Print usage documentation and exit");

	// Parse command line arguments
	try {
		op.parse(argc, argv);
	}
	catch (const std::exception& e) {
		std::cerr << e.what() << std::endl;
		op.printHelp(std::cerr);
		return EXIT_FAILURE;
	}

	// Print usage documentation if help switch is given
	if (help_switch.is_set()) {
		printUsageDoc();
		return EXIT_SUCCESS;
	}

	// Print verbose message if verbose switch is given
	if (verbose_switch.is_set())
		std::cout << "Verbose mode is enabled" << std::endl;

	// Handle file arguments
	std::vector<std::string> files = op.free_args();
	for (const std::string& file : files)
		std::cout << "Processing file: " << file << std::endl;

	return EXIT_SUCCESS;
}
#+end_example


** C++ libtorch

- pose estimation on image
#+begin_example
Write C++ code with libtorch that opens an image and performs pose estimation.

#include <torch/torch.h>
#include <opencv2/opencv.hpp>
#include <iostream>

// Read the image
cv::Mat image = cv::imread("image.jpg");

// Convert to tensor
at::Tensor tensor_image = torch::from_blob(image.data, {1, image.rows, image.cols, 3}, at::kByte);

// Normalize the image
tensor_image = tensor_image.toType(at::kFloat) / 255.0;

// Create the network
auto network = torch::nn::Sequential(torch::nn::Conv2d(3, 32, 3),
                                    torch::nn::ReLU(),
                                    torch::nn::MaxPool2d(2),
                                    torch::nn::Conv2d(32, 64, 3),
                                    torch::nn::ReLU(),
                                    torch::nn::MaxPool2d(2),
                                    torch::nn::Conv2d(64, 128, 3),
                                    torch::nn::ReLU(),
                                    torch::nn::MaxPool2d(2));

// Perform pose estimation
torch::Tensor output = network->forward(tensor_image);

std::cout << "Pose estimation output: " << output << std::endl;

#+end_example

- on video

#+begin_example
#include <torch/torch.h>
#include <opencv2/opencv.hpp>

// Load a pretrained model
torch::jit::script::Module model = torch::jit::load("pose_estimation_model.pt");

// Create a cv::VideoCapture object to capture from a camera
cv::VideoCapture cap(0);

while (true) {
    // Capture a frame from the video
    cv::Mat frame;
    cap >> frame;

    // Convert the frame to a tensor
    torch::Tensor tensor_image = torch::from_blob(frame.data, {1, frame.rows, frame.cols, 3}, torch::kByte);
    tensor_image = tensor_image.permute({0, 3, 1, 2});
    tensor_image = tensor_image.to(torch::kF32);

    // Run the model
    std::vector<torch::jit::IValue> inputs;
    inputs.push_back(tensor_image);
    at::Tensor output = model.forward(inputs).toTensor();

    // Extract the pose from the output
    float x_pos = output[0][0].item<float>();
    float y_pos = output[0][1].item<float>();

    // Draw the pose on the frame
    cv::circle(frame, cv::Point(x_pos, y_pos), 3, cv::Scalar(0,255,0), -1);

    // Display the frame
    cv::imshow("Pose Estimation", frame);

    // Check for user input
    int key = cv::waitKey(1);
    if (key == 27) {
        break;
    }
}

#+end_example


** C++ CGAL

#+begin_example

Write C++ code using CGAL.  Open a point cloud from a file. Fit a plane to the points with a z height lower than 10.


#include <CGAL/Simple_cartesian.h>
#include <CGAL/Plane_3.h>
#include <CGAL/IO/read_xyz_points.h>
#include <CGAL/Point_3.h>
#include <CGAL/Random.h>
#include <CGAL/linear_least_squares_fitting_3.h>

#include <fstream>
#include <iostream>
#include <vector>

typedef CGAL::Simple_cartesian<double> K;
typedef K::FT FT;
typedef K::Point_3 Point;
typedef K::Plane_3 Plane;
typedef std::vector<Point> Points;

int main()
{
  Points points;
  std::ifstream stream("data/points.xyz");
  if (!stream ||
      !CGAL::read_xyz_points(stream, std::back_inserter(points)))
  {
    std::cerr << "Error: cannot read file data/points.xyz" << std::endl;
    return EXIT_FAILURE;
  }

  Plane plane;

  Points filtered_points;
  for (auto p : points) {
    if (p.z() < 10) {
      filtered_points.push_back(p);
    }
  }

  CGAL::linear_least_squares_fitting_3(filtered_points.begin(), filtered_points.end(), plane, CGAL::Dimension_tag<0>());

  std::cout << "Fitting plane : " << plane << std::endl;

  return EXIT_SUCCESS;
}
#+end_example
 
** C++ Ceres

#+begin_example

Write C++ read images from two cameras and perform stereo calibration with the ceres-solver.

// Include the necessary libraries
#include<opencv2/opencv.hpp>
#include<ceres/ceres.h>
#include <ceres/rotation.h>

int main()
{
    // Read in the images from the two cameras
    cv::Mat left_image;
    cv::Mat right_image;
    left_image = cv::imread("left.jpg");
    right_image = cv::imread("right.jpg");
    
    // Create the vector of image point correspondences
    std::vector<cv::Point2f> left_points;
    std::vector<cv::Point2f> right_points;
    cv::findChessboardCorners(left_image, cv::Size(7,7), left_points);
    cv::findChessboardCorners(right_image, cv::Size(7,7), right_points);
    
    // Create the vector of 3D point correspondences
    std::vector<cv::Point3f> object_points;
    for (int i = 0; i < 7; i++) {
        for (int j = 0; j < 7; j++) {
            object_points.push_back(cv::Point3f(i, j, 0));
        }
    }
    
    // Create the camera intrinsic parameters
    cv::Matx33d camera_matrix = cv::Matx33d::eye();
    camera_matrix(0,0) = 1.0; //fx
    camera_matrix(1,1) = 1.0; //fy
    camera_matrix(0,2) = 0.5*left_image.cols; //cx
    camera_matrix(1,2) = 0.5*left_image.rows; //cy
    
    // Define the ceres problem
    ceres::Problem problem;
    for (int i = 0; i < left_points.size(); i++) {
        // Define the residual block
        ceres::CostFunction* cost_function =
        new ceres::AutoDiffCostFunction<ReprojectionError, 2, 4, 6>(
            new ReprojectionError(left_points[i], right_points[i], object_points[i], camera_matrix));
        
        // Set the parameters for the problem
        double* R = new double[4];
        double* t = new double[3];
        problem.AddResidualBlock(cost_function, NULL, R, t);
        
        // Set the parameter lower and upper bounds
        problem.SetParameterLowerBound(R, 0, -1.0);
        problem.SetParameterUpperBound(R, 0, 1.0);
        problem.SetParameterLowerBound(t, 0, -1000.0);
        problem.SetParameterUpperBound(t, 0, 1000.0);
    }
    
    // Solve the problem with Ceres
    ceres::Solver::Options options;
    options.linear_solver_type = ceres::DENSE_QR;
    options.minimizer_progress_to_stdout = true;
    ceres::Solver::Summary summary;
    ceres::Solve(options, &problem, &summary);
    
    // Print the results
    std::cout << summary.BriefReport() << std::endl;
    
    return 0;
}
#+end_example

** C++ skia

#+begin_example

Write C++ that draws a star with skia. When the user presses the star, it should smoothly transform into a circle.

#include <SkCanvas.h>
#include <SkPaint.h>
#include <SkPath.h>
#include <SkEvent.h>

void drawStar(SkCanvas* canvas) {
    SkPaint paint;
    paint.setStyle(SkPaint::kStroke_Style);

    SkPath starPath;
    starPath.moveTo(50, 10); 
    for (int i = 1; i < 5; i++) {
        starPath.lineTo(50 + 25 * cos(36 * i * M_PI / 180), 10 + 25 * sin(36 * i * M_PI / 180));
    }
    starPath.close();
    canvas->drawPath(starPath, paint);
}

void onUserPress(SkEvent *evt) {
    SkCanvas *canvas = evt->getCanvas();
    SkPaint paint;
    paint.setStyle(SkPaint::kStroke_Style);
    canvas->drawCircle(50, 50, 25, paint);
}

void main() {
    SkCanvas canvas;
    drawStar(&canvas);
    SkEvent evt("UserPressed", onUserPress);
    canvas.post(&evt);
}
#+end_example

** C++ filament

#+begin_example

Write C++ that uses filament. Load a glTF with a character animation. Display the character walking on a checkerboard floor.

#include <filament/Engine.h>
#include <filament/Scene.h>
#include <filament/Material.h>
#include <filament/TransformManager.h>
#include <filament/RenderableManager.h>
#include <filament/IndirectLight.h>
#include <filament/View.h>
#include <filament/LightManager.h>
#include <filament/IndexBuffer.h>
#include <filament/VertexBuffer.h>
#include <filament/Animation.h>
#include <filament/AnimationController.h>
#include <filament/Renderer.h>
#include <filament/Texture.h>

#include <gltfio/FilamentAsset.h>

#include <math/mat4.h>
#include <math/vec3.h>

using namespace filament;
using namespace gltfio;
using namespace math;

int main() {
    // Create an engine and a scene
    Engine* engine = Engine::create();
    Scene* scene = engine->createScene();

    // Create a camera
    Camera* camera = engine->createCamera();
    camera->setProjection(45.0f, 16.0f/9.0f, 0.1f, 100.0f);

    // Set a view
    View* view = engine->createView();
    view->setCamera(camera);
    view->setScene(scene);

    // Create a material
    Material* material = Material::Builder()
        .package("checkerboard.filamat")
        .build(*engine);

    // Load the glTF
    FilamentAsset* asset = FilamentAsset::createFromFile("character.gltf", engine);

    // Create the transform
    Entity entity = engine->getEntityManager()->create();
    TransformManager::get().setTransform(entity, mat4f{ mat3f::rotation(M_PI_2, float3{1, 0, 0}) });

    // Add the glTF to the scene
    asset->addEntitiesToScene(scene);
    asset->releaseSourceData();

    // Create the animation controller
    AnimationController* animController = engine->createAnimationController(asset->getAnimator());
    animController->setAnimation("walk", 0);

    // Set the scene and render
    engine->setView(view);
    engine->render(view);

    // Clean up
    engine->destroy(view);
    engine->destroy(animController);
    engine->destroy(camera);
    engine->destroy(asset);
    engine->destroy(material);
    engine->destroy(scene);
    engine->destroy(engine);

    return 0;
}
#+end_example

** Blender Python Armature

#+begin_example

Write Python code for Blender that creates an animated robot.

import bpy

# Create Armature
bpy.ops.object.armature_add(enter_editmode=True, location=(0, 0, 0))
bpy.ops.armature.bone_primitive_add(name='UpperArm')
bpy.ops.armature.bone_primitive_add(name='LowerArm')
bpy.ops.armature.bone_primitive_add(name='UpperLeg')
bpy.ops.armature.bone_primitive_add(name='LowerLeg')
bpy.ops.armature.bone_primitive_add(name='Head')
bpy.ops.armature.bone_primitive_add(name='Torso')
bpy.ops.object.mode_set(mode='OBJECT')

# Add modifiers to armature
bpy.context.object.modifiers.new(name='Armature', type='ARMATURE')
bpy.context.object.modifiers["Armature"].object = bpy.data.objects["Armature"]

# Create IK Constraints
bpy.context.object.pose.bones["UpperArm"].constraints.new("IK")
bpy.context.object.pose.bones["UpperLeg"].constraints.new("IK")

# Set IK Targets
bpy.context.object.pose.bones["UpperArm"].constraints["IK"].target = bpy.data.objects["LowerArm"]
bpy.context.object.pose.bones["UpperLeg"].constraints["IK"].target = bpy.data.objects["LowerLeg"]

# Create Animation
bpy.context.scene.frame_start = 0
bpy.context.scene.frame_end = 60
bpy.context.scene.frame_current = 0

# Set Armature location for each frame
for frame in range(bpy.context.scene.frame_start, bpy.context.scene.frame_end):
    bpy.context.scene.frame_set(frame)
    bpy.context.object.location.x = frame * 0.2

# Set Armature rotation for each frame
for frame in range(bpy.context.scene.frame_start, bpy.context.scene.frame_end):
    bpy.context.scene.frame_set(frame)
    bpy.context.object.rotation_euler.z = frame * 0.2

# Set Armature scale for each frame
for frame in range(bpy.context.scene.frame_start, bpy.context.scene.frame_end):
    bpy.context.scene.frame_set(frame)
    bpy.context.object.scale = (frame * 0.01, frame * 0.01, frame * 0.01)
#+end_example

** Emacs lisp words

#+begin_example

Write Emacs code that computes the ten words that occur the most in a buffer.

(defun compute-most-frequent-words (buffer) 
  "Computes the 10 most frequent words in BUFFER." 
  (interactive "b") 
  (let ((words (split-string (buffer-substring (point-min) (point-max))))) 
    (sort 
     (cl-loop for w in words 
              count w into word-counts 
              finally return (cl-loop for word being the hash-keys of word-counts using (hash-values count) 
                                     collect (cons word count))) 
     (lambda (x y) (> (cdr x) (cdr y))) 
     :key 'cdr) 
    (subseq (cl-loop for w in words 
                     count w into word-counts 
                     finally return (cl-loop for word being the hash-keys of word-counts using (hash-values count) 
                                            collect (cons word count))) 0 10)))
#+end_example

** Javascript link extractor

#+begin_example

Write Javascript code that finds extracts link for a youtube video when executed in the browsers javascript console.

//Assuming the video ID is "dQw4w9WgXcQ"

let link = 'https://www.youtube.com/watch?v=' + 'dQw4w9WgXcQ';
console.log(link); // Prints "https://www.youtube.com/watch?v=dQw4w9WgXcQ"

#+end_example

- is this a joke?

** Python helium

#+begin_example
Write Python code using helium. Open youtube. Search for "water". Download the video of the first result into a file. Wait until the download finished. Print the time it took. Exit the python program.

import helium

#open youtube
helium.start('youtube.com')

#search for 'water'
helium.write('water', into='Search')
helium.press(helium.Key.ENTER)

#download the video of the first result
helium.click('Download')

#wait until the download finished
start_time = helium.get_time()
helium.wait_until(lambda: helium.get_text('Downloaded') == 'Downloaded', timeout=60)
end_time = helium.get_time()

#print the time it took
print('Download finished in {} seconds.'.format(end_time - start_time))

#exit the program
helium.exit()
#+end_example

- i don't think you can just click download. but pretty good.


- try to help
#+begin_example

Write Python code using helium. Open youtube. Search for "water". Download the video of the first result into a file. Note that there is no download button. The program has to look at the HTML code of the site. Wait until the download finished. Print the time it took. Exit the python program.



import helium

# open youtube
helium.start_chrome('youtube.com')

# search for 'water'
helium.write('water', into='Search')
helium.press(helium.Key.ENTER)

# find link to the first result
first_result_url = helium.find_all('a.yt-simple-endpoint.style-scope.ytd-video-renderer')[0].web_element.get_attribute("href")

# download the video
start_time = helium.time()
helium.download(first_result_url)

# wait until download finishes
helium.wait_until(lambda: helium.download_complete())

# print time it took
print("Time elapsed: {} seconds".format(int(helium.time() - start_time)))

# exit program
helium.kill_browser()
#+end_example

- it's not working but pretty good

** C++ SIMD Gaussian filter

#+begin_example

Write C++ code that opens a PGM image. Perform a 2D Gaussian filter using SIMD instructions.


#include <iostream>
#include <fstream>
#include <string>
#include <xmmintrin.h>

using namespace std;

int main() {
	int width, height, max_val;
	string line;
	ifstream pgm_file;
	pgm_file.open("test.pgm");

	// Read PGM file header
	getline(pgm_file, line);
	getline(pgm_file, line);
	sscanf(line.c_str(), "%d %d", &width, &height);
	getline(pgm_file, line);
	sscanf(line.c_str(), "%d", &max_val);
	
	// Read pixel data
	int *pixel_data = new int[width * height];
	for (int i = 0; i < width * height; i++) {
		getline(pgm_file, line);
		sscanf(line.c_str(), "%d", &pixel_data[i]);
	}
	
	// Perform Gaussian filtering
	float kernel[3][3] = {
		{1.0/16.0, 2.0/16.0, 1.0/16.0},
		{2.0/16.0, 4.0/16.0, 2.0/16.0},
		{1.0/16.0, 2.0/16.0, 1.0/16.0}
	};
	
	float *output = new float[width * height];
	for (int i = 0; i < height; i++) {
		for (int j = 0; j < width; j++) {
			float sum = 0.0;
			for (int m = -1; m <= 1; m++) {
				for (int n = -1; n <= 1; n++) {
					int x = j + n;
					int y = i + m;
					if (x < 0 || x >= width || y < 0 || y >= height) {
						continue;
					}
					sum += (float)pixel_data[y * width + x] * kernel[m + 1][n + 1];
				}
			}
			output[i * width + j] = sum;
		}
	}
	
	// Perform Gaussian filtering using SIMD instructions
	__m128 *kernel_sse = (__m128*)kernel;
	
	for (int i = 0; i < height; i++) {
		for (int j = 0; j < width; j++) {
			__m128 sum = _mm_set1_ps(0.0f);
			for (int m = -1; m <= 1; m++) {
				for (int n = -1; n <= 1; n++) {
					int x = j + n;
					int y = i + m;
					if (x < 0 || x >= width || y < 0 || y >= height) {
						continue;
					}
					__m128 input = _mm_set1_ps((float)pixel_data[y * width + x]);
					sum = _mm_add_ps(sum, _mm_mul_ps(input, kernel_sse[m + 1][n + 1]));
				}
			}
			output[i * width + j] = sum[0] + sum[1] + sum[2] + sum[3];
		}
	}
	
	delete[] pixel_data;
	delete[] output;
	
	pgm_file.close();
	
	return 0;
}
#+end_example

** C++ read pulse audio
#+begin_example

Write C++ code that reads a buffer from the default pulse audio device.


#include <pulse/simple.h>
#include <iostream>

int main()
{
    pa_simple *s = NULL;
    int error;
    int16_t buffer[1024];

    // Create a new pulse audio simple context 
    s = pa_simple_new(
        nullptr,                          // Use the default server.
        "My Application Name",            // Our application's name.
        PA_STREAM_RECORD,                 // Record from the microphone.
        nullptr,                          // Use the default device.
        "Record from the microphone",     // Description of the stream.
        nullptr,                          // Specify sample format (defaults to signed 16-bit int).
        nullptr,                          // Use default channel map.
        nullptr,                          // Use default buffering attributes.
        &error                            // Error code.
    );

    if (s == nullptr) {
        std::cout << "Error creating pulse audio simple context: " << pa_strerror(error) << std::endl;
        return 1;
    }

    // Read a buffer of samples from the default pulse audio device
    if (pa_simple_read(s, buffer, sizeof(buffer), &error) < 0) {
        std::cout << "Error reading from pulse audio simple context: " << pa_strerror(error) << std::endl;
        return 1;
    }

    pa_simple_free(s);

    // Do something with the buffer of samples here

    return 0;
}
#+end_example


** C++ SIMD FFT

#+begin_example

Write C++ code that performs 1D FFT using SIMD instructions on a single-float buffer of length 1024.

#include <immintrin.h> // SIMD instructions
#include <complex> // complex data types

// define complex data type
typedef std::complex<float> cplx;

// helper function to perform FFT butterfly operation
void butterfly(__m128 &x0, __m128 &x1, __m128 &w0)
{
    __m128 tmp = _mm_add_ps(x0, x1);
    x1 = _mm_sub_ps(x0, x1);
    x0 = tmp;
    x1 = _mm_mul_ps(x1, w0);
}

// FFT implementation using SIMD instructions
void fft_simd(cplx *in, cplx *out, int N)
{
    // define constants
    const float PI = 3.14159265358979323846f;
    const __m128i mask_even = _mm_set_epi32(0, 0, 0, 0x55555555);
    const __m128i mask_odd = _mm_set_epi32(0, 0, 0, 0xAAAAAAA);
    const __m128 PI_2 = _mm_set1_ps(PI / 2.f);
    const int N_2 = N / 2;

    // create buffers for input and output
    __m128 *x_in = (__m128*)in;
    __m128 *x_out = (__m128*)out;

    // perform bit-reversal
    for (int i = 0; i < N_2; i++)
    {
        int j = _mm_cvtsi128_si32(_mm_shuffle_epi32(_mm_set_epi32(0, 0, 0, i), 0x1B));
        __m128 tmp = x_in[i];
        x_in[i] = x_in[j];
        x_in[j] = tmp;
    }

    // iterate over stages
    for (int s = 0; s < N_2; s++)
    {
        // calculate twiddle factors
        __m128 w = _mm_set1_ps(exp(-2.f * PI * s / N));

        // iterate over butterflies
        for (int b = 0; b < N_2; b++)
        {
            // select inputs
            int i0 = b;
            int i1 = b + N_2;
            __m128 x0 = x_in[i0];
            __m128 x1 = x_in[i1];

            // perform butterfly operation
            butterfly(x0, x1, w);

            // store results
            x_out[i0] = x0;
            x_out[i1] = x1;

            // update twiddle factors
            w = _mm_mul_ps(w, PI_2);
        }

        // swap input and output buffers
        __m128 *tmp = x_in;
        x_in = x_out;
        x_out = tmp;
    }

    // store output values
    int i = 0;
    for (int s = 0; s < N_2; s += 2)
    {
        // select values
        __m128 tmp = x_in[s];
        __m128 even = _mm_and_ps(tmp, mask_even);
        __m128 odd = _mm_and_ps(tmp, mask_odd);

        // store values
        out[i++] = cplx(_mm_cvtss_f32(even), _mm_cvtss_f32(odd));
    }
}

// main function
int main()
{
    // array of input values
    const int N = 1024;
    cplx input[N];

    // initialize input values
    for (int i = 0; i < N; i++)
        input[i] = cplx((float)i, 0);

    // array of output values
    cplx output[N];

    // perform FFT
    fft_simd(input, output, N);

    // print output values
    for (int i = 0; i < N; i++)
        std::cout << output[i] << std::endl;

    return 0;
}
#+end_example

- again with C++20

#+begin_example

Write C++20 code that performs 1D FFT using SIMD instructions on a single-float buffer of length 1024.


#include <intrin.h>
#include <immintrin.h>

int FFT_1D_SIMD(float *buffer, int N) {
    __m128 *data = (__m128*)buffer;
    int i, j;

    // Perform FFT in-place
    for (i = 0; i < N; i++) {
        __m128 sum = _mm_setzero_ps();
        __m128 w = _mm_set1_ps(1.0f);
        for (j = 0; j < N; j++) {
            sum = _mm_add_ps(sum, _mm_mul_ps(data[j], w));
            w = _mm_mul_ps(w, _mm_set_ps(cosf(2.0f*M_PI*i*j/N), sinf(2.0f*M_PI*i*j/N), cosf(2.0f*M_PI*i*j/N), sinf(2.0f*M_PI*i*j/N)));
        }
        data[i] = sum;
    }

    return 0;
}
#+end_example

- again Cuda

#+begin_example
Write Cuda code that performs 1D FFT on a single-float buffer of length 1024.


__global__ void FFTKernel(float* buf, int length)
{
    // Perform 1D FFT on a single-float buffer of length 1024
    int index = blockDim.x * blockIdx.x + threadIdx.x;

    // Check that thread is within bounds
    if (index < length)
    {
        // Declare complex variables
        float2 x, w, t;

        // Calculate the magnitude of the current index
        int k = index;
        int m = length/2;
        int n = 0;
        while (m > 0)
        {
            n++;
            m >>= 1;
        }

        // Calculate the twiddle factor
        float theta = -2.0 * M_PI * k / length;
        w.x = cosf(theta);
        w.y = sinf(theta);

        // Perform FFT
        for (int j = 0; j < n; j++)
        {
            m = 1 << j;
            for (int i = 0; i < length; i += 2*m)
            {
                t.x = buf[i+m] * w.x - buf[i+m] * w.y;
                t.y = buf[i+m] * w.y + buf[i+m] * w.x;
                x.x = buf[i];
                x.y = 0.0f;
                buf[i] = x.x + t.x;
                buf[i+m] = x.x - t.x;
                x.x = buf[i+1];
                x.y = 0.0f;
                buf[i+1] = x.x + t.y;
                buf[i+m+1] = x.x - t.y;
            }
            w.x = (w.x * w.x) - (w.y * w.y);
            w.y = 2.0f * w.x * w.y;
        }
    }
}

// Launch the FFT kernel
FFTKernel<<<1024,1>>>(buf, 1024);

#+end_example

** OpenCL 1D FFT

#+begin_example

Write OpenCL code that performs 1D FFT on a single-float buffer of length 1024.


// FFT kernel
__kernel void fft_kernel(__global float* input, __global float* output){
    // Get the global id of the current thread
    int gid = get_global_id(0);

    // Define constants
    int N = 1024;
    float PI = 3.14159265358979f;

    // Calculate the FFT
    float real = 0.0f;
    float imag = 0.0f;
    for (int k=0; k<N; k++){
        real += input[k] * cos(-2*PI*k*gid/N);
        imag += input[k] * sin(-2*PI*k*gid/N);
    }

    // Store the output
    output[2*gid] = real;
    output[2*gid+1] = imag;
}
#+end_example

- that is not a "FAST" FT

- again

#+begin_example

Write OpenCL code that performs 1D FFT on a single-float buffer of length 1024. Make sure to use butterfly.

// Global constants
#define NUM_ELEMENTS 1024
#define LOG2_NUM_ELEMENTS 10

// Global variables
__constant float twiddle_factors[NUM_ELEMENTS/2];
__global float buffer[NUM_ELEMENTS];

// Kernel function
__kernel void FFT_1D(__global float *buffer, __constant float *twiddle_factors)
{
  // Local memory
  __local float local_buffer[NUM_ELEMENTS];

  // Read input data into local memory
  int index = get_global_id(0);
  local_buffer[index] = buffer[index];

  // FFT butterfly
  for (int i=1; i<=LOG2_NUM_ELEMENTS; i++) {
    int butterfly_size = 1 << i;
    int butterfly_count = NUM_ELEMENTS / butterfly_size;
    int butterfly_half_size = butterfly_size / 2;

    for (int j=0; j<butterfly_count; j++) {
      int base_index = j * butterfly_size;
      int index_A = base_index;
      int index_B = base_index + butterfly_half_size;
      float twiddle_index = (float) (j * butterfly_half_size);

      float A = local_buffer[index_A];
      float B = local_buffer[index_B];
      float twiddle = twiddle_factors[(int) twiddle_index];
      float sum = A + B;
      float difference = (A - B) * twiddle;

      local_buffer[index_A] = sum;
      local_buffer[index_B] = difference;
    }
  }

  // Write result back to global memory
  buffer[index] = local_buffer[index];
}
#+end_example

*** Common Lisp SBCL FFT sb-simd

#+begin_example

Write Common Lisp for SBCL code using sb-simd that performs 1D FFT for a single float array. Don't forget butterfly.

(defun 1D-FFT (array)
  (let ((n (length array)))
    (if (= n 1)
        array
        (let* ((even-array (sb-simd:map (lambda (x y) (+ x y))
                                        (1D-FFT (subseq array 0 (truncate (/ n 2))))
                                        (1D-FFT (subseq array (truncate (/ n 2)) n))))
          (sb-simd:map (lambda (x y w) (+ (* w x) y))
                       even-array
                       (sb-simd:map (lambda (x y) (- x y))
                                    (1D-FFT (subseq array 0 (truncate (/ n 2))))
                                    (1D-FFT (subseq array (truncate (/ n 2)) n)))
                       (sb-simd:butterfly n)))))
#+end_example

** Cuda 2D gaussian blur

#+begin_example

Write Cuda code that performs 2D Gaussian blur on a 2D texture with size 1024x1024;



// Kernel function for 2D Gaussian blur
__global__ void gaussian_blur(float *in, float *out, int width, int height, float sigma)
{
    int x = blockDim.x * blockIdx.x + threadIdx.x;
    int y = blockDim.y * blockIdx.y + threadIdx.y;
   
    if (x < width && y < height) 
    { 
        // calculate the gaussian blur    
        float sum = 0.0f; 
        float kernel_value;
        for (int i = -1; i <= 1; i++)
        {
            for (int j = -1; j <= 1; j++)
            {
                // Retrieve the value of the current pixel
                float pixel_value = in[(y + i) * width + (x + j)];
                // Calculate the kernel value
                kernel_value = exp(-((i * i + j * j) / (2 * sigma * sigma)));
                // Accumulate the weighted pixel value
                sum += pixel_value * kernel_value;
            }
        }
        // Store the blurred pixel value
        out[y * width + x] = sum;
    }
}
 
// Launch grid for the kernel
dim3 blocks(32, 32);
dim3 threads(16, 16);
 
// Allocate shared memory
__shared__ float shared_in[16 * 16];
__shared__ float shared_out[16 * 16];
 
// Call the kernel
gaussian_blur<<<blocks, threads>>>(in, out, 1024, 1024, sigma);
#+end_example

** OpenCL 2D Gaussian blur

#+begin_example

Write OpenCL
 code that performs 2D Gaussian blur on a 2D texture with size 1024x1024;


// Define the global constants
#define IMAGE_WIDTH 1024
#define IMAGE_HEIGHT 1024
#define KERNEL_SIZE 9

// Define the kernel
__kernel void gaussianBlur2D(__read_only image2d_t input,
                            __write_only image2d_t output)
{
    // Get the x and y coordinates of the current thread
    int x = get_global_id(0);
    int y = get_global_id(1);
 
    // Compute the coordinates of the current pixel
    int2 coords = (int2)(x, y);

    // Initialize the sum to 0
    float4 sum = (float4)(0.0f);

    // Iterate over the kernel size
    for (int i = -KERNEL_SIZE/2; i <= KERNEL_SIZE/2; i++)
    {
        for (int j = -KERNEL_SIZE/2; j <= KERNEL_SIZE/2; j++)
        {
            // Compute the coordinates of the kernel element
            int2 kernelCoords = (int2)(x + i, y + j);

            // Make sure that the coordinates are valid
            if (kernelCoords.x >= 0 && kernelCoords.x < IMAGE_WIDTH &&
                kernelCoords.y >= 0 && kernelCoords.y < IMAGE_HEIGHT)
            {
                // Read the pixel value from the input image
                float4 pixel = read_imagef(input, kernelCoords);

                // Apply the Gaussian filter
                float4 gaussianWeight = (float4)(exp(-((i*i)+(j*j))/(2*(KERNEL_SIZE/3)*(KERNEL_SIZE/3))));
                sum += pixel * gaussianWeight;
            }
        }
    }

    // Write the blurred pixel to the output image
    write_imagef(output, coords, sum);
}
#+end_example

** C++ wayland screen capture

#+begin_example

Write C++ code that captures a wayland screen.

#include <wayland-client.h>
#include <wayland-server.h>

/* Get a reference to the global Wayland display */
struct wl_display *display = wl_display_connect(NULL);

/* Create a Wayland registry and add a listener */
struct wl_registry *registry = wl_display_get_registry(display);
wl_registry_add_listener(registry, &registry_listener, NULL);

/* Wait for the registry listener to be called */
wl_display_dispatch(display);

/* Get the compositor for the display */
struct wl_compositor *compositor = wl_registry_bind(
    registry,
    compositor_id,
    &wl_compositor_interface,
    1);

/* Create a surface */
struct wl_surface *surface = wl_compositor_create_surface(compositor);

/* Create a buffer to store the image data */
struct wl_buffer *buffer = wl_shm_pool_create_buffer(
    shm_pool,
    0,
    width,
    height,
    stride,
    WL_SHM_FORMAT_ARGB8888);

/* Attach the buffer to the surface */
wl_surface_attach(surface, buffer, 0, 0);

/* Commit the surface */
wl_surface_commit(surface);

/* Read the image data from the buffer */
uint8_t *data = wl_shm_pool_read(shm_pool, 0, width * height * 4);
#+end_example

*** store in opengl texture

#+begin_example
Write C++ code that captures a wayland screen into a OpenGL texture.

#include <GL/gl.h>
#include <wayland-client.h>

int main() {
    struct wl_display *display = wl_display_connect(NULL);
    struct wl_registry *registry = wl_display_get_registry(display);
    struct wl_compositor *compositor = NULL;
    wl_registry_add_listener(registry, &registry_listener, &compositor);
    wl_display_dispatch(display);
    wl_display_roundtrip(display);
    // get the output
    struct wl_output *output = wl_registry_bind(registry, 0, &wl_output_interface, 1);
    // create a buffer
    struct wl_buffer *buffer = wl_compositor_create_buffer(compositor, output, WL_OUTPUT_MODE_CURRENT, 0, 0);
    // create an OpenGL texture
    GLuint texture;
    glGenTextures(1, &texture);
    glBindTexture(GL_TEXTURE_2D, texture);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, wl_buffer_get_width(buffer), wl_buffer_get_height(buffer), 0, GL_RGBA, GL_UNSIGNED_BYTE, wl_buffer_get_data(buffer));
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glBindTexture(GL_TEXTURE_2D, 0);
    wl_buffer_destroy(buffer);
    wl_output_destroy(output);
    wl_registry_destroy(registry);
    wl_compositor_destroy(compositor);
    wl_display_disconnect(display);
    return 0;
}

#+end_example

*** store in vulkan texture

#+begin_example
Write C++ code that captures a wayland screen into a Vulkan texture.

#include <vulkan/vulkan.h>
#include <wayland/wayland.h>

struct wl_display* display;
struct wl_buffer* buffer;

VkImage image;
VkDeviceMemory memory;
VkImageView view;
VkBuffer stagingBuffer;
VkDeviceMemory stagingMemory;

// Create image
VkImageCreateInfo imageInfo = {};
imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
imageInfo.imageType = VK_IMAGE_TYPE_2D;
imageInfo.format = VK_FORMAT_R8G8B8A8_UNORM;
imageInfo.extent.width = width;
imageInfo.extent.height = height;
imageInfo.extent.depth = 1;
imageInfo.mipLevels = 1;
imageInfo.arrayLayers = 1;
imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;
imageInfo.tiling = VK_IMAGE_TILING_LINEAR;
imageInfo.usage = VK_IMAGE_USAGE_TRANSFER_DST_BIT;
imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

// Allocate memory
VkMemoryRequirements memReqs;
vkGetImageMemoryRequirements(device, image, &memReqs);

VkMemoryAllocateInfo allocInfo = {};
allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
allocInfo.allocationSize = memReqs.size;
allocInfo.memoryTypeIndex = findMemoryType(memReqs.memoryTypeBits,
											VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | 
											VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);

vkAllocateMemory(device, &allocInfo, nullptr, &memory);
vkBindImageMemory(device, image, memory, 0);

// Create image view
VkImageViewCreateInfo viewInfo = {};
viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
viewInfo.image = image;
viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
viewInfo.format = VK_FORMAT_R8G8B8A8_UNORM;
viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
viewInfo.subresourceRange.baseMipLevel = 0;
viewInfo.subresourceRange.levelCount = 1;
viewInfo.subresourceRange.baseArrayLayer = 0;
viewInfo.subresourceRange.layerCount = 1;

vkCreateImageView(device, &viewInfo, nullptr, &view);

// Create staging buffer
VkBufferCreateInfo stagingBufferInfo = {};
stagingBufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
stagingBufferInfo.size = width * height * 4;
stagingBufferInfo.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;
stagingBufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

vkCreateBuffer(device, &stagingBufferInfo, nullptr, &stagingBuffer);

// Allocate memory for staging buffer
VkMemoryRequirements stagingMemReqs;
vkGetBufferMemoryRequirements(device, stagingBuffer, &stagingMemReqs);

VkMemoryAllocateInfo stagingAllocInfo = {};
stagingAllocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
stagingAllocInfo.allocationSize = stagingMemReqs.size;
stagingAllocInfo.memoryTypeIndex = findMemoryType(stagingMemReqs.memoryTypeBits, 
												  VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | 
												  VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);

vkAllocateMemory(device, &stagingAllocInfo, nullptr, &stagingMemory);
vkBindBufferMemory(device, stagingBuffer, stagingMemory, 0);

// Acquire Wayland buffer
wl_display_roundtrip(display);
wl_surface_attach(surface, buffer, 0, 0);
wl_surface_damage(surface, 0, 0, width, height);

// Map memory
void* data;
vkMapMemory(device, stagingMemory, 0, width * height * 4, 0, &data);

// Copy data
wl_shm_pool_get_data(pool, data);

// Unmap memory
vkUnmapMemory(device, stagingMemory);

// Copy data to image
VkCommandBufferBeginInfo beginInfo = {};
beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;

vkBeginCommandBuffer(commandBuffer, &beginInfo);

VkImageMemoryBarrier barrier = {};
barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
barrier.srcAccessMask = 0;
barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
barrier.oldLayout = VK_IMAGE_LAYOUT_UNDEFINED;
barrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
barrier.image = image;
barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
barrier.subresourceRange.baseMipLevel = 0;
barrier.subresourceRange.levelCount = 1;
barrier.subresourceRange.baseArrayLayer = 0;
barrier.subresourceRange.layerCount = 1;

vkCmdPipelineBarrier(commandBuffer,
					 VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
					 VK_PIPELINE_STAGE_TRANSFER_BIT,
					 0,
					 0, nullptr,
					 0, nullptr,
					 1, &barrier);

VkBufferImageCopy region = {};
region.bufferOffset = 0;
region.bufferRowLength = 0;
region.bufferImageHeight = 0;
region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
region.imageSubresource.mipLevel = 0;
region.imageSubresource.baseArrayLayer = 0;
region.imageSubresource.layerCount = 1;
region.imageOffset = { 0, 0, 0 };
region.imageExtent = { width, height, 1 };

vkCmdCopyBufferToImage(commandBuffer, stagingBuffer, image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &region);

VkImageMemoryBarrier barrier2 = {};
barrier2.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
barrier2.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
barrier2.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
barrier2.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
barrier2.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
barrier2.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
barrier2.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
barrier2.image = image;
barrier2.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
barrier2.subresourceRange.baseMipLevel = 0;
barrier2.subresourceRange.levelCount = 1;
barrier2.subresourceRange.baseArrayLayer = 0;
barrier2.subresourceRange.layerCount = 1;

vkCmdPipelineBarrier(commandBuffer,
					 VK_PIPELINE_STAGE_TRANSFER_BIT,
					 VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
					 0,
					 0, nullptr,
					 0, nullptr,
					 1, &barrier2);

vkEndCommandBuffer(commandBuffer);

VkSubmitInfo submitInfo = {};
submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
submitInfo.commandBufferCount = 1;
submitInfo.pCommandBuffers = &commandBuffer;

vkQueueSubmit(queue, 1, &submitInfo, VK_NULL_HANDLE);
vkQueueWaitIdle(queue);

vkDestroyBuffer(device, stagingBuffer, nullptr);
vkFreeMemory(device, stagingMemory, nullptr);

#+end_example

- that is too verbose, using up all the tokens

** OpenGL compute shader clahe

#+begin_example

Write an OpenGL shader that performs CLAHE.

// Vertex shader
#version 330 core
layout (location = 0) in vec3 aPos;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    gl_Position = projection * view * model * vec4(aPos, 1.0);
}

//Fragment shader
#version 330 core
out vec4 FragColor;

uniform sampler2D inputTexture;
uniform float clipLimit;

// Number of bins to use
const int BINS = 256;

// Size of histogram bin
const float BIN_SIZE = 1.0 / float(BINS);

// Size of window used to compute histogram
const int WINDOW_SIZE = 32;

// Compute histogram of pixel values
float calculateHistogram(sampler2D texture, vec2 uv, int windowSize)
{
    // Initialize histogram array
    float histogram[BINS];
    for (int i = 0; i < BINS; i++)
        histogram[i] = 0.0;

    // Compute histogram
    for (int x = -windowSize; x <= windowSize; x++)
    {
        for (int y = -windowSize; y <= windowSize; y++)
        {
            vec2 offset = vec2(float(x), float(y));
            vec4 sample = texture2D(texture, uv + offset);
            int bin = int(sample.r * 255.0);
            histogram[bin] += 1.0;
        }
    }

    // Normalize histogram
    float total = 0.0;
    for (int i = 0; i < BINS; i++)
        total += histogram[i];
    for (int i = 0; i < BINS; i++)
        histogram[i] /= total;

    // Compute cumulative distribution
    float cdf[BINS];
    cdf[0] = histogram[0];
    for (int i = 1; i < BINS; i++)
        cdf[i] = cdf[i - 1] + histogram[i];

    // Compute clip limit
    float clipLimit = 0.0;
    for (int i = 0; i < BINS; i++)
    {
        if (cdf[i] >= clipLimit)
            clipLimit = cdf[i];
    }

    // Return clip limit
    return clipLimit;
}

// Compute CLAHE pixel
vec4 clahe(sampler2D texture, vec2 uv, float clipLimit)
{
    // Compute histogram
    float histogram[BINS];
    for (int i = 0; i < BINS; i++)
        histogram[i] = 0.0;

    // Compute histogram
    for (int x = -WINDOW_SIZE; x <= WINDOW_SIZE; x++)
    {
        for (int y = -WINDOW_SIZE; y <= WINDOW_SIZE; y++)
        {
            vec2 offset = vec2(float(x), float(y));
            vec4 sample = texture2D(texture, uv + offset);
            int bin = int(sample.r * 255.0);
            histogram[bin] += 1.0;
        }
    }

    // Normalize histogram
    float total = 0.0;
    for (int i = 0; i < BINS; i++)
        total += histogram[i];
    for (int i = 0; i < BINS; i++)
        histogram[i] /= total;

    // Compute cumulative distribution
    float cdf[BINS];
    cdf[0] = histogram[0];
    for (int i = 1; i < BINS; i++)
        cdf[i] = cdf[i - 1] + histogram[i];

    // Compute clip limit
    float clipLimit = 0.0;
    for (int i = 0; i < BINS; i++)
    {
        if (cdf[i] >= clipLimit)
            clipLimit = cdf[i];
    }

    // Compute CLAHE pixel
    vec4 sample = texture2D(texture, uv);
    int bin = int(sample.r * 255.0);
    float cdfMin = 0.0;
    if (bin > 0)
        cdfMin = cdf[bin - 1];
    float cdfMax = cdf[bin];
    float a = (clipLimit - cdfMin) / (cdfMax - cdfMin);
    sample.r = bin * BIN_SIZE + a * BIN_SIZE;

    return sample;
}

void main()
{
    // Compute clip limit
    float clipLimit = calculateHistogram(inputTexture, gl_FragCoord.xy, WINDOW_SIZE);

    // Compute CLAHE pixel
    vec4 sample = clahe(inputTexture, gl_FragCoord.xy, clipLimit);

    FragColor = sample;
}
#+end_example
- i'm not sure this works but looks quite impressive


** C++ Ryzen power consumption

#+begin_example
Write an C++ code that reads current power consumption from register on AMD Ryzen.

#include <cstdio>
#include <iostream>
#include <Windows.h>

int main() {
  HKEY hKey;
  DWORD dwType = REG_DWORD;
  DWORD dwSize = sizeof(DWORD);
  DWORD dwValue;
  LONG lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
      TEXT("HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0"), 0, KEY_READ, &hKey);
  if (lRet != ERROR_SUCCESS) {
    printf("Error opening registry key\n");
    return 1;
  }
  lRet = RegQueryValueEx(hKey, TEXT("PowerManagement"), 0, &dwType, (LPBYTE)&dwValue, &dwSize);
  if (lRet != ERROR_SUCCESS) {
    printf("Error querying registry value\n");
    return 1;
  }
  printf("Current power consumption from AMD Ryzen is %d W\n", dwValue);
  RegCloseKey(hKey);
  return 0;
}
#+end_example

** C++ Linux power consumption
#+begin_example

Write Linux C++20 code that reads current power consumption from register on AMD Ryzen.

#include <iostream>
#include <fstream>
#include <string>

int main()
{
    std::ifstream cpu_file("/sys/class/powercap/rapl_controller/intel-rapl/intel-rapl:0/energy_uj");
    std::string power_consumption_line;
    double power_consumption;

    if (cpu_file.is_open()) {
        if (getline(cpu_file, power_consumption_line)) {
            power_consumption = std::stod(power_consumption_line);
            std::cout << "Current power consumption is " << power_consumption << " uJ\n";
        }
    }

    return 0;
}
#+end_example

- i have an intel box, this is actually pretty close:

#+begin_example
[martin@localhost source00]$ sudo cat /sys/class/powercap/intel-rapl/intel-rapl\:0/energy_uj 
[sudo] password for martin: 
96375830303
[martin@localhost source00]$ sudo cat /sys/class/powercap/intel-rapl/intel-rapl\:0/energy_uj 
96378561070

#+end_example

*** for Ryzen it the sys path is a bit different:

#+begin_example

Write Linux C++20 code that reads current power consumption from register on AMD Ryzen processor core 0.


#include <fstream>
#include <iostream>
#include <string>

int main() {
    std::string path = "/sys/devices/system/cpu/cpu0/power/energy_uj";
    std::ifstream infile(path);
    uint64_t energy;
    infile >> energy;
    std::cout << "Current power consumption (in uJ) of core 0 is: " << energy << std::endl;
    return 0;
}
#+end_example

** C++ Linux clock frequency

#+begin_example

Write Linux C++20 code that reads current frequency  from register on AMD Ryzen.

#include <cpufreq.h>
 
int main()
{
    /* Get the current frequency of CPU 0 on AMD Ryzen */
    unsigned int freq;
    int ret = cpufreq_get_freq_kernel(0, &freq);
    if (ret == 0) {
        std::cout << "Current CPU frequency is: " << freq << " MHz\n";
    } else {
        std::cerr << "Error getting CPU frequency\n";
    }
 
    return 0;
}
#+end_example

** C++ Linux clock frequency intel register

#+begin_example

Write Linux C++20 code that reads current frequency  from register on Intel processor.


#include <cpuid.h>
#include <bitset>
#include <iostream>

int main()
{
	unsigned int eax, ebx, ecx, edx;
	unsigned int max_level, ext_level;

	// Get processor info
	__cpuid(0, max_level, ebx, ecx, edx);
	__cpuid(0x80000000, ext_level, ebx, ecx, edx);

	// Check if CPUID supports extended functions
	if (ext_level >= 0x16) {
		// Get frequency from the MSR
		__cpuid(0x16, eax, ebx, ecx, edx);
		// Bits 31:0 contain the current frequency in MHz
		std::bitset<32> cur_freq(eax);
		std::cout << "Current frequency: " << cur_freq.to_ulong() << " MHz" << std::endl;
	}

	return 0;
}
#+end_example

** C++ Linux ARM A53 frequency

#+begin_example

Write Linux C++20 code that reads current frequency  from register on ARM A53.


#include <stdio.h>
#include <stdint.h>

int main() {
    // Read from the A53 frequency register
    uint32_t reg;
    asm volatile("mrs %0, S3_1_C15_C2_4" : "=r" (reg));
    uint32_t cur_freq = (reg >> 8) & 0xFFF;  // Bits 8-19 of the register
    printf("Current frequency is %u MHz\n", cur_freq);
    return 0;
}
#+end_example

- again
#+begin_example

Write Android C++20 code that reads current frequency  from register on ARM A53.


#include <stdio.h>
#include <stdint.h>

// Get the current frequency of the ARM A53 processor
uint32_t getCurrentFrequency(void)
{
    uint32_t result;
    
    // Read the register containing the current frequency
    asm volatile (
        "mrc p15, 0, %0, c0, c1, 0"
        : "=r" (result)
    );
    
    return result;
}

int main(void)
{
    printf("Current frequency: %u\n", getCurrentFrequency());
    
    return 0;
}
#+end_example

*** power consumption

#+begin_example

Write Linux C++20 code that reads current power consumption  from register on ARM A53.


#include <iostream>
#include <fstream>
#include <cstdint>

int main() {
    // Read the register value
    std::ifstream reg_file("/sys/devices/system/cpu/cpu0/regs/PMCR_EL0");
    uint32_t reg_val;
    reg_file >> std::hex >> reg_val;

    // Extract the power consumption value
    uint32_t power_consumption = (reg_val >> 0) & 0xFFFF;

    std::cout << "Power consumption: " << power_consumption << std::endl;

    return 0;
}
#+end_example

*** android

#+begin_example
Write Android C++20 code that reads current power consumption  from register on ARM A53.



#include <stdio.h>
#include <stdint.h>

// Register addresses for power consumption
#define A53_PWR_CONSUMPTION_REGISTER 0x020C8018

int main()
{
    // Read from power consumption register
    uint32_t value;
    __asm__ ("MRS %0, PMU_PWR_CONSUMPTION" : "=r" (value));
 
    // Print the current power consumption
    printf("Current power consumption is %u\n", value);
    
    return 0;
}


#+end_example

*** armv7 frequency

#+begin_example
Write Android C++20 code that reads current frequency  from register on ARMv7.


#include <cstdint>
#include <arm_neon.h>
 
int main(int argc, char **argv) {
    uint32_t current_freq;
    asm volatile ("mrc p15, 0, %0, c0, c0, 0" : "=r" (current_freq));
    uint32x2_t vFreq = vdup_n_u32(current_freq);
    printf("Current Frequency: %d Hz\n", vFreq[0]);
    return 0;
}

#+end_example

*** Android armv7 power consumption

#+begin_example

Write Android C++20 code that reads current power consumption from register on ARMv7.


// Include necessary libraries
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <arm_neon.h>

// Define register address
#define POWER_REGISTER 0xE000ED14

// Function to read current power consumption from register
int32_t read_power_consumption()
{
    int32_t power_consumption;

    // Use vld1q_s32 intrinsics to read the register
    int32x2_t power_val = vld1q_s32((const int32_t *)POWER_REGISTER);

    // Extract the value from the register
    power_consumption = vgetq_lane_s32(power_val, 0);

    return power_consumption;
}
#+end_example
- Shows the content of the CCR register (in HEX) located at memory
  address 0xE000ED14.


*** Linux armv7 power consumption

#+begin_example

Write Linux C++20 code that reads current power consumption from register on ARMv7.


#include <cstdint>
#include <cstdio>
#include <functional>

using namespace std;

int main(int argc, char** argv) {
    const int CP15_REG_POWER_CTRL = 0xE000ED2C;

    // Read the power control register
    uint32_t power_ctrl;
    asm volatile("mrc p15, 0, %0, c9, c0, 2" : "=r" (power_ctrl));

    // Extract the current power consumption
    uint32_t consumption = (power_ctrl & 0xFF);
    printf("Current power consumption: %u\n", consumption);

    return 0;
}
#+end_example


** Open Wayland window

#+begin_example
Write Linux C++20 code that opens a wayland window.

#include <wayland-client.h>

int main() {
   struct wl_display *display;
   struct wl_compositor *compositor;
   struct wl_surface *surface;
   struct wl_shell *shell;
   struct wl_shell_surface *shell_surface;

   display = wl_display_connect(NULL);
   if (display == NULL) {
      return -1;
   }

   compositor = wl_compositor_create(display, 1);
   surface = wl_compositor_create_surface(compositor);
   shell = wl_shell_create(display, 1);
   shell_surface = wl_shell_get_shell_surface(shell, surface);

   wl_shell_surface_set_toplevel(shell_surface);

   wl_display_dispatch(display);

   wl_shell_surface_destroy(shell_surface);
   wl_shell_destroy(shell);
   wl_surface_destroy(surface);
   wl_compositor_destroy(compositor);
   wl_display_disconnect(display);

   return 0;
}
#+end_example

- not working: 
#+begin_example
[martin@localhost 90_ue5]$ g++ wayland_open.cpp
wayland_open.cpp: In function ‘int main()’:
wayland_open.cpp:17:17: error: ‘wl_compositor_create’ was not declared in this scope; did you mean ‘wl_compositor_interface’?
   17 |    compositor = wl_compositor_create(display, 1);
      |                 ^~~~~~~~~~~~~~~~~~~~
      |                 wl_compositor_interface
wayland_open.cpp:19:12: error: ‘wl_shell_create’ was not declared in this scope; did you mean ‘wl_shell_surface’?
   19 |    shell = wl_shell_create(display, 1);
      |            ^~~~~~~~~~~~~~~
      |            wl_shell_surface

#+end_example

*** again
#+begin_example

Write Linux C++20 code that opens a wayland window. wl_compositor_create is not declared.

#include <wayland-client.h>
#include <wayland-egl.h>
#include <EGL/egl.h>
#include <GLES2/gl2.h>
 
struct wl_display *display = wl_display_connect(NULL);
if (display == NULL) {
    // handle error
}
 
struct wl_registry *registry = wl_display_get_registry(display);
if (registry == NULL) {
    // handle error
}
 
wl_registry_add_listener(registry, &registry_listener, NULL);
wl_display_dispatch(display);
wl_display_roundtrip(display);
 
struct wl_compositor *compositor = wl_registry_bind(registry,
                                                    compositor_id,
                                                    &wl_compositor_interface,
                                                    1);
if (compositor == NULL) {
    // handle error
}
 
struct wl_surface *surface = wl_compositor_create_surface(compositor);
if (surface == NULL) {
    // handle error
}
 
struct wl_egl_window *egl_window = wl_egl_window_create(surface,
                                                       width,
                                                       height);
if (egl_window == NULL) {
    // handle error
}
#+end_example

** C++ control browser

*** firefox
#+begin_example
Write Linux C++ code that controls firefox.

#include <iostream>
#include <string>
#include <stdlib.h>
#include <unistd.h>
using namespace std;

int main() 
{
    string firefoxPath = "/usr/bin/firefox";
    string firefoxCommand = firefoxPath + " &";
    system(firefoxCommand.c_str());
    sleep(2); // give Firefox time to launch

    // Here is where you would add your code to control Firefox
    // For example, you might want to navigate to a specific URL
    string navigateCommand = firefoxPath + " -url http://www.example.com";
    system(navigateCommand.c_str());
    sleep(2); // give Firefox time to navigate

    // You could also add code to close Firefox
    string closeCommand = firefoxPath + " -remote 'quit'";
    system(closeCommand.c_str());

    return 0;
}
#+end_example

- is that possible. it seems reasonable

*** chrome x11

#+begin_example
Write Linux C++ code that controls chrome.

#include <stdio.h>
#include <iostream>
#include <string>
#include <X11/Xlib.h>
#include <X11/keysym.h>
 
// Function to simulate user input of a key
void send_key(Display *display, KeySym key)
{
    XTestFakeKeyEvent(display, XKeysymToKeycode(display, key), True, 0);
    XFlush(display);
    XTestFakeKeyEvent(display, XKeysymToKeycode(display, key), False, 0);
    XFlush(display);
}
 
// Function to open Chrome
void open_chrome(Display *display)
{
    std::string command = "google-chrome &";
    system(command.c_str());
 
    // Wait until Chrome is open
    while (true)
    {
        Window window;
        int revert;
        XGetInputFocus(display, &window, &revert);
 
        char *wm_name;
        XFetchName(display, window, &wm_name);
 
        if (wm_name != NULL)
        {
            std::string name(wm_name);
            XFree(wm_name);
            if (name.find("Google Chrome") != std::string::npos)
            {
                break;
            }
        }
    }
}
 
// Main function
int main()
{
    Display *display = XOpenDisplay(NULL);
 
    // Open Chrome
    open_chrome(display);
 
    // Send a key to control Chrome
    send_key(display, XK_F5);
 
    return 0;
}

#+end_example
*** chrome wayland
- modified it to compile
#+begin_example

// g++ chrome.cpp  -lwayland-client
#include <iostream>
#include <string>
#include <wayland-client.h>

int main(int argc, char* argv[])
{
    wl_display *display = wl_display_connect(NULL);
    if (!display)
    {
        std::cerr << "Failed to connect to Wayland display" << std::endl;
        return -1;
    }

    wl_registry *registry = wl_display_get_registry(display);
    if (!registry)
    {
        std::cerr << "Failed to get registry from Wayland display" << std::endl;
        return -1;
    }

    auto *compositor = wl_registry_bind(registry, 1, &wl_compositor_interface, 1);
    if (!compositor)
    {
        std::cerr << "Failed to bind compositor" << std::endl;
        return -1;
    }

    wl_surface *surface = wl_compositor_create_surface((wl_compositor*)compositor);
    if (!surface)
    {
        std::cerr << "Failed to create surface" << std::endl;
        return -1;
    }

    auto *shell = wl_registry_bind(registry, 2, &wl_shell_interface, 1);
    if (!shell)
    {
        std::cerr << "Failed to bind shell" << std::endl;
        return -1;
    }

    wl_shell_surface *shell_surface = wl_shell_get_shell_surface((wl_shell*)shell, surface);
    if (!shell_surface)
    {
        std::cerr << "Failed to get shell surface" << std::endl;
        return -1;
    }

    // Set the title of the window
    wl_shell_surface_set_title(shell_surface, "My Chrome Window");

    // Launch chrome
    std::string chrome_command = "/usr/bin/google-chrome-stable";
    system(chrome_command.c_str());

    return 0;
}

#+end_example

- inject keys

#+begin_example

Write Linux C++ code that controls chrome in wayland. Inject key commands.

#include <iostream>
#include <wayland-client.h>
#include <wayland-server.h>
#include <xkbcommon/xkbcommon.h>

using namespace std;

int main()
{
    // Create a Wayland display and connect to it
    wl_display* display = wl_display_connect(NULL); // connect to the default Wayland display
    if (!display) {
        cerr << "Failed to connect to Wayland display" << endl;
        return -1;
    }

    // Initialize the Wayland registry
    wl_registry* registry = wl_display_get_registry(display);
    wl_registry_add_listener(registry, &registry_listener, NULL);
    wl_display_dispatch(display);

    // Find the Chrome window and activate it
    wl_surface* surface = wl_compositor_create_surface(compositor); // create a wayland surface for Chrome
    if (!surface) {
        cerr << "Failed to create wayland surface" << endl;
        return -1;
    }

    // Send key commands to the Chrome window
    xkb_keymap* keymap = xkb_keymap_new_from_names(NULL, NULL, XKB_KEYMAP_COMPILE_NO_FLAGS);
    xkb_state* state = xkb_state_new(keymap);
    xkb_keysym_t key;

    // Send the 'Ctrl+T' key command
    key = xkb_keysym_from_name("Ctrl_L", XKB_KEYSYM_CASE_INSENSITIVE);
    xkb_state_update_key(state, key, XKB_KEY_DOWN);
    key = xkb_keysym_from_name("T", XKB_KEYSYM_CASE_INSENSITIVE);
    xkb_state_update_key(state, key, XKB_KEY_DOWN);
    wl_keyboard_send_key(keyboard, 0, 0, WL_KEYBOARD_KEY_STATE_PRESSED, key);
    wl_keyboard_send_key(keyboard, 0, 0, WL_KEYBOARD_KEY_STATE_RELEASED, key);
    xkb_state_update_key(state, key, XKB_KEY_UP);
    xkb_state_update_key(state, key, XKB_KEY_UP);

    // Free all the resources
    xkb_keymap_unref(keymap);
    xkb_state_unref(state);
    wl_surface_destroy(surface);
    wl_registry_destroy(registry);
    wl_display_disconnect(display);

    return 0;
}
#+end_example

** wireshark lua dissector

#+begin_example

Write LUA dissector for wireshark for a simple UDP Packet that contains a 32bit length followed by the data.

-- declare protocol
local myproto = Proto("myproto", "My Protocol")

-- declare fields
local f_length = ProtoField.uint32("myproto.length", "Length")
local f_data = ProtoField.string("myproto.data", "Data")

-- add fields to protocol
myproto.fields = {f_length, f_data}

-- declare dissector function
function myproto.dissector(buffer, pinfo, tree)
	local length = buffer(0, 4):uint()
	local data = buffer(4):string()

	-- add protocol to tree
	local subtree = tree:add(myproto, buffer(0))

	-- add fields to protocol
	subtree:add(f_length, buffer(0,4)):append_text(" (" .. length .. " bytes)")
	subtree:add(f_data, buffer(4,length))
end

-- register protocol
udp_table = DissectorTable.get("udp.port")
udp_table:add(80, myproto)
#+end_example

** Fit sigmoid

- Fit a sigmoid function to an edge assuming quasi-poissonian noise.

- A sigmoid function can be fit to an edge by minimizing the sum of
  squares of the residuals between the model and the data. This can be
  done using a least squares algorithm, such as gradient descent. The
  model should be adjusted to account for the quasi-poissonian noise,
  by including a term in the cost function that penalizes
  outliers. This can be done by adding a penalty term to the cost
  function that is proportional to the difference between the model
  and the data.


#+begin_example
Implement code in R. Load a 1D array from a CSV file. Fit a sigmoid function to an edge assuming quasi-poissonian noise.

# Load necessary packages
library(ggplot2)

# Read the CSV file and store the data in a variable
data <- read.csv("filename.csv")

# Fit the sigmoid function to the data
fit <- nls(data$y ~ SSlogis(data$x, Asym, xmid, scal), start=list(Asym=1, xmid=0, scal=1), trace=FALSE)

# Plot the fitted sigmoid function
ggplot(data, aes(x,y)) +
  geom_point() +
  stat_function(fun = SSlogis, args = coef(fit))

#+end_example

** Ransac

*** Python
#+begin_example
Implement Python code to make a robust fit of a linear function using RANSAC.

import numpy as np
from sklearn.linear_model import RANSACRegressor

# Generate random data
x = np.random.rand(100, 1)
y = 2 + 3 * x + np.random.randn(100, 1)

# Fit line using all data
model = RANSACRegressor()
model.fit(x, y)

# Robustly fit linear model with RANSAC algorithm
model_ransac = RANSACRegressor(residual_threshold=1.0)
model_ransac.fit(x, y)
inlier_mask = model_ransac.inlier_mask_
outlier_mask = np.logical_not(inlier_mask)

# Predict data of estimated models
line_X = np.arange(x.min(), x.max())[:, np.newaxis]
line_y = model.predict(line_X)
line_y_ransac = model_ransac.predict(line_X)

# Compare estimated coefficients
print(model.coef_,model_ransac.estimator_.coef_)
#+end_example

*** R

#+begin_example
Implement R code to make a robust fit of a linear function using RANSAC.

# Load the necessary libraries
library(MASS)
library(robustbase)

# Set the data
x <- c(1, 2, 3, 4, 5, 100, 101, 102, 103, 104)
y <- c(1, 1.9, 3.2, 4.2, 5.3, 300, 300.1, 300.3, 300.4, 300.5)

# Fit the RANSAC model
model <- ransac(x, y, LinearModel, n = 1000, thresh = 0.1)

# Print the model
print(model)
#+end_example

*** FORTH

#+begin_example
Implement FORTH code to make a robust fit of a linear function using RANSAC.


: ransac ( n m-max n-iters -- )
    0 SWAP 0 SWAP  \ n m-max n-iters 0 0
    BEGIN
        DUP 0 > WHILE \ n m-max n-iters k
        DUP 1 + SWAP  \ n m-max n-iters k+1
        \ Generate random samples
        2DUP 3 PICK  \ n m-max n-iters k+1 n n-iters
        n-iters SAMPLE \ n m-max n-iters k+1 nSample
        nSample MODEL-FIT   \ n m-max n-iters k+1 m b
        \ Calculate error of the model
        DUP 5 PICK 5 PICK \ n m-max n-iters k+1 m b n m
        n m MODEL-EVALUATE \ n m-max n-iters k+1 m b error
        error m-max < IF
            \ Update best model
            \ m-max m b
            3 PICK 3 PICK 3 PICK \ m-max m b m-max m b
            SWAP ROT \ m-max m b m b m-max
            SWAP \ m-max m b m-max m b
        THEN
        DROP DROP DROP \ n m-max n-iters
    REPEAT
    \ m-max m b
    3 PICK 3 PICK 3 PICK \ m-max m b m-max m b
    SWAP ROT \ m-max m b m b m-max
    DROP DROP DROP DROP DROP \

#+end_example
- not sure if this works, looks wrong



#+begin_example

Implement C++20 code to make a robust fit of a linear function using RANSAC.

#include <iostream>
#include <vector>
#include <random>
#include <algorithm>

// Define the linear equation
struct LinearEquation {
    double m;  // Slope
    double b;  // Intercept
};

// Calculate the RSS (residual sum of squares)
double CalculateRSS(const LinearEquation& equation, const std::vector<std::pair<double, double>>& data) {
    double rss = 0.0;
    for (size_t i = 0; i < data.size(); ++i) {
        double error = data[i].second - (equation.m * data[i].first + equation.b);
        rss += error * error;
    }
    return rss;
}

// Fit a linear equation using RANSAC
LinearEquation FitLinearEquation(const std::vector<std::pair<double, double>>& data, int iterations, double error_threshold) {
    // Set up random number generator
    std::default_random_engine generator;
    std::uniform_int_distribution<int> distribution(0, data.size() - 1);

    // Initialize variables
    LinearEquation best_equation;
    double best_rss = std::numeric_limits<double>::max();
    int best_inliers = 0;

    // Run RANSAC iterations
    for (int i = 0; i < iterations; ++i) {
        // Choose two random points
        int idx1 = distribution(generator);
        int idx2 = distribution(generator);
        while (idx1 == idx2) {
            idx2 = distribution(generator);
        }
        double x1 = data[idx1].first;
        double y1 = data[idx1].second;
        double x2 = data[idx2].first;
        double y2 = data[idx2].second;

        // Fit a linear equation using the two points
        LinearEquation equation;
        equation.m = (y2 - y1) / (x2 - x1);
        equation.b = y1 - equation.m * x1;

        // Count the number of inliers
        int inliers = 0;
        for (size_t i = 0; i < data.size(); ++i) {
            double y_predicted = equation.m * data[i].first + equation.b;
            double error = std::abs(y_predicted - data[i].second);
            if (error < error_threshold) {
                ++inliers;
            }
        }

        // Update the best equation
        if (inliers > best_inliers) {
            best_inliers = inliers;
            best_equation = equation;
            best_rss = CalculateRSS(equation, data);
        }
    }

    return best_equation;
}

// Test the function
int main() {
    // Generate data points
    std::vector<std::pair<double, double>> data;
    for (int i = -30; i < 30; ++i) {
        double x = static_cast<double>(i);
        double y = 3.5 * x + 4.2;
        data.emplace_back(x, y + static_cast<double>((std::rand() % 101) - 50));
    }

    // Fit the linear equation
    LinearEquation equation = FitLinearEquation(data, 1000, 10.0);

    // Print the result
    std::cout << "m = " << equation.m << ", b = " << equation.b << std::endl;

    return 0;
}
#+end_example

- again a bit different
#+begin_example

Implement modern C++20 code to make a robust fit of a linear function using RANSAC.

#include <algorithm>
#include <numeric>
#include <random>
#include <vector>

// A linear function is of the form y = mx + c
struct LinearFunction {
    double m;
    double c;
};

// A point on a 2D plane
struct Point {
    double x;
    double y;
};

// Represents a set of points and the corresponding linear function
struct Model {
    std::vector<Point> points;
    LinearFunction fn;
};

// Calculates the distance between a point and a linear function
double distance(const Point& pt, const LinearFunction& fn)
{
    return std::abs(pt.y - (fn.m * pt.x + fn.c));
}

// Fits a linear function to the given points using RANSAC
LinearFunction fit(const std::vector<Point>& points, int nIter, double threshold)
{
    LinearFunction bestModel;
    int bestScore = 0;

    // Use a random number generator
    std::random_device rd;
    std::mt19937 gen(rd());

    // Repeat the iterations multiple times
    for(int i = 0; i < nIter; ++i) {
        // Select two random points
        std::vector<Point> modelPoints(2);
        std::sample(points.begin(), points.end(), modelPoints.begin(), 2, gen);

        // Calculate the linear function for the two points
        LinearFunction model;
        model.m = (modelPoints[1].y - modelPoints[0].y) / (modelPoints[1].x - modelPoints[0].x);
        model.c = modelPoints[1].y - (model.m * modelPoints[1].x);

        // Count the number of points close to the linear function
        int score = 0;
        for(const Point& pt : points) {
            if(distance(pt, model) < threshold) {
                ++score;
            }
        }

        // Update the best model
        if(score > bestScore) {
            bestScore = score;
            bestModel = model;
        }
    }

    return bestModel;
}

int main() {
    // Define a set of points
    std::vector<Point> points = {
        {1, 2},
        {2, 3},
        {3, 4},
        {4, 5},
        {5, 6},
    };

    // Fit a linear function to the points using RANSAC
    LinearFunction fn = fit(points, 10, 0.5);

    // Print the result
    std::cout << "m: " << fn.m << ", c: " << fn.c << '\n';
}
#+end_example

- use SIMD (still double)

#+begin_example

Implement modern C++20 code to make a robust fit of a linear function using RANSAC. Use SIMD instructions.

#include <algorithm>
#include <numeric>
#include <array>
#include <cmath>
#include <immintrin.h>

// A structure to hold the result of a RANSAC fit
struct LinearFitRansacResult {
    double a;
    double b;
    double error;
};

// A structure to hold the data points for a linear fit
struct LinearFitData {
    double x[256];
    double y[256];
    int nPoints;
};

// A function to compute the least-squares error of a linear fit
double compute_least_squares_error(const LinearFitData &data, double a, double b) {
    double sum_err_sq = 0.0;

    // Compute the sum of the squared errors using SIMD instructions
    __m256d a_vec = _mm256_set1_pd(a);
    __m256d b_vec = _mm256_set1_pd(b);
    __m256d err_sq_vec = _mm256_setzero_pd();
    for (int i = 0; i < data.nPoints; i += 4) {
        __m256d x_vec = _mm256_load_pd(data.x + i);
        __m256d y_vec = _mm256_load_pd(data.y + i);
        __m256d y_pred_vec = _mm256_add_pd(_mm256_mul_pd(a_vec, x_vec), b_vec);
        __m256d err_vec = _mm256_sub_pd(y_vec, y_pred_vec);
        __m256d err_sq_vec = _mm256_mul_pd(err_vec, err_vec);
        err_sq_vec = _mm256_add_pd(err_sq_vec, err_sq_vec);
    }
    std::array<double, 4> err_sq_arr;
    _mm256_store_pd(err_sq_arr.data(), err_sq_vec);
    for (auto err_sq : err_sq_arr) {
        sum_err_sq += err_sq;
    }

    return sum_err_sq;
}

// A function to fit a linear function using RANSAC
LinearFitRansacResult linear_fit_ransac(const LinearFitData &data, int num_iters, double thresh) {
    LinearFitRansacResult result;

    // Initialize the best result
    result.a = 0;
    result.b = 0;
    result.error = std::numeric_limits<double>::infinity();

    // Generate num_iters random samples
    for (int i = 0; i < num_iters; ++i) {
        // Choose two random points
        int idx1 = std::rand() % data.nPoints;
        int idx2 = std::rand() % data.nPoints;

        // Compute the coefficients of the line passing through the two points
        double x1 = data.x[idx1];
        double x2 = data.x[idx2];
        double y1 = data.y[idx1];
        double y2 = data.y[idx2];
        double a = (y2 - y1) / (x2 - x1);
        double b = y1 - (a * x1);

        // Compute the error of the line
        double error = compute_least_squares_error(data, a, b);

        // Update the best result if the error is lower than the threshold
        if (error < thresh && error < result.error) {
            result.a = a;
            result.b = b;
            result.error = error;
        }
    }

    return result;
}
#+end_example

- SIMD single float

#+begin_example
Implement modern C++20 code to make a robust fit of a linear function (in single float datatype) using RANSAC. Use SIMD instructions.

#include <array>
#include <numeric>
#include <algorithm>
#include <xmmintrin.h>

auto robust_fit_linear_function_ransac_simd(const std::array<float, N>& data,
                                           float threshold,
                                           unsigned int max_iterations)
{
    float a{0}, b{0};
    float best_error = std::numeric_limits<float>::max();

    __m128 x, y, x2, xy;
    int count = 0;

    for (unsigned int i = 0; i < max_iterations; ++i) {
        // Generate random indices
        std::array<int, 2> indices;
        std::generate(indices.begin(), indices.end(), [&] { return std::rand() % data.size(); });

        // Load random data into SIMD registers
        x = _mm_load_ps(&data[indices[0]]);
        y = _mm_load_ps(&data[indices[1]]);

        // Compute quantities
        x2 = _mm_mul_ps(x, x);
        xy = _mm_mul_ps(x, y);

        // Calculate coefficients
        __m128 coeffs = _mm_div_ps(xy, x2);
        a = coeffs[0];
        b = coeffs[1];

        // Calculate error
        float error = 0;
        for (int j = 0; j < data.size(); j += 4) {
            x  = _mm_load_ps(&data[j]);
            y  = _mm_load_ps(&data[j+1]);

            __m128 predicted = _mm_add_ps(_mm_mul_ps(x, _mm_set1_ps(a)), _mm_set1_ps(b));
            __m128 diff      = _mm_sub_ps(predicted, y);
            __m128 sq_diff   = _mm_mul_ps(diff, diff);

            error += sq_diff[0] + sq_diff[1] + sq_diff[2] + sq_diff[3];
        }

        // Update best fit
        if (error < best_error) {
            best_error = error;
            a = coeffs[0];
            b = coeffs[1];
            count = 1;
        } else if (error - best_error < threshold) {
            count++;
        }
    }

    return std::make_pair(a, b);
}
#+end_example

*** Cuda
#+begin_example
Implement Cuda code to make a robust fit of a linear function using RANSAC.

__global__ void ransac(float *x, float *y, int n, float *a, float *b, float *residual){
    int idx = threadIdx.x + blockDim.x * blockIdx.x;
    if (idx < n){
        float a_t = 0.0f;
        float b_t = 0.0f;
        float sum_x = 0.0f;
        float sum_y = 0.0f;
        float sum_xy = 0.0f;
        float sum_x2 = 0.0f;
        int sample_size = 0;
        for (int i = 0; i < n; ++i){
            int rand_idx = rand() % n;
            sum_x += x[rand_idx];
            sum_y += y[rand_idx];
            sum_xy += x[rand_idx] * y[rand_idx];
            sum_x2 += x[rand_idx] * x[rand_idx];
            sample_size++;
        }
        //Calculate line parameters
        a_t = (sum_x * sum_y - sample_size * sum_xy) / (sum_x * sum_x - sample_size * sum_x2);
        b_t = (sum_x * sum_xy - sum_y * sum_x2) / (sum_x * sum_x - sample_size * sum_x2);
        //Calculate residual
        float sum_residual = 0.0f;
        for (int i = 0; i < n; ++i){
            sum_residual += (y[i] - a_t * x[i] - b_t) * (y[i] - a_t * x[i] - b_t);
        }
        a[idx] = a_t;
        b[idx] = b_t;
        residual[idx] = sum_residual;
    }
} 

//Call the kernel
dim3 blockSize(64, 1, 1);
dim3 gridSize(ceil(n/64.0f), 1, 1);
ransac<<<gridSize, blockSize>>>(x, y, n, a, b, residual);
#+end_example

*** C#

#+begin_example
Implement C# code to make a robust fit of a linear function using RANSAC.

using System;
using System.Collections.Generic;
 
//The point class to store x and y coordinates 
public class Point
{
    public double x;
    public double y;
 
    public Point(double x, double y)
    {
        this.x = x;
        this.y = y;
    }
}
 
public class RANSAC
{
    //The list of points
    List<Point> points;
 
    //The parameters of the linear function
    double m;
    double b;
 
    //The maximum distance from the line for a point to be considered as an inlier
    double inlierThreshold;
 
    //The minimum number of inliers for the linear function to be considered as a robust fit
    int minInliers;
 
    //The maximum number of iterations for the algorithm
    int maxIterations;
 
    public RANSAC(List<Point> points, double inlierThreshold, int minInliers, int maxIterations)
    {
        this.points = points;
        this.inlierThreshold = inlierThreshold;
        this.minInliers = minInliers;
        this.maxIterations = maxIterations;
    }
 
    public void Fit()
    {
        //The number of iterations
        int iterations = 0;
 
        //The number of inliers
        int numInliers = 0;
 
        //The best model
        double bestM = 0;
        double bestB = 0;
 
        //The random number generator
        Random rand = new Random();
 
        //The list of inliers
        List<Point> bestInliers = new List<Point>();
 
        //Keep iterating until the maximum number of iterations is reached
        while (iterations < maxIterations)
        {
            //Choose two random points
            int i1 = rand.Next(points.Count);
            int i2 = rand.Next(points.Count);
 
            //Calculate the linear parameters (m and b)
            double x1 = points[i1].x;
            double y1 = points[i1].y;
            double x2 = points[i2].x;
            double y2 = points[i2].y;
            m = (y2 - y1) / (x2 - x1);
            b = y1 - (m * x1);
 
            //Reset the inliers
            numInliers = 0;
            List<Point> inliers = new List<Point>();
 
            //Loop over all points and count the inliers
            for (int i = 0; i < points.Count; i++)
            {
                //Calculate the distance of the point from the line
                double x = points[i].x;
                double y = points[i].y;
                double dist = Math.Abs(y - (m * x + b));
 
                //Check if the point is an inlier
                if (dist < inlierThreshold)
                {
                    numInliers++;
                    inliers.Add(points[i]);
                }
            }
 
            //Check if the model is better
            if (numInliers > minInliers && numInliers > bestInliers.Count)
            {
                bestInliers = inliers;
                bestM = m;
                bestB = b;
            }
 
            iterations++;
        }
 
        //Store the best model
        m = bestM;
        b = bestB;
    }
 
    //The linear function
    public double f(double x)
    {
        return m * x + b;
    }
 
    //The y co-ordinate of the linear function at the given x co-ordinate
    public double GetY(double x)
    {
        return f(x);
    }
}

#+end_example

*** Go

#+begin_example

Implement Go code to make a robust fit of a linear function using RANSAC.

package main

import (
	"fmt"
)

// A linear function is a function of the form y = mx + b
type LinearFunction struct {
	m float64 // Slope of the line
	b float64 // Y-intercept
}

// A point is a pair of x-y coordinates
type Point struct {
	x float64
	y float64
}

// This function takes a list of points and attempts to find a robust fit of a linear function using RANSAC.
// It returns a LinearFunction that best fits the points.
func RANSAC(points []Point) LinearFunction {
	// Set the number of iterations and the inlier threshold
	iterations := 1000
	inlierThreshold := 0.1

	// Initialize best fit to an empty LinearFunction
	bestFit := LinearFunction{}

	// Iterate for the specified number of iterations
	for i := 0; i < iterations; i++ {
		// Randomly select two points from the list
		p1 := points[rand.Intn(len(points))]
		p2 := points[rand.Intn(len(points))]

		// Calculate the slope and y-intercept of the line between the two points
		m := (p2.y - p1.y) / (p2.x - p1.x)
		b := p2.y - m*p2.x

		// Create a LinearFunction with the calculated slope and y-intercept
		line := LinearFunction{m, b}

		// Count the number of inliers
		inliers := 0
		for _, p := range points {
			// Calculate the difference between the actual y-value and the y-value predicted by the line
			diff := p.y - (m*p.x + b)
			// If the difference is within the inlier threshold, count it as an inlier
			if math.Abs(diff) < inlierThreshold {
				inliers++
			}
		}

		// If the line has more inliers than the best fit so far, update the best fit
		if inliers > bestFit.inliers {
			bestFit = line
		}
	}

	// Return the best fit
	return bestFit
}

func main() {
	// Create a list of points
	points := []Point{{1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}, {6, 7}}

	// Find the best fit using RANSAC
	bestFit := RANSAC(points)

	// Print the best fit
	fmt.Printf("Best fit: y = %fx + %f\n", bestFit.m, bestFit.b)
}
#+end_example

*** Rust

#+begin_example
Implement Rust code to make a robust fit of a linear function using RANSAC.

use ransac::{ransac, Estimator};

// Define our struct that implements Estimator
#[derive(Copy, Clone)]
struct LinearRegression {
    x_mean: f64,
    y_mean: f64,
    x_term: f64,
    y_term: f64,
    xy_term: f64
}

impl Estimator<f64, (f64, f64)> for LinearRegression {
    fn estimate(&self, data: &[(f64, f64)]) -> Option<f64> {
        let mut slope = (self.xy_term - self.x_term * self.y_mean) / (self.x_term * self.x_mean - self.xy_term);
        let mut intercept = self.y_mean - slope * self.x_mean;

        Some((slope, intercept))
    }
    
    fn is_model_valid(&self, data: &[(f64, f64)], _model: &f64) -> bool {
        let (slope, intercept) = self.estimate(data).unwrap();
        let mut residual_sum = 0.;

        for (x, y) in data {
            let predicted_y = slope * x + intercept;
            let residual = (y - predicted_y).powi(2);
            residual_sum += residual;
        }

        // If the residual_sum is below a certain threshold, we consider the model valid
        residual_sum < 0.01
    }
}

fn main() {
    let data = vec![
        (1.0, 0.3),
        (2.0, 0.5),
        (3.0, 0.8),
        (4.0, 1.2),
        (5.0, 1.4)
    ];
   
    let (x_mean, y_mean, x_term, y_term, xy_term) = linear_regression(&data);
    let estimator = LinearRegression {
        x_mean,
        y_mean,
        x_term,
        y_term,
        xy_term
    };

    let (slope, intercept) = ransac(&data, &estimator, 4).unwrap();
    println!("Slope: {:.2}, Intercept: {:.2}", slope, intercept);
}

// Helper function to calculate linear regression parameters
fn linear_regression(data: &[(f64, f64)]) -> (f64, f64, f64, f64, f64) {
    let (mut x_sum, mut y_sum, mut x_term, mut y_term, mut xy_term) = (0., 0., 0., 0., 0.);

    for (x, y) in data {
        x_sum += x;
        y_sum += y;
        x_term += x * x;
        y_term += y * y;
        xy_term += x * y;
    }

    let n = data.len() as f64;
    let x_mean = x_sum / n;
    let y_mean = y_sum / n;

    (x_mean, y_mean, x_term, y_term, xy_term)
}
#+end_example

*** Erlang

#+begin_example

Implement Erlang code to make a robust fit of a linear function using RANSAC.

-module(ransac).
-export([fit/1]).

fit(DataSet) ->
	MaxIterations = 10,
	MinInliers = floor(length(DataSet) / 2),
	BestFit = [],
	BestError = infinity,
	BestInliers = [],
	for iteration = 1 to MaxIterations do
		Sample = take_sample(DataSet),
		Fit = linear_regression(Sample),
		Error = get_error(DataSet, Fit),
		Inliers = get_inliers(DataSet, Error),
		if length(Inliers) > MinInliers and Error < BestError then
			BestFit = Fit,
			BestError = Error,
			BestInliers = Inliers
		end
	end,
	{BestFit, BestError, BestInliers}.

take_sample(DataSet) ->
	random:uniform(length(DataSet)),
	[DataSet[Index] || Index <- random:uniform(length(DataSet))].

linear_regression(Sample) ->
	[Slope, Intercept] = linear_regression_fit(Sample),
	{Slope, Intercept}.

get_error(DataSet, Fit) ->
	[{X, Y} || {X, Y} <- DataSet],
	[abs(Y - (Fit#{slope} * X + Fit#{intercept})) || {X, Y} <- DataSet].

get_inliers(DataSet, Error) ->
	Threshold = mean(Error),
	[DataSet[Index] || {Index, Err} <- lists:zip(lists:seq(1, length(DataSet)), Error), Err < Threshold].
#+end_example

*** Elixir

#+begin_example

Implement Elixir code to make a robust fit of a linear function using RANSAC.

defmodule RANSAC do
  @doc """
  Robust linear fit with RANSAC

  ## Examples
    iex> RANSAC.fit([{1,2}, {2,4}, {3,6}, {4,5}])
    {a: 1.0, b: 2.0}
  """
  def fit(points) do
    # Set the parameters for RANSAC
    n_samples = 3
    max_iterations = 1000
    min_inliers = 3
    inlier_tolerance = 0.5

    # Calculate the total number of samples
    total_samples = length(points)

    # Initialize the inlier count and best fit parameters
    inlier_count = 0
    best_fit_params = {a: 0, b: 0}

    # Repeat until max iteration is reached
    1..max_iterations
    |> Enum.each(fn _ ->
      # Select a random sample of points
      sample = Enum.take(Enum.random_member(points, n_samples), n_samples)

      # Fit the linear model
      fit_params = fit_linear_model(sample)

      # Count the inliers
      inlier_count = count_inliers(points, fit_params, inlier_tolerance)

      # Update the best fit parameters if necessary
      if inlier_count >= min_inliers, do: best_fit_params = fit_params
    end)

    # Return the best fit parameters
    best_fit_params
  end

  # Fit a linear model
  defp fit_linear_model(points) do
    # Calculate the sums
    x_sum = Enum.reduce(points, 0, &(&1 + elem(&2, 0)))
    y_sum = Enum.reduce(points, 0, &(&1 + elem(&2, 1)))
    xy_sum = Enum.reduce(points, 0, &(&1 + elem(&2, 0) * elem(&2, 1)))
    x2_sum = Enum.reduce(points, 0, &(&1 + elem(&2, 0) * elem(&2, 0)))

    # Calculate the parameters
    n = length(points)
    a = (n * xy_sum - x_sum * y_sum) / (n * x2_sum - x_sum * x_sum)
    b = (x2_sum * y_sum - x_sum * xy_sum) / (n * x2_sum - x_sum * x_sum)

    # Return the parameters
    {a: a, b: b}
  end

  # Count the inliers
  defp count_inliers(points, fit_params, tolerance) do
    Enum.reduce(points, 0, fn point, count ->
      # Calculate the distance from the point to the line
      x = elem(point, 0)
      y = elem(point, 1)
      a = fit_params[:a]
      b = fit_params[:b]
      distance = abs(y - (a * x + b))

      # Check if the point is within the tolerance
      if distance <= tolerance, do: count + 1, else: count
    end)
  end
end
#+end_example

*** Common Lisp
#+begin_example
Implement Common Lisp code to make a robust fit of a linear function using RANSAC.

(defun robust-fit (data)
  (let* ((n (length data))
         (max-iterations (ceiling (1+ (/ n 2))))
         (inlier-threshold 0.5)
         (best-fit nil)
         (best-inliers nil))
    (dotimes (i max-iterations)
      (let* ((sample (subseq data (random 0 (- n 2))))
             (model (fit-line sample))
             (inliers (ransac-inliers data model inlier-threshold)))
        (when (> (length inliers) (length best-inliers))
          (setf best-fit model
                best-inliers inliers))))
    (values best-fit best-inliers)))

(defun fit-line (data)
  (let* ((x-sum 0)
         (y-sum 0)
         (x2-sum 0)
         (xy-sum 0)
         (n (length data)))
    (dolist (datum data)
      (let* ((x (car datum))
             (y (cdr datum)))
        (incf x-sum x)
        (incf y-sum y)
        (incf x2-sum (* x x))
        (incf xy-sum (* x y))))
    (let* ((denom (- (* n x2-sum) (expt x-sum 2)))
           (a (/ (- (* n xy-sum) (* x-sum y-sum)) denom))
           (b (- (/ y-sum n) (* a (/ x-sum n)))))
      (values a b))))

(defun ransac-inliers (data model inlier-threshold)
  (let ((inliers (list)))
    (dolist (datum data)
      (let ((x (car datum))
            (y (cdr datum))
            (a (car model))
            (b (cadr model))
            (y-expected (- (* a x) b)))
        (when (< (abs (- y y-expected)) inlier-threshold)
          (push datum inliers))))
    inliers))
#+end_example

*** Emacs Lisp
#+begin_example

Implement Emacs Lisp code to make a robust fit of a linear function using RANSAC.

(defun ransac-fit (data)
  "Robustly fit a line to DATA using RANSAC algorithm."
  (let ((iterations 1000)
	(threshold 0.1)
	(best-parameters nil))
    (dotimes (i iterations)
      ;; Randomly select two points from the data
      (let ((index1 (random (length data)))
	    (index2 (random (length data))))
	(let* ((point1 (elt data index1))
	       (point2 (elt data index2))
	       (slope (/ (- (cadr point2) (cadr point1))
			 (- (car point2) (car point1))))
	       (intercept (- (cadr point1) (* slope (car point1)))))
	  ;; Calculate the distance between each point and the line
	  (let ((inliers '()))
	    (dolist (point data)
	      (let ((d (abs (- (cadr point) (+ (* slope (car point)) intercept)))))
		(when (< d threshold)
		  (push point inliers))))
	    ;; Update best parameters if we have more inliers
	    (when (> (length inliers) (length best-parameters))
	      (setq best-parameters (list slope intercept inliers))))))
    best-parameters))
#+end_example

** Savgol filter

*** Python
#+begin_example
Implement Python code that applies a Savitzky-Golay filter  over a 1D data set of 1024 single float values. Use a filter window of 17 points and a polynomial order of 3.

import numpy as np
from scipy.signal import savgol_filter

# Create a 1D array of 1024 single float values
data = np.random.rand(1024)

# Apply Savitzky-Golay filter 
savgol_data = savgol_filter(data, 17, 3)

print(savgol_data)
#+end_example

*** C++ 
#+begin_example
Implement modern C++20 code that applies a Savitzky-Golay filter  over a 1D data set of 1024 single float values. Use a filter window of 17 points and a polynomial order of 3.

#include <ranges>
#include <numeric>
#include <vector>

//Function to apply the Savitzky-Golay filter
std::vector<float> savitzky_golay_filter(std::vector<float> data, int window, int order) {

	//Calculate number of coefficients
    int num_coeff = (2 * window) + 1;

	//Create vector of coefficients
    std::vector<float> coeff(num_coeff);
	
	//Calculate coefficients
    for (int i = 0; i < num_coeff; ++i) {
        float sum = 0.0f;
        for (int j = 0; j < (num_coeff + 1); ++j) {
            sum += std::pow(-1.0f, j) * std::pow(i - (num_coeff - 1.0f) / 2.0f, j);
        }
        coeff[i] = sum / std::pow((num_coeff - 1.0f) / 2.0f, order);
    }
	
	//Create vector to store filtered data
    std::vector<float> filtered(data.size());
	
	//Filter data with the Savitzky-Golay filter
    for (int i = 0; i < data.size(); ++i) {
        int start = std::max(0, i - (num_coeff - 1) / 2);
        int end = std::min(data.size() - 1, i + (num_coeff - 1) / 2);
        filtered[i] = std::inner_product(std::begin(data) + start, std::begin(data) + end + 1, std::begin(coeff), 0.0f);
    }
	
	//Return filtered data
    return filtered;
}

int main() {
	//Create vector of 1024 single float values
    std::vector<float> data(1024);
	
	//Populate vector with values
    for (int i = 0; i < data.size(); ++i) {
        data[i] = i;
    }
	
	//Apply Savitzky-Golay filter
    std::vector<float> filtered = savitzky_golay_filter(data, 17, 3);
	
	return 0;
}
#+end_example

*** C++17

#+begin_example

Implement modern C++17 code that applies a Savitzky-Golay filter  over a 1D data set of 1024 single float values. 

#include <vector>
#include <algorithm>
#include <numeric>

// Savitzky-Golay filter of order k
std::vector<float> SavitzkyGolayFilter(const std::vector<float>& data, int k)
{
	// Data size must be greater than the filter order
	if (data.size() < k)
		return data;

	// Create the result array
	std::vector<float> result(data.size(), 0.0f);

	// Iterate over every element in the dataset
	for (int i = 0; i < data.size(); ++i)
	{
		// Calculate the weights for the current window
		float weightsSum = 0.0f;
		std::vector<float> weights(k);
		for (int j = 0; j < k; ++j)
		{
			int n = i - (k - 1) / 2 + j;
			if (n < 0)
				n = 0;
			else if (n > data.size() - 1)
				n = data.size() - 1;
			weights[j] = data[n];
			weightsSum += weights[j];
		}

		// Calculate the weighted sum
		float weightedSum = 0.0f;
		for (int j = 0; j < k; ++j)
		{
			weightedSum += weights[j] * data[i - (k - 1) / 2 + j];
		}

		// Calculate the result for the current element
		result[i] = weightedSum / weightsSum;
	}

	return result;
}

int main()
{
	// Create a 1D data set of 1024 single float values
	std::vector<float> data(1024);
	std::iota(data.begin(), data.end(), 1.0f);
	
	// Apply a Savitzky-Golay filter of order k
	int k = 3;
	std::vector<float> result = SavitzkyGolayFilter(data, k);

	// Print the result
	for (auto& val : result)
		std::cout << val << " ";

	return 0;
}
#+end_example

*** C++ SIMD

#+begin_example

Implement modern C++20 code that applies a Savitzky-Golay filter  over a 1D data set of 1024 single float values. Use a filter window of 17 points and a polynomial order of 3. Speed up the computation with SIMD instructions.

#include <simd/simd.h>

// Savitzky-Golay filter coefficients for a 17-point filter window and a polynomial order of 3
static constexpr float filterCoeffs[17] = {
    -3.0f, -2.5f, -1.5f, -0.5f, 0.5f, 1.5f, 2.5f, 3.0f,
    3.0f,  2.5f,  1.5f,  0.5f, -0.5f, -1.5f, -2.5f, -3.0f
};

// SIMD-accelerated Savitzky-Golay filter
void SavitzkyGolayFilter_SIMD(float* data, const int length)
{
    const int filterLength = 17;
    const int halfFilterLength = filterLength / 2;
    
    simd_float4 runningSum = 0.0f;
    simd_float4 filterCoeffs_SIMD;
    simd_float4 data_SIMD;
    
    // Iterate over the input data
    for (int i = 0; i < length; ++i)
    {
        // Reset running sum
        runningSum = 0.0f;
        
        // Iterate over the filter coefficients
        for (int j = 0; j < filterLength; ++j)
        {
            // Load filter coefficients into SIMD register
            filterCoeffs_SIMD = simd_make_float4(filterCoeffs[j]);
            
            // Calculate the start and end indices for the data
            const int startIdx = i - halfFilterLength + j;
            const int endIdx = startIdx + 4;
            
            // Clamp start and end indices to valid range
            const int clampedStartIdx = startIdx < 0 ? 0 : startIdx;
            const int clampedEndIdx = endIdx > length ? length : endIdx;
            
            // Load 4 data points into SIMD register
            data_SIMD = simd_load(data + clampedStartIdx);
            
            // Calculate the running sum
            runningSum += simd_mul(filterCoeffs_SIMD, data_SIMD);
        }
        
        // Store the result
        data[i] = simd_sum(runningSum);
    }
}
#+end_example
*** Go

#+begin_example
Implement Go code that applies a Savitzky-Golay filter  over a 1D data set of 1024 single float values. Use a filter window of 17 points and a polynomial order of 3. Don't omit code for brevity.

package main 

import (
	"fmt"
)

func main() {
	// Initialize data set with 1024 single float values
	data := []float32{1.2, 2.3, 3.2, 4.1, 5.6, ... , 1024.0}

	// Initialize filter window of 17 points
	var filterWindow int = 17

	// Initialize polynomial order of 3
	var polyOrder int = 3

	// Initialize filteredData with zero values
	filteredData := make([]float32, len(data))

	// Apply Savitzky-Golay filter over 1D data set
	for i := 0; i < len(data); i++ {
		start := i - filterWindow/2
		end := i + filterWindow/2
		if start < 0 {
			start = 0
		}
		if end > len(data)-1 {
			end = len(data) - 1
		}
		subData := data[start : end+1]
		filteredData[i] = savitzkyGolay(subData, polyOrder)
	}

	// Print filteredData
	fmt.Println("Filtered Data:")
	for i := 0; i < len(filteredData); i++ {
		fmt.Println(filteredData[i])
	}
}

func savitzkyGolay(data []float32, polyOrder int) float32 {
	// Initialize filtered data
	var filteredData float32

	// Calculate filtered data
	for i := 0; i < len(data); i++ {
		// Calculate weight for each data point
		weight := float32(math.Pow(-1, float64(i))) * float32(math.Pow(float64(i), float64(polyOrder)))
		filteredData += data[i] * weight
	}

	return filteredData
}

#+end_example
- i'm not sure if this is right

*** Rust
#+begin_example

#include <ranges>
#include <numeric>
#include <vector>

//Function to apply the Savitzky-Golay filter
std::vector<float> savitzky_golay_filter(std::vector<float> data, int window, int order) {

	//Calculate number of coefficients
    int num_coeff = (2 * window) + 1;

	//Create vector of coefficients
    std::vector<float> coeff(num_coeff);
	
	//Calculate coefficients
    for (int i = 0; i < num_coeff; ++i) {
        float sum = 0.0f;
        for (int j = 0; j < (num_coeff + 1); ++j) {
            sum += std::pow(-1.0f, j) * std::pow(i - (num_coeff - 1.0f) / 2.0f, j);
        }
        coeff[i] = sum / std::pow((num_coeff - 1.0f) / 2.0f, order);
    }
	
	//Create vector to store filtered data
    std::vector<float> filtered(data.size());
	
	//Filter data with the Savitzky-Golay filter
    for (int i = 0; i < data.size(); ++i) {
        int start = std::max(0, i - (num_coeff - 1) / 2);
        int end = std::min(data.size() - 1, i + (num_coeff - 1) / 2);
        filtered[i] = std::inner_product(std::begin(data) + start, std::begin(data) + end + 1, std::begin(coeff), 0.0f);
    }
	
	//Return filtered data
    return filtered;
}

int main() {
	//Create vector of 1024 single float values
    std::vector<float> data(1024);
	
	//Populate vector with values
    for (int i = 0; i < data.size(); ++i) {
        data[i] = i;
    }
	
	//Apply Savitzky-Golay filter
    std::vector<float> filtered = savitzky_golay_filter(data, 17, 3);
	
	return 0;
}
#+end_example


** CSV 

*** Read C++
#+begin_example

Implement modern C++17 code that reads 2x1024 single float values from a two columns of a CSV file with the titles "time" and "measurement". The first line of the CSV file contains column titles.  The CSV file may contain more than two columns and the columns we want can be at an arbitrary position. Select the columns by locking at the column titles.



#include <iostream> 
#include <fstream>
#include <sstream>
#include <string> 
#include <vector> 

int main() 
{ 
    std::ifstream csv_file("data.csv");
    std::string line;
    std::vector<float> time;
    std::vector<float> measurement;
    std::string time_title;
    std::string measurement_title;
    int time_column;
    int measurement_column;

    // Get first line with titles
    std::getline(csv_file, line);
    std::stringstream line_stream(line);
    std::string token;
    int column = 0;
    while (std::getline(line_stream, token, ',')) {
        if (token == "time") {
            time_title = token;
            time_column = column;
        }
        else if (token == "measurement") {
            measurement_title = token;
            measurement_column = column;
        }
        column++;
    }

    // Read data 
    while (std::getline(csv_file, line)) {
        std::stringstream line_stream(line);
        column = 0;
        while (std::getline(line_stream, token, ',')) {
            if (column == time_column) {
                time.push_back(std::stof(token));
            }
            else if (column == measurement_column) {
                measurement.push_back(std::stof(token));
            }
            column++;
        }
    }

    // Output the two columns
    for (int i = 0; i < 1024; i++) {
        std::cout << time[i] << ", " << measurement[i] << '\n';
    }

    return 0; 
} 

#+end_example

- bit different. there is no need for SIMD
#+begin_example
Implement modern C++17 code that reads 2x1024 single float values from a two columns of a CSV file with the titles "time" and "measurement". The first line of the CSV file contains column titles.  The CSV file may contain more than two columns and the columns we want can be at an arbitrary position. Select the columns by locking at the column titles. Use SIMD.

#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <array>
#include <numeric>
#include <algorithm>
#include <immintrin.h>

constexpr unsigned int NumValues = 1024;

int main()
{
	std::ifstream csvFile("data.csv");
	std::string line;
	
	// Get column titles
	std::getline(csvFile, line);
	std::stringstream ss(line);
	std::string columnName;
	int timeColumnIndex = -1, measurementColumnIndex = -1;
	int columnIndex = 0;
	while (std::getline(ss, columnName, ','))
	{
		if (columnName == "time")
			timeColumnIndex = columnIndex;
		else if (columnName == "measurement")
			measurementColumnIndex = columnIndex;
		columnIndex++;
	}
	if (timeColumnIndex == -1 || measurementColumnIndex == -1)
	{
		std::cerr << "Error: column titles not found\n";
		return -1;
	}

	// Read data
	std::array<float, NumValues> times;
	std::array<float, NumValues> measurements;
	int index = 0;
	while (std::getline(csvFile, line) && index < NumValues)
	{
		std::stringstream ss(line);
		std::string value;
		int columnIndex = 0;
		while (std::getline(ss, value, ','))
		{
			if (columnIndex == timeColumnIndex)
				times[index] = std::stof(value);
			else if (columnIndex == measurementColumnIndex)
				measurements[index] = std::stof(value);
			columnIndex++;
		}
		index++;
	}

	// Use SIMD to calculate the sum of the measurements
	__m128 sum = _mm_setzero_ps();
	for (int i = 0; i < NumValues; i += 4)
	{
		__m128 measurementVec = _mm_loadu_ps(&measurements[i]);
		sum = _mm_add_ps(sum, measurementVec);
	}
	// Sum the four elements of the vector
	float sum4 = sum[0] + sum[1] + sum[2] + sum[3];
	
	std::cout << "Sum of measurements: " << sum4 << "\n";
	
	return 0;
}

#+end_example

- stringview (c++20)

#+begin_example
Implement modern C++20 code that reads 2x1024 single float values from a two columns of a CSV file with the titles "time" and "measurement". The first line of the CSV file contains column titles.  The CSV file may contain more than two columns and the columns we want can be at an arbitrary position. Select the columns by locking at the column titles. Use SIMD.

#include <filesystem>
#include <fstream>
#include <sstream>
#include <string_view>
#include <vector>

int main() {
    const std::filesystem::path csv_path = "path/to/file.csv";
    std::ifstream csv_file(csv_path);
    std::string line;

    // Find the index of the columns we want:
    std::size_t time_col_index;
    std::size_t measurement_col_index;
    if (std::getline(csv_file, line)) {
        std::istringstream ss(line);
        std::string column_title;
        std::size_t i;
        for (i = 0; std::getline(ss, column_title, ','); ++i) {
            if (column_title == "time") {
                time_col_index = i;
            } else if (column_title == "measurement") {
                measurement_col_index = i;
            }
        }
    }

    // Read the values:
    std::vector<float> times;
    std::vector<float> measurements;
    times.reserve(1024);
    measurements.reserve(1024);
    while (std::getline(csv_file, line)) {
        std::istringstream ss(line);
        std::string value;
        std::size_t i;
        for (i = 0; std::getline(ss, value, ','); ++i) {
            if (i == time_col_index) {
                times.emplace_back(std::stof(value));
            } else if (i == measurement_col_index) {
                measurements.emplace_back(std::stof(value));
            }
        }
    }

    // Process the data using SIMD:
    constexpr std::size_t simd_data_width = 16;
    constexpr std::size_t num_iterations = 1024 / simd_data_width;
    __m128 time_values;
    __m128 measurement_values;
    for (std::size_t i = 0; i < num_iterations; ++i) {
        time_values = _mm_load_ps(&times[i * simd_data_width]);
        measurement_values = _mm_load_ps(&measurements[i * simd_data_width]);
        // Do something with the values here
    }

    return 0;
}

#+end_example

- use simd to compute mean and variance

#+begin_example

Implement modern C++20 code that reads 2x1024 single float values from a two columns of a CSV file with the titles "time" and "measurement". The first line of the CSV file contains column titles.  The CSV file may contain more than two columns and the columns we want can be at an arbitrary position. Select the columns by locking at the column titles. Use SIMD to compute variance and mean of the measurements.

#include <algorithm>
#include <array>
#include <filesystem>
#include <fstream>
#include <numeric>
#include <string>
#include <string_view>
#include <vector>

#include <immintrin.h>

std::pair<float, float> compute_mean_and_variance(const std::vector<float>& measurements) {
    // Start with an empty accumulator
    __m128 acc = _mm_setzero_ps();

    // Accumulate mean and variance for each SIMD iteration
    for (size_t i = 0; i < measurements.size(); i += 4) {
        // Load 4 values into SIMD registers
        __m128 x = _mm_loadu_ps(&measurements[i]);

        // Compute the square of x
        __m128 square = _mm_mul_ps(x, x);

        // Accumulate square and x
        acc = _mm_add_ps(acc, square);
        acc = _mm_add_ps(acc, x);
    }

    // Reduce the accumulator to get the mean and variance
    float sum = std::accumulate(measurements.begin(), measurements.end(), 0.0f);
    float mean = sum / measurements.size();
    float variance = (_mm_cvtss_f32(acc) - measurements.size() * mean * mean) / (measurements.size() - 1);

    return {mean, variance};
}

std::pair<std::vector<float>, std::vector<float>> read_csv(const std::filesystem::path& path, std::string_view time_column, std::string_view measure_column) {
    std::pair<std::vector<float>, std::vector<float>> values{};

    std::ifstream file(path);
    if (!file.good()) {
        return values;
    }

    // Read the first line to determine the column indices
    std::string titles;
    std::getline(file, titles);
    size_t time_index = titles.find(time_column);
    size_t measure_index = titles.find(measure_column);

    // Read the remaining lines
    while (file) {
        std::string line;
        std::getline(file, line);

        // Parse the line into tokens
        std::vector<std::string> tokens;
        std::string token;
        for (char c : line) {
            if (c == ',') {
                tokens.push_back(token);
                token.clear();
            } else {
                token += c;
            }
        }
        tokens.push_back(token);

        // Convert the tokens to float values
        float time = std::stof(tokens[time_index]);
        float measure = std::stof(tokens[measure_index]);

        // Store the values
        values.first.push_back(time);
        values.second.push_back(measure);
    }

    return values;
}

int main() {
    auto [times, measurements] = read_csv("data.csv", "time", "measurement");
    auto [mean, variance] = compute_mean_and_variance(measurements);

    return 0;
}
#+end_example

*** Write CSV C++

#+begin_example

#include <algorithm>
#include <array>
#include <filesystem>
#include <fstream>
#include <numeric>
#include <string>
#include <string_view>
#include <vector>

#include <immintrin.h>

std::pair<float, float> compute_mean_and_variance(const std::vector<float>& measurements) {
    // Start with an empty accumulator
    __m128 acc = _mm_setzero_ps();

    // Accumulate mean and variance for each SIMD iteration
    for (size_t i = 0; i < measurements.size(); i += 4) {
        // Load 4 values into SIMD registers
        __m128 x = _mm_loadu_ps(&measurements[i]);

        // Compute the square of x
        __m128 square = _mm_mul_ps(x, x);

        // Accumulate square and x
        acc = _mm_add_ps(acc, square);
        acc = _mm_add_ps(acc, x);
    }

    // Reduce the accumulator to get the mean and variance
    float sum = std::accumulate(measurements.begin(), measurements.end(), 0.0f);
    float mean = sum / measurements.size();
    float variance = (_mm_cvtss_f32(acc) - measurements.size() * mean * mean) / (measurements.size() - 1);

    return {mean, variance};
}

std::pair<std::vector<float>, std::vector<float>> read_csv(const std::filesystem::path& path, std::string_view time_column, std::string_view measure_column) {
    std::pair<std::vector<float>, std::vector<float>> values{};

    std::ifstream file(path);
    if (!file.good()) {
        return values;
    }

    // Read the first line to determine the column indices
    std::string titles;
    std::getline(file, titles);
    size_t time_index = titles.find(time_column);
    size_t measure_index = titles.find(measure_column);

    // Read the remaining lines
    while (file) {
        std::string line;
        std::getline(file, line);

        // Parse the line into tokens
        std::vector<std::string> tokens;
        std::string token;
        for (char c : line) {
            if (c == ',') {
                tokens.push_back(token);
                token.clear();
            } else {
                token += c;
            }
        }
        tokens.push_back(token);

        // Convert the tokens to float values
        float time = std::stof(tokens[time_index]);
        float measure = std::stof(tokens[measure_index]);

        // Store the values
        values.first.push_back(time);
        values.second.push_back(measure);
    }

    return values;
}

int main() {
    auto [times, measurements] = read_csv("data.csv", "time", "measurement");
    auto [mean, variance] = compute_mean_and_variance(measurements);

    return 0;
}

#+end_example


** grpc c++

#+begin_example

Implement modern C++20 code that reads 1024 single float values from a socket. The data is encoded using grpc.

// C++20 code example 
#include <iostream>
#include <string>
#include <grpcpp/grpcpp.h>

int main()
{
    // Create a channel to the server.
    grpc::ChannelArguments channel_args;
    std::shared_ptr<grpc::Channel> channel = grpc::CreateChannel("localhost:50051", channel_args);

    // Create a stub to communicate with the server.
    auto stub = myproto::DataService::NewStub(channel);

    // Create a request that can hold 1024 float values.
    myproto::Request request;
    request.set_num_values(1024);

    // Create a reader to receive the response from the server.
    grpc::ClientReader<myproto::Response> reader(stub->Read(&context, request));

    // Read the values from the socket.
    std::vector<float> values;
    myproto::Response response;
    while (reader.Read(&response)) {
        if (response.has_value()) {
            values.push_back(response.value());
        }
    }

    // Print out the values.
    for (auto v : values) {
        std::cout << v << std::endl;
    }

    return 0;
}
#+end_example

** protobuf c++

#+begin_example

Implement modern C++20 code that reads 1024 single float values from a socket. The data is encoded using protobuf.

#include <iostream>
#include <cstdint>
#include <vector>
#include <span>
#include <numeric>
#include <socket>

#include <google/protobuf/message.h>

using namespace std;

constexpr uint32_t kBufferSize = 1024;

// Reads float values from a socket, encoded using protobuf.
vector<float> ReadFromSocketWithProtoBuf(socket &sock) {
  // Allocate a buffer for the protobuf message.
  uint8_t buf[kBufferSize];
  
  // Read the message from the socket.
  size_t bytes_read = sock.read(buf, kBufferSize);
  if (bytes_read != kBufferSize) {
    throw runtime_error("Failed to read protobuf message from socket");
  }
  
  // Parse the message from the buffer.
  google::protobuf::Message message;
  if (!message.ParseFromArray(buf, kBufferSize)) {
    throw runtime_error("Failed to parse protobuf message from buffer");
  }
  
  // Extract the float values from the message.
  vector<float> values;
  for (int i = 0; i < message.float_size(); ++i) {
    values.push_back(message.float(i));
  }
  
  return values;
}

// Reads float values from a socket, using a binary format.
vector<float> ReadFromSocketWithBinary(socket &sock) {
  // Allocate a buffer for the float values.
  uint8_t buf[sizeof(float) * kBufferSize];
  
  // Read the float values from the socket.
  size_t bytes_read = sock.read(buf, sizeof(float) * kBufferSize);
  if (bytes_read != sizeof(float) * kBufferSize) {
    throw runtime_error("Failed to read float values from socket");
  }
  
  // Extract the float values from the buffer.
  vector<float> values;
  span<float> float_span(reinterpret_cast<float*>(buf), kBufferSize);
  for (float f : float_span) {
    values.push_back(f);
  }
  
  return values;
}
#+end_example


*** more complexity (with crc)

#+begin_example

Implement modern C++20 code that reads a data packet from a socket. The data is encoded using protobuf. The data packet consist of a CRC, a length (which is 1024) followed by 1024 single float values. The CRC is computed over length and data.

#include <iostream>
#include <span>
#include <numeric>
#include <protobuf/message.h>

using std::span;
using std::accumulate;

// Read a data packet from a socket.
// The data is encoded using protobuf.
// The data packet consist of a CRC, a length (which is 1024)
// followed by 1024 single float values.
// The CRC is computed over length and data.
void readDataPacket(std::istream& socket, protobuf::Message& message)
{
    // Read CRC
    uint32_t crc;
    socket >> crc;

    // Read length
    uint32_t length;
    socket >> length;

    // Check if length is 1024
    if (length != 1024) {
        throw std::runtime_error("length isn't 1024");
    }

    // Read data
    span<float> data(length);
    for (float& d : data) {
        socket >> d;
    }

    // Calculate CRC over length and data
    uint32_t expectedCrc = accumulate(data.begin(), data.end(), length);

    // Check if CRC is correct
    if (crc != expectedCrc) {
        throw std::runtime_error("CRC doesn't match");
    }

    // Deserialize data into protobuf message
    message.ParseFromArray(data.data(), length * sizeof(float));
}
#+end_example

*** protobuf writer

#+begin_example

Implement modern C++20 code that writes a data packet to a socket. The data is encoded using protobuf. The data packet consist of a CRC, a length (which is 1024) followed by 1024 single float values. The CRC is computed over length and data. Do not omit the CRC calculation.

#include <cstdint>
#include <netinet/in.h>
#include <span>

#include <iostream>
#include <vector>
#include <algorithm>

#include "crc32.h"
#include "protobuf.h"

using namespace std;

// Compute the CRC of the data packet
uint32_t compute_crc32(std::span<float> data)
{
    // Turn the data into byte array
    std::vector<uint8_t> byte_data = {};
    for(float f : data) {
        const uint8_t* bytes = reinterpret_cast<const uint8_t*>(&f);
        for(int i = 0; i < sizeof(float); i++)
            byte_data.push_back(bytes[i]);
    }

    // Compute and return the CRC
    return crc32(byte_data.data(), byte_data.size());
}

// Write the data packet to the socket
void write_data_packet(int socket, std::span<float> data)
{
    // Compute the CRC
    const uint32_t crc = compute_crc32(data);

    // Construct the packet
    const uint32_t length = htonl(data.size());
    std::vector<uint8_t> packet = {};
    const uint8_t* crc_bytes = reinterpret_cast<const uint8_t*>(&crc);
    for(int i = 0; i < sizeof(uint32_t); i++)
        packet.push_back(crc_bytes[i]);
    const uint8_t* length_bytes = reinterpret_cast<const uint8_t*>(&length);
    for(int i = 0; i < sizeof(uint32_t); i++)
        packet.push_back(length_bytes[i]);
    for(float f : data) {
        const uint8_t* bytes = reinterpret_cast<const uint8_t*>(&f);
        for(int i = 0; i < sizeof(float); i++)
            packet.push_back(bytes[i]);
    }

    // Encode the packet using protobuf
    const std::vector<uint8_t> encoded_packet = protobuf_encode(packet);

    // Write the packet to the socket
    write(socket, encoded_packet.data(), encoded_packet.size());
}
#+end_example


** Construct Raw Packet C++20

#+begin_example
Implement modern C++20 code that writes or reads a data packet to or from a socket. The data packet is a struct that contains CRC, packet type (uint8), protocol version (uint8), length (uint32) and data. Data is an array of length single float values. The CRC is computed over packet type, protocol version, length, data;

#include <array>
#include <cstdint>
#include <numeric>
#include <socket>

// Struct to represent the data packet
struct DataPacket {
  uint32_t crc;
  uint8_t packetType;
  uint8_t protocolVersion;
  uint32_t length;
  std::array<float, 128> data;
};

// Compute the CRC for the data packet
uint32_t computeCRC(const DataPacket& packet) {
  // Compute CRC over packet type, protocol version, length, and data
  const auto crc = std::accumulate(
    packet.data.begin(), packet.data.end(),
    packetType ^ protocolVersion ^ length,
    [](const auto acc, const auto& elem) {
      return std::crc32(acc, &elem, sizeof(elem));
    }
  );
  return crc;
}

// Function to write the data packet to a socket
void writeDataPacketToSocket(const DataPacket& packet, std::socket& socket) {
  // Compute the CRC
  packet.crc = computeCRC(packet);

  // Write the data packet to the socket
  socket.send(reinterpret_cast<const char*>(&packet), sizeof(packet));
}

// Function to read the data packet from a socket
void readDataPacketFromSocket(DataPacket& packet, std::socket& socket) {
  // Read the data packet from the socket
  socket.recv(reinterpret_cast<char*>(&packet), sizeof(packet));

  // Compute the CRC
  const auto computedCrc = computeCRC(packet);

  // Verify the CRC
  if (packet.crc != computedCrc) {
    throw std::runtime_error("Data packet CRC mismatch");
  }
}

#+end_example


** next

- compute forward error correction (and use it to correct broken data)
- i want an example of how to demux with ffmpeg and decode with nvdec
  https://github.com/FFmpeg/FFmpeg/blob/master/libavcodec/nvdec.c
- maybe something with imgui
- some async c++, coroutines
- c++ modules with clang
- imx477 set registers to increase sensitivity, disable star destroyer

*** more complexity, allow for different packet types


- Implement modern C++20 code that writes or reads a data packet to or
  from a socket. The data packet is a struct that contains CRC, packet
  type (uint8), protocol version (uint8), length (uint16) and
  data. Length can be at most 4096. The CRC is computed over all the
  struct members (except CRC). Data is a union and takes on different
  meanings depending on the value of packet type. For packet type 0
  the data always contains the bytes 0xDEADBEEF. For packet type 1
  data contains an array of single float values with length
  entries. For packet type 2 data contains a UTF-8 string.

- Rate limit reached for default-text-davinci-003 in organization
  org-xxxxxq on tokens per min. Limit: 150000.000000 / min. Current:
  192480.000000 / min. Contact support@openai.com if you continue to
  have issues. Please add a payment method to your account to increase
  your rate limit. Visit https://beta.openai.com/account/billing to
  add a payment method.

- try on chat.openai.com/chat next morning:

#+begin_example

#include <cstdint>
#include <cstddef>
#include <array>
#include <string>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <numeric>

// Define the union for the different data types
union PacketData {
  std::array<uint8_t, 4> data_type_0;
  std::array<float, 4096> data_type_1;
  std::string data_type_2;
};

// Define the struct for the packet
struct DataPacket {
  uint16_t crc;
  uint8_t packet_type;
  uint8_t protocol_version;
  uint16_t length;
  PacketData data;

  // Compute the CRC of the packet
  uint16_t compute_crc() const {
    // Convert the struct to a byte array
    std::array<uint8_t, sizeof(DataPacket)> bytes{};
    std::memcpy(bytes.data(), this, sizeof(DataPacket));

    // Compute the sum of all bytes in the array, modulo 65535
    // to ensure that the result is a 16-bit value
    return std::accumulate(bytes.begin(), bytes.end(), 0) % 65535;
  }

  // Check if the packet is valid by comparing the stored CRC with
  // the computed CRC
  bool is_valid() const {
    return crc == compute_crc();
  }
};

// Write the data packet to a socket
void write_data_packet(int socket, const DataPacket& packet) {
  // Compute the CRC of the packet and store it in the packet
  packet.crc = packet.compute_crc();

  // Write the packet to the socket
  std::array<uint8_t, sizeof(DataPacket)> bytes{};
  std::memcpy(bytes.data(), &packet, sizeof(DataPacket));
  std::write(socket, bytes.data(), bytes.size());
}

// Read a data packet from a socket
DataPacket read_data_packet(int socket) {
  DataPacket packet{};

  // Read the packet from the socket
  std::array<uint8_t, sizeof(DataPacket)> bytes{};
  std::read(socket, bytes.data(), bytes.size());
  std::memcpy(&packet, bytes.data(), sizeof(DataPacket));

  return packet;
}

int main() {
  // Create a sample packet
  DataPacket packet{};
  packet.packet_type = 1;
  packet.protocol_version = 2;
  packet.length = 4096;
  std::fill(packet.data.data_type_1.begin(), packet.data.data_type_1.end(), 1.0f);

  // Write the packet to a socket
  int socket = 1; // dummy value
  write_data_packet(socket, packet);

  // Read the packet back from the socket
  DataPacket received_packet = read_data_packet(socket);

#+end_example

- crc is over full packet, maybe it assumes that CRC is initialized
  with zero during computation

*** try forward error correction


- Implement modern C++20 code that writes or reads a data packet to or
  from a socket. The data packet is a struct that contains FEC, packet
  type (uint8), protocol version (uint8), length (uint16) and
  data. Length can be at most 4096. The FEC (forward error correction)
  is computed over all the struct members (except FEC) and is used to
  correct a limited number of errors in the packet data without the
  need for retransmission.  Data is a union and takes on different
  meanings depending on the value of packet type. For packet type 1
  data contains an array of single float values with <length>
  entries. For packet type 2 data contains a UTF-8 string of at most
  <length> runes.

#+begin_example
#include <cstdint>
#include <cstddef>
#include <array>
#include <string>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <numeric>

// Define the union for the different data types
union PacketData {
  std::array<float, 4096> data_type_1;
  std::string data_type_2;
};

// Define the struct for the packet
struct DataPacket {
  uint16_t fec;
  uint8_t packet_type;
  uint8_t protocol_version;
  uint16_t length;
  PacketData data;

  // Compute the FEC of the packet
  uint16_t compute_fec() const {
    // Convert the struct to a byte array
    std::array<uint8_t, sizeof(DataPacket)> bytes{};
    std::memcpy(bytes.data(), this, sizeof(DataPacket));

    // Compute the sum of all bytes in the array, modulo 65535
    // to ensure that the result is a 16-bit value
    return std::accumulate(bytes.begin(), bytes.end(), 0) % 65535;
  }

  // Check if the packet is valid by comparing the stored FEC with
  // the computed FEC
  bool is_valid() const {
    return fec == compute_fec();
  }
};

// Write the data packet to a socket
void write_data_packet(int socket, const DataPacket& packet) {
  // Compute the FEC of the packet and store it in the packet
  packet.fec = packet.compute_fec();

  // Write the packet to the socket
  std::array<uint8_t, sizeof(DataPacket)> bytes{};
  std::memcpy(bytes.data(), &packet, sizeof(DataPacket));
  std::write(socket, bytes.data(), bytes.size());
}

// Read a data packet from a socket
DataPacket read_data_packet(int socket) {
  DataPacket packet{};

  // Read the packet from the socket
  std::array<uint8_t, sizeof(DataPacket)> bytes{};
  std::read(socket, bytes.data(), bytes.size());
  std::memcpy(&packet, bytes.data(), sizeof(DataPacket));

  return packet;
}

int main() {
  // Create a sample packet
  DataPacket packet{};
  packet.packet_type = 1;
  packet.protocol_version = 2;
  packet.length = 4096;
  std::fill(packet.data.data_type_1.begin(), packet.data.data_type_1.end(), 1.0f);

  // Write the packet to a socket
  int socket = 1; // dummy value
  write_data_packet(socket, packet);

  // Read the packet back from the socket
  DataPacket received_packet = read_data_packet(socket);
}


#+end_example

- it didn't create FEC, again

- Implement modern C++20 code that writes or reads a data packet to or
  from a socket. The data packet contains a fixed block of data with
  64 bytes. It also contains a low-density parity check code for
  forward error correction. Show the implementation of the forward
  error correction using AFF3CT.

#+begin_example
#include <cstdint>
#include <cstddef>
#include <array>
#include <string>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <numeric>

// Include the AFF3CT library
#include <aff3ct.hpp>

constexpr std::size_t kBlockSize = 64;

// Define the struct for the packet
struct DataPacket {
  std::array<uint8_t, kBlockSize> data;
  uint16_t ldpc;

  // Compute the low-density parity check code of the packet using
  // the AFF3CT library
  uint16_t compute_ldpc() const {
    // Convert the data block to a vector of 8-bit symbols
    std::vector<uint8_t> symbols(data.begin(), data.end());

    // Define the parity check matrix for a (72,64) LDPC code
    // with 8-bit symbols
    std::array<std::array<uint8_t, 72>, 64> H{
      {
        {
          1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0,
          1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0
        }
      }
    };

    // Create an LDPC decoder using the parity check matrix
    aff3ct::module::Encoder_LDPC_std_8bits encoder(H, false);

    // Encode the data block to compute the LDPC code
    std::vector<uint8_t> ldpc_code(encoder.get_n_code_bits());
    encoder.encode(symbols.data(), ldpc_code.data());

    // Convert the LDPC code to a 16-bit value and return it
    uint16_t ldpc = 0;
    std::memcpy(&ldpc, ldpc_code.data(), sizeof(ldpc));
    return ldpc;
  }

  // Check if the packet is valid by comparing the stored LDPC with
  // the computed LDPC
  bool is_valid() const {
    return ldpc == compute_ldpc();
  }
};

// Write the data packet to a socket


#+end_example

** Misc

*** investment


- Are treasuries better investment during a recession compared to real estate.

- The answer depends on a variety of factors, including your
  individual financial situation and risk tolerance. Treasuries
  generally offer a more secure investment than real estate during a
  recession, as they are backed by the full faith and credit of the
  U.S. government and provide a fixed rate of return. However, because
  of their low returns, treasuries may not be the best investment for
  those looking to maximize their return on investment. Real estate,
  on the other hand, can offer potentially higher returns, but carries
  the risk of increased volatility in pricing and liquidity during
  economic downturns. Ultimately, the best investment for you during a
  recession will depend on your individual financial goals and risk
  tolerance.

- Are treasuries better investment during a recession compared to real
  estate?

- It depends on the individual's risk tolerance and financial
  goals. Generally, Treasury securities are considered a safe
  investment during a recession, because they are backed by the
  U.S. government. However, real estate can also be a good investment
  during a recession. In a recession, some real estate values may
  decrease, but with the right research and timing, there may be
  opportunities for lucrative investments.


- Do I have to pay Irish withholding tax for stock investments, when
  I'm registered in Switzerland?

- No, you do not have to pay Irish withholding tax for stock
  investments when you are registered in Switzerland. As a Swiss
  resident, you would be subject to Swiss income tax on your
  investments, but not Irish withholding tax.


- What is the closest nuclear power plant to Dornbirn, Austria?

- The closest nuclear power plant to Dornbirn, Austria is the Nuclear
  Power Plant in Beznau, Switzerland, located approximately 26.5 km
  (16.5 miles) away.
  - The distance is wrong.
   

- Were there ever any incidents in the Nuclear Power Plant in Beznau,
  Switzerland?

- Yes. In 1970, a minor incident occurred in the Beznau Nuclear Power
  Plant, causing the reactor to be shut down. In addition, in 2014, a
  transformer fire at the plant caused the plant to be shut down and
  its two reactors to be offline.


- Where do the Swiss store the majority of their nuclear waste?

- The Swiss store the majority of their nuclear waste in deep
  geological repositories, usually located hundreds of metres below
  the earth's surface.


- Where do the Germans store the majority of their nuclear waste?

- The majority of Germany's nuclear waste is stored in interim storage
  facilities located near nuclear power plants. Long-term disposal of
  the waste is planned in deep geological repositories.


- Where there ever any incidents with nuclear waste in deep geological
  repositories?

- Yes, there have been several incidents involving nuclear waste in
  deep geological repositories. In the United States, one of the most
  notable incidents was in 2005, when an underground tunnel in the
  Waste Isolation Pilot Plant (WIPP) in New Mexico collapsed and
  leaked radioactive material into the environment. In Germany, an
  incident occurred in 1986 when a container of nuclear waste leaked
  into a salt mine used as a repository. In Russia, an incident
  occurred in 2007 when an underground nuclear waste repository
  exploded, resulting in significant damage and contamination.


- Were there ever any incidents with nuclear waste in deep geological
  repositories?

- Yes, there have been several incidents involving nuclear waste in
  deep geological repositories. In 2014, a leak of radioactive
  material from the Waste Isolation Pilot Plant in New Mexico was
  discovered, prompting an evacuation of the facility and the closure
  of nearby roads. In 2017, a major leak of radioactive tritium was
  discovered at the Onkalo repository in Finland, prompting an
  investigation. In 2018, a leak of radioactively contaminated water
  was reported at the Asse II repository in Germany, prompting the
  shutdown of the facility.



- Were there ever any incidents with nuclear waste in deep geological
  repositories in Switzerland?

- No, there have been no incidents with nuclear waste in deep
  geological repositories in Switzerland. The country has operated a
  safe and secure program for the disposal of nuclear waste for
  decades. As of 2020, Switzerland had disposed of more than 5,000
  cubic meters of nuclear waste in five deep geological repositories.


- What are the locations of the five deep geological repositories in
  Switzerland?

- The five deep geological repositories in Switzerland are:

1. Mont Terri, canton Jura
2. Wellenberg, canton Nidwalden
3. Zürich Nordost, canton Zurich
4. Gösgen, canton Solothurn
5. Nördlich Lägern, canton Aargau
