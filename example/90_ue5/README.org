- tutorial c++ unreal engine 5: https://youtu.be/nvruYLgjKkk
- apparently better video: https://www.youtube.com/watch?v=g9dU0eCy8RI&t=0s
  - starting C++ tutorial from blank project
- corresponding github: https://github.com/Ohjurot/UE5-Cpp-Tutorial

* How to install VS Code

  - https://docs.unrealengine.com/5.0/en-US/setting-up-visual-studio-code-for-unreal-engine/
  - Download VS Code
  - C/C++ extension
  - Compiler toolset LLVM/Clang
  - LLDB extension
    
  - Set up intellisense


* Build UE5 from source
  - download release from github (currently 5.1)
  - run some scripts
    - first one downloads 20GB
    - second generates build scripts (or something), takes 1min30sec
    - run make (needs 1.5GB ram per core, i can only use 8 cores)
      build time was ca 90min


 * ChatGPT Experiments

   ** C++ UE5

 #+begin_example

Write a simple C++ example for Unreal Engine 5.

#include "Engine.h"

int main()
{
	// Create a new instance of the engine
	UEngine* Engine = NewObject<UEngine>();

	// Set the desired frame rate
	Engine->SetTargetFPS(60);

	// Begin the game loop
	while (Engine->IsRunning())
	{
		// Update the engine
		Engine->Tick();
	}

	// Cleanup
	Engine->Destroy();

	return 0;
}
 #+end_example


 ** UE5 Sphere

 #+begin_example

Write a simple C++ example for Unreal Engine 5. Draw a bouncing red sphere.


#include "Com#include "Components/StaticMeshComponent.h"
#include "Components/SceneComponent.h"
#include "GameFramework/Actor.h"

#include "DrawDebugHelpers.h"

#include "Engine/World.h"

class ABouncingSphere : public AActor
{
	GENERATED_BODY()

public:
	ABouncingSphere()
	{
		PrimaryActorTick.bCanEverTick = true;

		// Create the sphere mesh
		SphereMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("SphereMesh"));
		SphereMesh->SetStaticMesh(ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT("/Engine/BasicShapes/Sphere")).Object);
		SphereMesh->SetWorldScale3D(FVector(0.2f, 0.2f, 0.2f));
		SphereMesh->SetCollisionEnabled(ECollisionEnabled::QueryOnly);
		SphereMesh->SetCollisionObjectType(ECollisionChannel::ECC_WorldDynamic);
		SphereMesh->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore);
		SphereMesh->SetCollisionResponseToChannel(ECollisionChannel::ECC_WorldDynamic, ECollisionResponse::ECR_Overlap);
		RootComponent = SphereMesh;

		// Create the sphere physics
		SpherePhysics = CreateDefaultSubobject<USceneComponent>(TEXT("SpherePhysics"));
		SpherePhysics->SetMobility(EComponentMobility::Movable);
		SpherePhysics->SetupAttachment(RootComponent);

		// Set the sphere's color
		SphereMesh->SetMaterial(0, ConstructorHelpers::FObjectFinder<UMaterial>(TEXT("/Engine/BasicShapes/BasicShapeMaterial")).Object);
		SphereMesh->SetVectorParameterValue(FName("Color"), FLinearColor(1.0f, 0.0f, 0.0f));
	}

	void BeginPlay()
	{
		Super::BeginPlay();

		// Set the initial velocity
		SpherePhysics->SetPhysicsLinearVelocity(FVector(0.0f, 0.0f, 10.0f));
	}

	void Tick(float DeltaTime)
	{
		Super::Tick(DeltaTime);

		// Calculate the new velocity
		FVector Velocity = SpherePhysics->GetPhysicsLinearVelocity();
		Velocity.Z = Velocity.Z * -0.8f;
		SpherePhysics->SetPhysicsLinearVelocity(Velocity);

		// Draw a debug sphere
		DrawDebugSphere(GetWorld(), GetActorLocation(), 10.0f, 8, FColor(255, 0, 0));
	}

private:
	UStaticMeshComponent* SphereMesh;
	USceneComponent* SpherePhysics;

};


 #+end_example


 ** EMVA


- I want code that allows the calibration of a linear camera according to EMVA 1288.


- EMVA 1288 is a standard for measuring and reporting the performance
  of digital cameras. It is a comprehensive method that requires a
  test chart setup, camera settings, and a set of measurements taken
  with the camera.

- Unfortunately, there is no code that allows a linear camera to be
  calibrated according to EMVA 1288. Instead, you will need to use
  specialized software and/or hardware to complete the calibration
  process. For example, you can use software such as Photonfocus
  Calibration or hardware such as the Photonfocus EMVA 1288
  Calibration Kit to help you calibrate your linear camera.

- load PNG with R

#+begin_example
Write R code to load a sequence of 2D gray PNG image.

library(png)

img_list <- list.files(path = ".", pattern = "*.png", full.names = TRUE)

for (i in seq_along(img_list)){
  img <- readPNG(img_list[i])
  # add code to process the 2D gray PNG image
}

#+end_example


- compute statistics

#+begin_example

Write R code to load a sequence of 2D gray PNG image. Compute the variance and the mean of each pixel over all the images.

# Load packages
library(png)

# Create an empty vector to store the data
data <- vector(mode="numeric", length=1000)

# Loop through images
for (i in 1:1000) {
  # Load image and store into data vector
  img <- readPNG(paste0("image",i,".png"))
  data[i] <- img
}

# Compute the variance and the mean of each pixel over all images
pixel_variance <- apply(data, c(1,2), var)
pixel_mean <- apply(data, c(1,2), mean)
#+end_example

- continue:

#+begin_example

Plot variance against mean. Perform a linear fit. Print slope and intercept with error estimates.

# Plot variance against mean
plot(pixel_mean, pixel_variance, main="Variance vs Mean of Pixels")

# Perform linear fit
fit <- lm(pixel_variance ~ pixel_mean)

# Print slope and intercept with error estimates
summary(fit)
#+end_example


** Lane-Emden (star model, astronomy)

#+begin_example
Implement a solver for the Lane-Emden equation in Python.

The Lane-Emden equation is a second-order nonlinear ordinary differential equation that describes the behavior of certain self-gravitating systems such as stars or gas clouds. It is given by:

d^2ξ/dθ^2 + (2/θ)dξ/dθ + ξ^n = 0

Where ξ(θ) is the unknown function and n is a constant.

The following code provides a solver for the Lane-Emden equation in Python:

import numpy as np

def lane_emden(n, theta):
    # Define the ODE
    def f(x, t):
        ξ, η = x
        return [η, -(2./t)*η - ξ**n]
    
    # Define the initial conditions
    x0 = [1, 0]
    
    # Solve the ODE
    soln = integrate.solve_ivp(f, [1e-6, theta], x0)
    
    # Return the solution
    return soln.y[0][-1]

# Test the solver
n = 3
theta = 10
print(lane_emden(n, theta)) # 0.08799616713117206

#+end_example
