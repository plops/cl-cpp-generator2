- tutorial c++ unreal engine 5: https://youtu.be/nvruYLgjKkk
- apparently better video: https://www.youtube.com/watch?v=g9dU0eCy8RI&t=0s
  - starting C++ tutorial from blank project
- corresponding github: https://github.com/Ohjurot/UE5-Cpp-Tutorial

* How to install VS Code

  - https://docs.unrealengine.com/5.0/en-US/setting-up-visual-studio-code-for-unreal-engine/
  - Download VS Code
  - C/C++ extension
  - Compiler toolset LLVM/Clang
  - LLDB extension
    
  - Set up intellisense


* Build UE5 from source
  - download release from github (currently 5.1)
  - run some scripts
    - first one downloads 20GB
    - second generates build scripts (or something), takes 1min30sec
    - run make (needs 1.5GB ram per core, i can only use 8 cores)
      build time was ca 90min


 * ChatGPT Experiments

   ** C++ UE5

 #+begin_example

Write a simple C++ example for Unreal Engine 5.

#include "Engine.h"

int main()
{
	// Create a new instance of the engine
	UEngine* Engine = NewObject<UEngine>();

	// Set the desired frame rate
	Engine->SetTargetFPS(60);

	// Begin the game loop
	while (Engine->IsRunning())
	{
		// Update the engine
		Engine->Tick();
	}

	// Cleanup
	Engine->Destroy();

	return 0;
}
 #+end_example


 ** UE5 Sphere

 #+begin_example

Write a simple C++ example for Unreal Engine 5. Draw a bouncing red sphere.


#include "Com#include "Components/StaticMeshComponent.h"
#include "Components/SceneComponent.h"
#include "GameFramework/Actor.h"

#include "DrawDebugHelpers.h"

#include "Engine/World.h"

class ABouncingSphere : public AActor
{
	GENERATED_BODY()

public:
	ABouncingSphere()
	{
		PrimaryActorTick.bCanEverTick = true;

		// Create the sphere mesh
		SphereMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("SphereMesh"));
		SphereMesh->SetStaticMesh(ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT("/Engine/BasicShapes/Sphere")).Object);
		SphereMesh->SetWorldScale3D(FVector(0.2f, 0.2f, 0.2f));
		SphereMesh->SetCollisionEnabled(ECollisionEnabled::QueryOnly);
		SphereMesh->SetCollisionObjectType(ECollisionChannel::ECC_WorldDynamic);
		SphereMesh->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore);
		SphereMesh->SetCollisionResponseToChannel(ECollisionChannel::ECC_WorldDynamic, ECollisionResponse::ECR_Overlap);
		RootComponent = SphereMesh;

		// Create the sphere physics
		SpherePhysics = CreateDefaultSubobject<USceneComponent>(TEXT("SpherePhysics"));
		SpherePhysics->SetMobility(EComponentMobility::Movable);
		SpherePhysics->SetupAttachment(RootComponent);

		// Set the sphere's color
		SphereMesh->SetMaterial(0, ConstructorHelpers::FObjectFinder<UMaterial>(TEXT("/Engine/BasicShapes/BasicShapeMaterial")).Object);
		SphereMesh->SetVectorParameterValue(FName("Color"), FLinearColor(1.0f, 0.0f, 0.0f));
	}

	void BeginPlay()
	{
		Super::BeginPlay();

		// Set the initial velocity
		SpherePhysics->SetPhysicsLinearVelocity(FVector(0.0f, 0.0f, 10.0f));
	}

	void Tick(float DeltaTime)
	{
		Super::Tick(DeltaTime);

		// Calculate the new velocity
		FVector Velocity = SpherePhysics->GetPhysicsLinearVelocity();
		Velocity.Z = Velocity.Z * -0.8f;
		SpherePhysics->SetPhysicsLinearVelocity(Velocity);

		// Draw a debug sphere
		DrawDebugSphere(GetWorld(), GetActorLocation(), 10.0f, 8, FColor(255, 0, 0));
	}

private:
	UStaticMeshComponent* SphereMesh;
	USceneComponent* SpherePhysics;

};


 #+end_example


 ** EMVA


- I want code that allows the calibration of a linear camera according to EMVA 1288.


- EMVA 1288 is a standard for measuring and reporting the performance
  of digital cameras. It is a comprehensive method that requires a
  test chart setup, camera settings, and a set of measurements taken
  with the camera.

- Unfortunately, there is no code that allows a linear camera to be
  calibrated according to EMVA 1288. Instead, you will need to use
  specialized software and/or hardware to complete the calibration
  process. For example, you can use software such as Photonfocus
  Calibration or hardware such as the Photonfocus EMVA 1288
  Calibration Kit to help you calibrate your linear camera.

- load PNG with R

#+begin_example
Write R code to load a sequence of 2D gray PNG image.

library(png)

img_list <- list.files(path = ".", pattern = "*.png", full.names = TRUE)

for (i in seq_along(img_list)){
  img <- readPNG(img_list[i])
  # add code to process the 2D gray PNG image
}

#+end_example


- compute statistics

#+begin_example

Write R code to load a sequence of 2D gray PNG image. Compute the variance and the mean of each pixel over all the images.

# Load packages
library(png)

# Create an empty vector to store the data
data <- vector(mode="numeric", length=1000)

# Loop through images
for (i in 1:1000) {
  # Load image and store into data vector
  img <- readPNG(paste0("image",i,".png"))
  data[i] <- img
}

# Compute the variance and the mean of each pixel over all images
pixel_variance <- apply(data, c(1,2), var)
pixel_mean <- apply(data, c(1,2), mean)
#+end_example

- continue:

#+begin_example

Plot variance against mean. Perform a linear fit. Print slope and intercept with error estimates.

# Plot variance against mean
plot(pixel_mean, pixel_variance, main="Variance vs Mean of Pixels")

# Perform linear fit
fit <- lm(pixel_variance ~ pixel_mean)

# Print slope and intercept with error estimates
summary(fit)
#+end_example


** Lane-Emden (star model, astronomy)
- python
#+begin_example
Implement a solver for the Lane-Emden equation in Python.

The Lane-Emden equation is a second-order nonlinear ordinary differential equation that describes the behavior of certain self-gravitating systems such as stars or gas clouds. It is given by:

d^2ξ/dθ^2 + (2/θ)dξ/dθ + ξ^n = 0

Where ξ(θ) is the unknown function and n is a constant.

The following code provides a solver for the Lane-Emden equation in Python:

import numpy as np

def lane_emden(n, theta):
    # Define the ODE
    def f(x, t):
        ξ, η = x
        return [η, -(2./t)*η - ξ**n]
    
    # Define the initial conditions
    x0 = [1, 0]
    
    # Solve the ODE
    soln = integrate.solve_ivp(f, [1e-6, theta], x0)
    
    # Return the solution
    return soln.y[0][-1]

# Test the solver
n = 3
theta = 10
print(lane_emden(n, theta)) # 0.08799616713117206

#+end_example

- continue
#+begin_example

# Plot results for three different positions in the Hertzsprung–Russell diagram
import matplotlib.pyplot as plt

# Define constants
n_values = [1, 3/2, 5]
theta_values = np.linspace(1e-6, 10, 100)

# Solve for each n value
for n in n_values:
    ξ_values = [lane_emden(n, theta) for theta in theta_values]
    
    # Plot the results
    plt.plot(ξ_values, theta_values, label=f'n = {n}')
    
# Label the plot
plt.xlabel('ξ')
plt.ylabel('θ')
plt.title('Lane-Emden Equation')
plt.legend()
plt.show()
#+end_example


- in go
  - does that make sense? i'm not sure
#+begin_example

Implement a solver for the Lane-Emden equation in Go.

//Function to solve Lane-Emden equation
func SolveLaneEmden(x float64, n float64) float64 {

	//Initialize variables
	var y float64 = 1
	var dy float64 = 0
	var h float64 = 1e-4

	//Iterate until x reaches 0
	for x >= 0 {
		//Calculate derivatives
		dy = y + (x*x*y)/(n-1)
		d2y := -2*x*dy/n - (x*x*dy)/(n-1)

		//Calculate new y value
		y += (h/2)*(dy + (h/2)*d2y)

		//Decrement x
		x -= h
	}

	//Return y
	return y
}
#+end_example

** Optical Fiber


- Derive the characteristic equation for a rotationally symmetric optical fiber with a core and infinite cladding.
 - That is not quite correct.
#+begin_example


The characteristic equation for a rotationally symmetric optical fiber with a core and infinite cladding is given by:

n_1^2 - n_2^2 = (2π/λ)^2n_1n_2(n_1^2 - n_2^2)r^2,

where n_1 is the refractive index of the core, n_2 is the refractive index of the cladding, λ is the wavelength of light, and r is the core radius.

#+end_example

- continue

#+begin_example


The solution for the scalar approximation is given by:

n_1 = n_2 + (2π/λ)^2n_1n_2r^2.
#+end_example


** Common Lisp socket

- Write Common Lisp code that listens on a socket. When it reads the
  string "Hello" the programm must return "World".

#+begin_example


(defun start-server ()
  (let ((s (socket:socket-server 8888 :element-type 'character :external-format '(:utf-8 :eol-style :crlf))))
    (loop (multiple-value-bind (str conn)
                        (socket:socket-accept s)
                      (if (string= "Hello" str)
                          (socket:socket-send conn "World")
                        (socket:socket-send conn "Error")))
           (sleep 5))))

(start-server)


#+end_example



** Common Lisp C++ generator

#+begin_example

Write Common Lisp code that reads s-expressions and generates C++ code.

(defun s-expr-to-cpp (expr)
  (cond
    ((atom expr) (format nil "~a" expr))
    ((eq (car expr) 'quote) (format nil "~a" (cadr expr)))
    ((or (eq (car expr) '+) (eq (car expr) '-))
     (format nil "(~a ~a ~a)"
             (s-expr-to-cpp (second expr)) (car expr) (s-expr-to-cpp (third expr))))
    ((or (eq (car expr) '*) (eq (car expr) '/))
     (format nil "(~a ~a ~a)"
             (s-expr-to-cpp (second expr)) (car expr) (s-expr-to-cpp (third expr))))
    (t (error "Unrecognized expression ~a" expr))))
#+end_example

- that is not what i want, i also don't see how i could fix that
