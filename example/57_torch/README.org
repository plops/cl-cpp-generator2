- https://pytorch.org/tutorials/advanced/cpp_frontend.html
- emerge cudnn
- submodule was created in the constructor's initializer list, while
  the parameter was created inside the constructor body. There is a
  good reason for this, which we'll touch upon this in the section on
  the C++ frontend's ownership model
- torch::nn::Module
- register_parameter "W" torch::randn({N,M})
- torch::Tensor W
- torch::nn::Linear linear
- construct (linear (register_module "linear" torch::nn::Linear(N,M)))
- for const auto& p : net.parameters()
- for const auto& pair : net.named_paramters()
  - pair.key()
  - pair.value()

- execution: net.forward( torch::ones({2,4}) )
- c++ api docs https://pytorch.org/cppdocs/api/namespace_torch__nn.html
- in python objects always on heap and have reference semantics
- c++ provides either value or reference semantics
  - value is simplest, objects on stack and are copied, moved, taken
    by reference or pointer
#+begin_example
(defun a (net)
  (declare (type Net net)))
(defun main ()
  (let ((net (Net))))
    (a (std--move net))))
#+end_example

  - reference: std::shared_ptr reduces cognitive overhead
#+begin_example
(defun a (net)
  (declare (type std--shared_ptr<Net> net)))
(defun main ()
  (let ((net (std--make_shared<Net>)))
    (a net)))
#+end_example
