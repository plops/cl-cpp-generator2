// based on https://github.com/openwch/ch592/tree/main/EVT/EXAM/BLE/RF_PHY/APP

// try rf communication module in basic mode

extern "C" {
#include <CH59x_common.h>
#include <CH59x_pwr.h>
#include <CH59x_sys.h>
#include <CONFIG.h>
#include <HAL.h>
#include <board.h>
};
#include <array>
#include <cstdio>
__attribute((aligned(4))) uint32_t MEM_BUF[(BLE_MEMHEAP_SIZE / 4)];
const uint8_t MacAddr[6]{0x84, 0xC2, 0xE4, 3, 2, 2};
std::array<uint8_t, 10> TX_DATA{1, 2, 3, 4, 5, 6, 7, 8, 9, 0};
enum class SBP : uint16_t {
  START_DEVICE_EVT,
  SBP_RF_PERIODIC_EVT,
  SBP_RF_RF_RX_EVT
};
__HIGH_CODE __attribute((noinline)) void Main_Circulation() {
  while (true) {
    TMOS_SystemProcess();
  }
}

/**

**Purpose**

The `RF_2G4StatusCallBack` function acts as a central handler for status updates
within a 2.4GHz radio frequency (RF) communication system. It's likely triggered
by interrupts or events generated by the RF hardware. The function's key actions
are:

* **Interpreting Status Codes:** It receives a status code (`sta`) that
indicates the current state of the RF module (e.g., transmission finished,
transmission failed, data received, timeout).
* **Updating Flags:**  It sets flags like `tx_end_flag` and `rx_end_flag` to
control other parts of the program that are waiting for transmission or
reception to complete.
* **Data Handling:**  If data is received successfully (`crc` indicates no
errors), it parses and potentially prints the received data to a console or
debugging output.
* **Error Reporting:**  If errors occur (CRC check failures), it prints relevant
error messages.
* **Event Triggering:** Depending on the configuration, it triggers events
within the system  (`tmos_set_event`) to notify other tasks that data is ready
or operations are completed.

**Translation of Comments**

* **@fn RF_2G4StatusCallBack** : Function name declaration
* **@brief RF status callback, this function is used within interrupts. Note:
not to use this function with other APIs that handle receive or transmit, must
work exclusively with the API used in interrupts. This callback or the APIs
associated with it handle different conditions according to status.**
* **@param sta - Status type**
* **@param crc - CRC checksum result**
* **@param rxBuf - Data buffer pointer**
* **@return none**



*/

void RF_2G4StatusCallback(uint8_t sta, uint8_t crc, uint8_t *rxBuf) {
  switch (sta) {
  case TX_MODE_TX_FINISH: {
    break;
  };
  case TX_MODE_TX_FAIL: {
    break;
  };
  }
}

uint16_t RF_ProcessEvent(uint8_t task_id, uint16_t events) {
  if ((events & SYS_EVENT_MSG)) {
  }
}

/**

RF_Wait_Tx_End() : This function waits for a transmission to end. It
continuously checks a flag called tx_end_flag. If the flag isn't set (indicating
the transmission is still ongoing), it enters a loop with a brief delay.  A
timeout mechanism forces the tx_end_flag to TRUE after approximately 5ms.

RF_Wait_Rx_End() :  This function is very similar to the transmission wait
function. It waits for a signal reception to end, monitoring the rx_end_flag. It
also has a timeout mechanism of approximately 5ms.


*/

void RF_Init() {
  auto cfg{rfConfig_t()};
  tmos_memset(&cfg, 0, sizeof(cfg));
  auto taskID{uint8_t(0)};
  taskID = TMOS_ProcessEventRegister(RF_ProcessEvent);
  cfg.accessAddress = 0x71764129;
  cfg.CRCInit = 0x555555;
  cfg.Channel = 39;
  cfg.Frequency = 2480000;
  cfg.LLEMode = LLE_MODE_BASIC | LLE_MODE_EX_CHANNEL;
  cfg.rfStatusCB = RF_2G4StatusCallback;
  cfg.RxMaxlen = 251;
  auto state{RF_Config(&cfg)};
  if (false) {
    // RX mode

    auto state{RF_Rx(TX_DATA.data(), TX_DATA.size(), 0xFF, 0xFF)};
  }
  if (true) {
    // TX mode

    tmos_set_event(taskID, static_cast<uint16_t>(SBP::SBP_RF_PERIODIC_EVT));
  }
}

int main() {
  // Enable DCDC

  PWR_DCDCCfg(ENABLE);
  SetSysClock(CLK_SOURCE_PLL_60MHz);
  board_button_init();
  board_led_init();
  // I think that fixes the gpio pins to prevent supply voltage from fluctuating

  GPIOA_ModeCfg(GPIO_Pin_All, GPIO_ModeIN_PU);
  GPIOB_ModeCfg(GPIO_Pin_All, GPIO_ModeIN_PU);
  CH59x_BLEInit();
  HAL_Init();
  RF_RoleInit();
  RF_Init();
  Main_Circulation();
  return 0;
}
