// based on https://github.com/openwch/ch592/tree/main/EVT/EXAM/BLE/RF_PHY/APP

// try rf communication module in basic mode

extern "C" {
#include <CH59x_common.h>
#include <CH59x_pwr.h>
#include <CH59x_sys.h>
#include <CONFIG.h>
#include <HAL.h>
#include <board.h>
};
#include <array>
#include <cstdio>
__attribute((aligned(4))) uint32_t MEM_BUF[(BLE_MEMHEAP_SIZE / 4)];
const uint8_t MacAddr[6]{0x84, 0xC2, 0xE4, 3, 2, 2};
uint8_t taskID{0};
volatile uint8_t tx_end_flag{0};
volatile uint8_t rx_end_flag{0};
std::array<uint8_t, 10> TX_DATA{1, 2, 3, 4, 5, 6, 7, 8, 9, 0};
enum class SBP : uint16_t {
  START_DEVICE_EVT,
  SBP_RF_PERIODIC_EVT,
  SBP_RF_RF_RX_EVT
};
__HIGH_CODE __attribute((noinline)) void Main_Circulation() {
  while (true) {
    TMOS_SystemProcess();
  }
}

/**

**Purpose**

The `RF_2G4StatusCallBack` function acts as a central handler for status updates
within a 2.4GHz radio frequency (RF) communication system. It's likely triggered
by interrupts or events generated by the RF hardware. The function's key actions
are:

* **Interpreting Status Codes:** It receives a status code (`sta`) that
indicates the current state of the RF module (e.g., transmission finished,
transmission failed, data received, timeout).
* **Updating Flags:**  It sets flags like `tx_end_flag` and `rx_end_flag` to
control other parts of the program that are waiting for transmission or
reception to complete.
* **Data Handling:**  If data is received successfully (`crc` indicates no
errors), it parses and potentially prints the received data to a console or
debugging output.
* **Error Reporting:**  If errors occur (CRC check failures), it prints relevant
error messages.
* **Event Triggering:** Depending on the configuration, it triggers events
within the system  (`tmos_set_event`) to notify other tasks that data is ready
or operations are completed.

**Translation of Comments**

* **@fn RF_2G4StatusCallBack** : Function name declaration
* **@brief RF status callback, this function is used within interrupts. Note:
not to use this function with other APIs that handle receive or transmit, must
work exclusively with the API used in interrupts. This callback or the APIs
associated with it handle different conditions according to status.**
* **@param sta - Status type**
* **@param crc - CRC checksum result**
* **@param rxBuf - Data buffer pointer**
* **@return none**



*/

void RF_2G4StatusCallback(uint8_t sta, uint8_t crc, uint8_t *rxBuf) {
  switch (sta) {
  case TX_MODE_TX_FINISH: {
    break;
  };
  case TX_MODE_TX_FAIL: {
    tx_end_flag = TRUE;
    break;
  };
  case TX_MODE_RX_DATA: {
    break;
  };
  case TX_MODE_RX_TIMEOUT: {
    // timeout is about 200us

    break;
  };
  case RX_MODE_RX_DATA: {
    if (0 == crc) {
      auto i{uint8_t(0)};
      tmos_set_event(taskID, static_cast<uint16_t>(SBP::SBP_RF_RF_RX_EVT));
    }
    break;
  };
  case RX_MODE_TX_FINISH: {
    break;
  };
  case RX_MODE_TX_FAIL: {
    break;
  };
  }
}

/**
**Purpose**

The `RF_ProcessEvent` function acts as the event handler for a radio frequency
(RF) module within a larger system. It processes different types of events that
likely drive the overall RF communication operations.  Here's how it handles the
various events:

* **`SYS_EVENT_MSG`:**
   - This likely indicates a message from a task operating system (TMOS).
   - It processes the message and then releases the memory associated with it.

* **`SBP_RF_START_DEVICE_EVT`:**
   - This seems to be a device initialization event.
   - It starts a periodic task (`SBP_RF_PERIODIC_EVT`) with a 1000ms interval.

* **`SBP_RF_PERIODIC_EVT`:**
   - This is the core periodic event of the RF module.
   - It shuts down the RF module (`RF_Shut()`).
   - Clears the transmission end flag (`tx_end_flag = FALSE`).
   - Initiates a transmission (`RF_Tx()`) and waits for it to complete
(`RF_Wait_Tx_End()`).
   - Reschedules itself to run again in 1000ms.

* **`SBP_RF_RF_RX_EVT`:**
   - This likely indicates the system wants to receive data.
   - Shuts down the RF module (`RF_Shut()`).
   - Prepares data for transmission (increments `TX_DATA[0]`).
   - Initiates data reception (`RF_Rx()`) and prints the state for debugging.

**Translation of Comments**

* **@fn RF_ProcessEvent** : Function name declaration
* **@brief RF event processing**
* **@param task_id - Task ID**
* **@param events - Event flags**
* **@return Returns unprocessed events**

**Overall Behavior**

This function suggests a system design where:

* The RF module is periodically turned on to transmit data (likely sensor data
or similar).
* The system can be triggered to enter a receive mode.




*/

uint16_t RF_ProcessEvent(uint8_t task_id, uint16_t events) {
  if ((events & SYS_EVENT_MSG)) {
    auto msg{tmos_msg_receive(task_id)};
    if (!(nullptr == msg)) {
      tmos_msg_deallocate(msg);
    }
    return events ^ SYS_EVENT_MSG;
  }
}

/**

RF_Wait_Tx_End() : This function waits for a transmission to end. It
continuously checks a flag called tx_end_flag. If the flag isn't set (indicating
the transmission is still ongoing), it enters a loop with a brief delay.  A
timeout mechanism forces the tx_end_flag to TRUE after approximately 5ms.


*/
/**
RF_Wait_Rx_End() :  This function is very similar to the transmission wait
function. It waits for a signal reception to end, monitoring the rx_end_flag. It
also has a timeout mechanism of approximately 5ms.


*/
__HIGH_CODE __attribute((noinline)) void RF_Wait_Tx_End() {
  auto i{uint32_t(0)};
  while (!(tx_end_flag)) {
    i++;
    __nop();
    __nop();
    if ((FREQ_SYS / 1000) < i) {
      tx_end_flag = TRUE;
    }
  }
}

__HIGH_CODE __attribute((noinline)) void RF_Wait_Rx_End() {
  auto i{uint32_t(0)};
  while (!(rx_end_flag)) {
    i++;
    __nop();
    __nop();
    if ((FREQ_SYS / 1000) < i) {
      rx_end_flag = TRUE;
    }
  }
}

/**

**Purpose**

The `RF_Init` function initializes the radio frequency (RF) module, establishing
its fundamental configuration.  Here's what it does step-by-step:

1. **Variable Setup:** Initializes  `state` for storing status and an
`rf_Config` structure for RF configuration.

2. **Task Registration:** Registers the `RF_ProcessEvent` function with the task
operating system  (TMOS), enabling handling of RF-related events.

3. **RF Configuration:**
   * **`accessAddress`:**  Sets an access address (likely to identify packets
for this device). The comment warns against using simple patterns like
0x55555555 or 0xAAAAAAAA.
   * **`CRCInit`:** Sets the initial value for CRC (Cyclic Redundancy Check)
calculations used for error detection.
   * **`Channel`:** Sets the operating channel (39 in this case, representing a
specific frequency within the 2.4 GHz range).
   * **`Frequency`:**  Fine-tunes the transmission frequency to 2480000 kHz
(2.48 GHz).
   * **`LLEMode`:** Configures the Low-Level Link mode, which determines aspects
of packet handling and potential auto-reply behaviors.
   * **`rfStatusCB`:** Assigns the `RF_2G4StatusCallBack` function as the
callback handler for status updates from the RF module.
   * **`RxMaxlen`:**  Sets the maximum length of data packets that can be
received.

4. **RF Module Configuration:**  Calls the `RF_Config` function, passing the
prepared `rf_Config` structure to apply the settings to the RF hardware.

5. **Status Print:** Prints the status returned by `RF_Config` (for
initialization debugging purposes).

6. **Commented-Out Code:** There's a commented-out section that would have put
the device into receive mode (`RF_Rx`) - this likely served testing purposes.

7. **Periodic Transmission Setup:**  Initializes periodic transmissions of data
by triggering the `SBP_RF_PERIODIC_EVT`.

**Translation of Comments**

* **@fn RF_Init** : Function name declaration
* **@brief RF initialization**
* **@return none**

**Key Notes**

* The specific RF chip used is not clear from the code, but the configuration
parameters align with common 2.4GHz RF transceivers.
* `RF_Auto_MODE_EXAM` seems to be a configuration flag; its exact behavior
depends on how it's defined elsewhere in the system.





*/

void RF_Init() {
  auto cfg{rfConfig_t()};
  tmos_memset(&cfg, 0, sizeof(cfg));
  taskID = TMOS_ProcessEventRegister(RF_ProcessEvent);
  cfg.accessAddress = 0x71764129;
  cfg.CRCInit = 0x555555;
  cfg.Channel = 39;
  cfg.Frequency = 2480000;
  cfg.LLEMode = LLE_MODE_BASIC | LLE_MODE_EX_CHANNEL;
  cfg.rfStatusCB = RF_2G4StatusCallback;
  cfg.RxMaxlen = 251;
  auto state{RF_Config(&cfg)};
  if (false) {
    // RX mode

    auto state{RF_Rx(TX_DATA.data(), TX_DATA.size(), 0xFF, 0xFF)};
  }
  if (true) {
    // TX mode

    tmos_set_event(taskID, static_cast<uint16_t>(SBP::SBP_RF_PERIODIC_EVT));
  }
}

int main() {
  // Enable DCDC

  PWR_DCDCCfg(ENABLE);
  SetSysClock(CLK_SOURCE_PLL_60MHz);
  board_button_init();
  board_led_init();
  // I think that fixes the gpio pins to prevent supply voltage from fluctuating

  GPIOA_ModeCfg(GPIO_Pin_All, GPIO_ModeIN_PU);
  GPIOB_ModeCfg(GPIO_Pin_All, GPIO_ModeIN_PU);
  CH59x_BLEInit();
  HAL_Init();
  RF_RoleInit();
  RF_Init();
  Main_Circulation();
  return 0;
}
