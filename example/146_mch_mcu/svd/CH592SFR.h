/*
 * Copyright (c) 2009-2019 ARM Limited. All rights reserved.
 * 
 * SPDX-License-Identifier: Apache-2.0
 * 
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @file     CH592SFR.h
 * @brief    CMSIS HeaderFile
 * @version  1.0
 * @date     Sun Feb 25 11:07:02 2024
 * @note     Generated by SVDConv V3.3.46
 *           from File '/home/martin/stage/cl-cpp-generator2/example/146_mch_mcu/svd/../CH59Xxx.svd',
 *           last modified on Mon Feb 19 19:02:58 2024
 */


/** @addtogroup WCH Ltd.
  * @{
  */


/** @addtogroup CH592SFR
  * @{
  */


#ifndef CH592SFR_H
#define CH592SFR_H

#ifdef __cplusplus
extern "C" {
#endif


/** @addtogroup Configuration_of_CMSIS
  * @{
  */



/* =========================================================================================================================== */
/* ================                                Interrupt Number Definition                                ================ */
/* =========================================================================================================================== */

typedef enum {
/* =======================================  ARM Cortex-M3 Specific Interrupt Numbers  ======================================== */
/* ==========================================  CH592SFR Specific Interrupt Numbers  ========================================== */
  TMR0_IRQn                 =  16,              /*!< 16 TMR0_IRQHandler                                                        */
  GPIO_A_IRQn               =  17,              /*!< 17 GPIOA_IRQHandler                                                       */
  GPIO_B_IRQn               =  18,              /*!< 18 GPIOB_IRQHandler                                                       */
  SPI0_IRQn                 =  19,              /*!< 19 SPI0_IRQHandler                                                        */
  BLEB_IRQn                 =  20,              /*!< 20 BB_IRQHandler                                                          */
  BLEL_IRQn                 =  21,              /*!< 21 LLE_IRQHandler                                                         */
  USB_IRQn                  =  22,              /*!< 22 USB_IRQHandler                                                         */
  TMR1_IRQn                 =  24,              /*!< 24 TMR1_IRQHandler                                                        */
  TMR2_IRQn                 =  25,              /*!< 25 TMR2_IRQHandler                                                        */
  UART0_IRQn                =  26,              /*!< 26 UART0_IRQHandler                                                       */
  UART1_IRQn                =  27,              /*!< 27 UART1_IRQHandler                                                       */
  RTC_IRQn                  =  28,              /*!< 28 RTC_IRQHandler                                                         */
  ADC_IRQn                  =  29,              /*!< 29 ADC_IRQHandler                                                         */
  I2C_IRQn                  =  30,              /*!< 30 I2C_IRQHandler                                                         */
  PWMX_IRQn                 =  31,              /*!< 31 PWMX_IRQHandler                                                        */
  TMR3_IRQn                 =  32,              /*!< 32 TMR3_IRQHandler                                                        */
  UART2_IRQn                =  33,              /*!< 33 UART2_IRQHandler                                                       */
  UART3_IRQn                =  34,              /*!< 34 UART3_IRQHandler                                                       */
  WDOG_BAT_IRQn             =  35               /*!< 35 WDOG_BAT_IRQHandler                                                    */
} IRQn_Type;



/* =========================================================================================================================== */
/* ================                           Processor and Core Peripheral Section                           ================ */
/* =========================================================================================================================== */

/* ===========================  Configuration of the ARM Cortex-M3 Processor and Core Peripherals  =========================== */
#define __CM3_REV                 0x0000U       /*!< CM3 Core Revision                                                         */
#define __NVIC_PRIO_BITS               2        /*!< Number of Bits used for Priority Levels                                   */
#define __Vendor_SysTickConfig         0        /*!< Set to 1 if different SysTick Config is used                              */
#define __MPU_PRESENT                  0        /*!< MPU present                                                               */
#define __FPU_PRESENT                  0        /*!< FPU present                                                               */


/** @} */ /* End of group Configuration_of_CMSIS */

#include "core_cm3.h"                           /*!< ARM Cortex-M3 processor and core peripherals                              */
#include "system_CH592SFR.h"                    /*!< CH592SFR System                                                           */

#ifndef __IM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __IM   __I
#endif
#ifndef __OM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __OM   __O
#endif
#ifndef __IOM                                   /*!< Fallback for older CMSIS versions                                         */
  #define __IOM  __IO
#endif


/* ========================================  Start of section using anonymous unions  ======================================== */
#if defined (__CC_ARM)
  #pragma push
  #pragma anon_unions
#elif defined (__ICCARM__)
  #pragma language=extended
#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wc11-extensions"
  #pragma clang diagnostic ignored "-Wreserved-id-macro"
  #pragma clang diagnostic ignored "-Wgnu-anonymous-struct"
  #pragma clang diagnostic ignored "-Wnested-anon-types"
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning 586
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#else
  #warning Not supported compiler type
#endif


/* =========================================================================================================================== */
/* ================                            Device Specific Peripheral Section                             ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripherals
  * @{
  */



/* =========================================================================================================================== */
/* ================                                            SYS                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief System Control Register (SYS)
  */

typedef struct {                                /*!< SYS Structure                                                             */
  __IM  uint32_t  RESERVED[2];
  
  union {
    __IOM uint32_t reg;                         /*!< RWA, system clock configuration, SAM                                      */
    
    struct {
      __IOM uint32_t RB_CLK_PLL_DIV : 5;        /*!< RWA, output clock divider from PLL or CK32M                               */
            uint32_t            : 1;
      __IOM uint32_t RB_CLK_SYS_MOD : 2;        /*!< RWA, system clock source mode: 00=divided from 32MHz                      */
            uint32_t            : 24;
    } bit;
  } R32_CLK_SYS_CFG;
  
  union {
    __IOM uint8_t reg;                          /*!< RWA, sleep clock off control byte 0, SAM                                  */
    
    struct {
      __IOM uint8_t RB_SLP_CLK_TMR0 : 1;        /*!< RWA, Timer 0 clock source                                                 */
      __IOM uint8_t RB_SLP_CLK_TMR1 : 1;        /*!< RWA, Timer 1 clock source                                                 */
      __IOM uint8_t RB_SLP_CLK_TMR2 : 1;        /*!< RWA, Timer 2 clock source                                                 */
      __IOM uint8_t RB_SLP_CLK_TMR3 : 1;        /*!< RWA, Timer 3 clock source                                                 */
      __IOM uint8_t RB_SLP_CLK_UART0 : 1;       /*!< RWA, UART0 clock source                                                   */
      __IOM uint8_t RB_SLP_CLK_UART1 : 1;       /*!< RWA, UART1 clock source                                                   */
      __IOM uint8_t RB_SLP_CLK_UART2 : 1;       /*!< RWA, UART2 clock source                                                   */
      __IOM uint8_t RB_SLP_CLK_UART3 : 1;       /*!< RWA, UART3 clock source                                                   */
    } bit;
  } R8_SLP_CLK_OFF0;
  
  union {
    __IOM uint8_t reg;                          /*!< RWA, sleep clock off control byte 1, SAM                                  */
    
    struct {
      __IOM uint8_t RB_SLP_CLK_SPI0 : 1;        /*!< RWA, close SPI0 clock                                                     */
            uint8_t             : 1;
      __IOM uint8_t RB_SLP_CLK_PWMX : 1;        /*!< RWA, close PWMx clock                                                     */
      __IOM uint8_t RB_SLP_CLK_I2C : 1;         /*!< RWA, close I2C clock                                                      */
      __IOM uint8_t RB_SLP_CLK_USB : 1;         /*!< RWA, close USB clock                                                      */
            uint8_t             : 1;
      __IOM uint8_t RB_SLP_CLK_LCD : 1;         /*!< RWA, close LCD clock                                                      */
      __IOM uint8_t RB_SLP_CLK_BLE : 1;         /*!< RWA, close BLE clock                                                      */
    } bit;
  } R8_SLP_CLK_OFF1;
  
  union {
    __IOM uint8_t reg;                          /*!< RWA, wake control, SAM                                                    */
    
    struct {
      __IOM uint8_t RB_SLP_USB_WAKE : 1;        /*!< RWA, enable USB waking                                                    */
            uint8_t             : 2;
      __IOM uint8_t RB_SLP_RTC_WAKE : 1;        /*!< RWA, enable RTC waking                                                    */
      __IOM uint8_t RB_SLP_GPIO_WAKE : 1;       /*!< RWA, enable GPIO waking                                                   */
      __IOM uint8_t RB_SLP_BAT_WAKE : 1;        /*!< RWA, enable BAT waking                                                    */
      __IOM uint8_t RB_WAKE_EV_MODE : 1;        /*!< RWA, event wakeup mode                                                    */
      __IOM uint8_t RB_GPIO_WAKE_MODE : 1;      /*!< RWA, enable GPIO wake-up mode                                             */
    } bit;
  } R8_SLP_WAKE_CTRL;
  
  union {
    __IOM uint8_t reg;                          /*!< RWA, peripherals power down control, SAM                                  */
    
    struct {
      __IOM uint8_t RB_WAKE_DLY_MOD : 2;        /*!< RWA, wakeup delay time selection                                          */
            uint8_t             : 2;
      __IOM uint8_t RB_SLP_CLK_RAMX : 1;        /*!< RWA, close main SRAM clock                                                */
      __IOM uint8_t RB_SLP_CLK_RAM2K : 1;       /*!< RWA, close retention 2KB SRAM clock                                       */
      __IOM uint8_t RB_RAM_RET_LV : 1;          /*!< RWA, SRAM retention voltage selection                                     */
            uint8_t             : 1;
    } bit;
  } R8_SLP_POWER_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< RWA, Sleep control register, SAM                                          */
    
    struct {
      __IOM uint32_t RB_TKEY_WAKE_EN : 6;       /*!< RWA, Touch button wake-up enable: 1: On; 0: Close. Each digit
                                                     corresponds to a button.                                                  */
            uint32_t            : 26;
    } bit;
  } R32_SLEEP_CTRL2;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint16_t reg;                         /*!< RW, function pin alternate configuration                                  */
    
    struct {
      __IOM uint16_t RB_PIN_TMR0 : 1;           /*!< RW, TMR0 alternate pin enable                                             */
      __IOM uint16_t RB_PIN_TMR1 : 1;           /*!< RW, TMR1 alternate pin enable                                             */
      __IOM uint16_t RB_PIN_TMR2 : 1;           /*!< RW, TMR2 alternate pin enable                                             */
      __IOM uint16_t RB_PIN_TMR3 : 1;           /*!< RW, TMR3 alternate pin enable                                             */
      __IOM uint16_t RB_PIN_UART0 : 1;          /*!< RW, RXD0/TXD0 alternate pin enable                                        */
      __IOM uint16_t RB_PIN_UART1 : 1;          /*!< RW, RXD1/TXD1 alternate pin enable                                        */
      __IOM uint16_t RB_PIN_UART2 : 1;          /*!< RW, RXD2/TXD2 alternate pin enable                                        */
      __IOM uint16_t RB_PIN_UART3 : 1;          /*!< RW, RXD3/TXD3 alternate pin enable                                        */
      __IOM uint16_t RB_PIN_SPI0 : 1;           /*!< RW, SCS/SCK0/MOSI/MISO alternate pin enable                               */
            uint16_t            : 1;
      __IOM uint16_t RB_PIN_PWMX : 1;           /*!< RW, PWM4/PWM5/PWM7/PWM8/PWM9 alternate pin enable                         */
      __IOM uint16_t RB_PIN_I2C : 1;            /*!< RW, SCL/SDA alternate pin enable                                          */
      __IOM uint16_t RB_PIN_MODEM : 1;          /*!< RW, DSR/DTR alternate pin enable                                          */
            uint16_t            : 2;
      __IOM uint16_t RB_RF_ANT_SW_EN : 1;       /*!< RW, RF antenna switch control output enable                               */
    } bit;
  } R16_PIN_ALTERNATE;
  
  union {
    __IOM uint16_t reg;                         /*!< RW, Analog pin enable and digital input disable                           */
    
    struct {
            uint16_t            : 6;
      __IOM uint16_t RB_PIN_USB_DP_PU : 1;      /*!< RW, USB UD+pin internal pull-up resistor enable                           */
      __IOM uint16_t RB_PIN_USB_IE : 1;         /*!< RW, USB pin enable                                                        */
            uint16_t            : 8;
    } bit;
  } R16_PIN_ANALOG_IE;
  __IOM uint32_t  R32_PIN_CONFIG2;              /*!< RW, Pin configuration register 2                                          */
  
  union {
    __IOM uint16_t reg;                         /*!< RWA, power plan before sleep instruction, SAM                             */
    
    struct {
      __IOM uint16_t RB_PWR_XROM : 1;           /*!< RWA, power for FlashROM                                                   */
      __IOM uint16_t RB_PWR_RAM2K : 1;          /*!< RWA, SRAM power supply for RAM2K                                          */
      __IOM uint16_t RB_PWR_CORE : 1;           /*!< RWA, power retention for core and base peripherals                        */
      __IOM uint16_t RB_PWR_EXTEND : 1;         /*!< RWA, power retention for USB and BLE                                      */
      __IOM uint16_t RB_PWR_RAM24K : 1;         /*!< RWA, SRAM power supply for RAM24K                                         */
            uint16_t            : 1;
      __IOM uint16_t RB_MAIN_ACT : 1;           /*!< RWA, Main power selection                                                 */
      __IOM uint16_t RB_PWR_SYS_EN : 1;         /*!< RWA, power for system                                                     */
      __IOM uint16_t RB_PWR_LDO_EN : 1;         /*!< RWA, Internal LDO control                                                 */
      __IOM uint16_t RB_PWR_DCDC_EN : 1;        /*!< RWA, DC/DC converter enable                                               */
      __IOM uint16_t RB_PWR_DCDC_PRE : 1;       /*!< RWA, DC/DC converter pre-enable                                           */
            uint16_t            : 4;
      __IOM uint16_t RB_PWR_PLAN_EN : 1;        /*!< RWA, must write 0010                                                      */
    } bit;
  } R16_POWER_PLAN;
  
  union {
    __IOM uint16_t reg;                         /*!< RWA, aux power adjust control, SAM                                        */
    
    struct {
      __IOM uint16_t RB_ULPLDO_ADJ : 3;         /*!< RWA, Output voltage regulation value of auxiliary power supply
                                                     for ultra-low power consumption LDO                                       */
            uint16_t            : 4;
      __IOM uint16_t RB_DCDC_CHARGE : 1;        /*!< RWA, Low power auxiliary DC-DC enable bit                                 */
      __IOM uint16_t RB_CFG_IVREF : 4;          /*!< RWA, retain. The original value must be kept unchanged when
                                                     writing                                                                   */
            uint16_t            : 2;
      __IOM uint16_t RB_IB_TKEY_SEL : 2;        /*!< RWA, TouchKey bias current, used to stabilize I/O potential
                                                     and prevent accidental wake-up                                            */
    } bit;
  } R16_AUX_POWER_ADJ;
  
  union {
    __IOM uint8_t reg;                          /*!< RWA, battery voltage detector control, SAM                                */
    
    struct {
      __IOM uint8_t RB_BAT_DET_EN : 1;          /*!< RWA, When RB_BAT_MON_EN=0, it is enabled by high-precision battery
                                                     voltage detection function                                                */
      __IOM uint8_t RB_BAT_LOW_VTHX : 1;        /*!< RWA, When RB_BAT_MON_EN=1, set low power consumption                      */
      __IOM uint8_t RB_BAT_LOWER_IE : 1;        /*!< RWA, interrupt enable for battery lower voltage                           */
      __IOM uint8_t RB_BAT_LOW_IE : 1;          /*!< RWA, interrupt enable for battery low voltage                             */
            uint8_t             : 4;
    } bit;
  } R8_BAT_DET_CTRL;
  
  union {
    __IOM uint8_t reg;                          /*!< RWA, battery voltage detector configuration, SAM                          */
    
    struct {
      __IOM uint8_t RB_BAT_LOW_VTH : 2;         /*!< RWA, select threshold voltage of battery voltage low                      */
            uint8_t             : 6;
    } bit;
  } R8_BAT_DET_CFG;
  
  union {
    __IM  uint8_t reg;                          /*!< RO, battery status                                                        */
    
    struct {
      __IM  uint8_t RB_BAT_STAT_LOWER : 1;      /*!< RO, battery lower voltage status, high action                             */
      __IM  uint8_t RB_BAT_STAT_LOW : 1;        /*!< RO, battery low voltage status, high action                               */
            uint8_t             : 6;
    } bit;
  } R8_BAT_STATUS;
  __IM  uint8_t   RESERVED2;
  __IM  uint32_t  RESERVED3;
  
  union {
    __IOM uint16_t reg;                         /*!< RWA, internal 32KHz oscillator tune control, SAM                          */
    
    struct {
      __IOM uint16_t RB_INT32K_TUNE : 13;       /*!< RWA, internal 32KHz oscillator frequency tune                             */
            uint16_t            : 3;
    } bit;
  } R16_INT32K_TUNE;
  
  union {
    __IOM uint8_t reg;                          /*!< RWA, External 32KHz oscillator tune control, SAM                          */
    
    struct {
      __IOM uint8_t RB_XT32K_I_TUNE : 2;        /*!< RWA, External 32KHz oscillator bias current selection                     */
            uint8_t             : 2;
      __IOM uint8_t RB_XT32K_C_LOAD : 4;        /*!< RWA, External 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD
                                                     + 12pF                                                                    */
    } bit;
  } R8_XT32K_TUNE;
  
  union {
    __IOM uint8_t reg;                          /*!< RWA, 32KHz oscillator configure                                           */
    
    struct {
      __IOM uint8_t RB_CLK_XT32K_PON : 1;       /*!< RWA, external 32KHz oscillator power on                                   */
      __IOM uint8_t RB_CLK_INT32K_PON : 1;      /*!< RWA, internal 32KHz oscillator power on                                   */
      __IOM uint8_t RB_CLK_OSC32K_XT : 1;       /*!< RWA, 32KHz oscillator source selection: 0=RC, 1=XT                        */
      __IOM uint8_t RB_CLK_OSC32K_FILT : 1;     /*!< RWA, internal 32KHz oscillator low noise mode enable                      */
            uint8_t             : 3;
      __IOM uint8_t RB_32K_CLK_PIN : 1;         /*!< RO, 32KHz oscillator clock pin status                                     */
    } bit;
  } R8_CK32K_CONFIG;
} SYS_Type;                                     /*!< Size = 48 (0x30)                                                          */



/* =========================================================================================================================== */
/* ================                                            RTC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Real time clock (RTC)
  */

typedef struct {                                /*!< RTC Structure                                                             */
  __IM  uint32_t  RESERVED[12];
  
  union {
    __IOM uint8_t reg;                          /*!< RWA, Real time clock                                                      */
    
    struct {
            uint8_t             : 4;
      __IOM uint8_t RB_RTC_TMR_CLR : 1;         /*!< RW, set 1 to clear RTC timer action flag, auto clear                      */
      __IOM uint8_t RB_RTC_TRIG_CLR : 1;        /*!< RW, set 1 to clear RTC trigger action flag, auto clear                    */
      __IM  uint8_t RB_RTC_TMR_FLAG : 1;        /*!< RO, RTC timer action flag                                                 */
      __IM  uint8_t RB_RTC_TRIG_FLAG : 1;       /*!< RO, RTC trigger action flag                                               */
    } bit;
  } R8_RTC_FLAG_CTRL;
  
  union {
    __IOM uint8_t reg;                          /*!< RWA, RTC mode control, SAM                                                */
    
    struct {
      __IOM uint8_t RB_RTC_TMR_MODE : 3;        /*!< RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S,
                                                     100=2S, 101=4S, 110=8S, 111=16S                                           */
      __IOM uint8_t RB_RTC_IGNORE_B0 : 1;       /*!< RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore
                                                     bit0                                                                      */
      __IOM uint8_t RB_RTC_TMR_EN : 1;          /*!< RWA, RTC timer mode enable                                                */
      __IOM uint8_t RB_RTC_TRIG_EN : 1;         /*!< RWA, RTC trigger mode enable                                              */
      __IOM uint8_t RB_RTC_LOAD_LO : 1;         /*!< RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto
                                                     clear after loaded                                                        */
      __IOM uint8_t RB_RTC_LOAD_HI : 1;         /*!< RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto
                                                     clear after loaded                                                        */
    } bit;
  } R8_RTC_MODE_CTRL;
  __IM  uint16_t  RESERVED1;
  
  union {
    __IOM uint32_t reg;                         /*!< RWA, RTC trigger value, SAM                                               */
    
    struct {
      __IOM uint32_t R32_RTC_TRIG : 32;         /*!< RWA, RTC trigger value                                                    */
    } bit;
  } R32_RTC_TRIG;
  
  union {
    __IM  uint16_t reg;                         /*!< RO, RTC count based 32KHz                                                 */
    
    struct {
      __IM  uint16_t R16_RTC_CNT_32K : 16;      /*!< R0,RTC count based 32KHz                                                  */
    } bit;
  } R16_RTC_CNT_32K;
  
  union {
    __IM  uint16_t reg;                         /*!< RO, RTC count based 2 second                                              */
    
    struct {
      __IM  uint16_t R16_RTC_CNT_2S : 16;       /*!< RO, RTC count based 2 second                                              */
    } bit;
  } R16_RTC_CNT_2S;
  
  union {
    __IM  uint32_t reg;                         /*!< RO, RTC count based one day, only low 14 bit                              */
    
    struct {
      __IM  uint32_t R32_RTC_CNT_DAY : 14;      /*!< RWA,RTC count based one day                                               */
            uint32_t            : 18;
    } bit;
  } R32_RTC_CNT_DAY;
} RTC_Type;                                     /*!< Size = 64 (0x40)                                                          */



/* =========================================================================================================================== */
/* ================                                      System_control                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief System control related registers (System_control)
  */

typedef struct {                                /*!< System_control Structure                                                  */
  __IM  uint16_t  RESERVED[32];
  
  union {
    __IOM uint8_t reg;                          /*!< WO, safe accessing sign register, must write SAFE_ACCESS_SIG1
                                                     then SAFE_ACCESS_SIG2 to enter safe accessing mode                        */
    
    struct {
      __IM  uint8_t RB_SAFE_ACC_MODE : 2;       /*!< RO, current safe accessing mode: 11=safe unlocked (SAM), other=locked
                                                     (00..01..10..11)                                                          */
            uint8_t             : 1;
      __IM  uint8_t RB_SAFE_ACC_ACT : 1;        /*!< RO, indicate safe accessing status now: 0=locked, read only,
                                                     1=safe/unlocked (SAM), write enabled                                      */
      __IM  uint8_t RB_SAFE_ACC_TIMER : 3;      /*!< RO, safe accessing timer bit mask (16*clock number)                       */
            uint8_t             : 1;
    } bit;
    
    struct {
      __OM  uint8_t R8_SAFE_ACCESS_SIG : 8;     /*!< WO, safe accessing sign register, must write 0x57 then 0xA8
                                                     to enter safe accessing mode                                              */
    } bit;
  } R8_SAFE_ACCESS_SIG;
  
  union {
    __IOM uint8_t reg;                          /*!< RF, chip ID register, always is ID_CH59*                                  */
    
    struct {
      __IM  uint8_t R8_CHIP_ID  : 8;            /*!< RF,chip ID register                                                       */
    } bit;
  } R8_CHIP_ID;
  
  union {
    __IOM uint8_t reg;                          /*!< RF, safe accessing ID register, always 0x0C                               */
    
    struct {
      __IM  uint8_t R8_SAFE_ACCESS_ID : 8;      /*!< RF,safe accessing ID register                                             */
    } bit;
  } R8_SAFE_ACCESS_ID;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, watch-dog count, count by clock frequency Fsys/131072                 */
    
    struct {
      __IOM uint8_t R8_WDOG_COUNT : 8;          /*!< RW,watch-dog count, count by clock frequency Fsys/131072                  */
    } bit;
  } R8_WDOG_COUNT;
  
  union {
    __IOM uint8_t reg;                          /*!< RWA, reset status, SAM or flash ROM configuration                         */
    
    struct {
      __IM  uint8_t RB_RESET_FLAG : 3;          /*!< RO, recent reset flag                                                     */
            uint8_t             : 1;
      __IOM uint8_t RB_ROM_CODE_OFS : 1;        /*!< RWA, code offset address selection in Flash ROM: 0=start address
                                                     0x000000, 1=start address 0x008000                                        */
      __IOM uint8_t RB_ROM_CTRL_EN : 1;         /*!< RWA, enable flash ROM control interface enable                            */
      __IOM uint8_t RB_ROM_DATA_WE : 1;         /*!< RWA,enable flash ROM data and code area being erase/write                 */
      __IOM uint8_t RB_ROM_CODE_WE : 1;         /*!< RWA, enable flash ROM code area being erase or write                      */
    } bit;
  } R8_RESET_STATUS_R8_GLOB_ROM_CFG;
  
  union {
    __IM  uint8_t reg;                          /*!< RO, global configuration information and status                           */
    
    struct {
      __IM  uint8_t RB_CFG_ROM_READ : 1;        /*!< RO, indicate protected status of Flash ROM code and data: 0=reading
                                                     protect, 1=enable read by external programmer                             */
            uint8_t             : 1;
      __IM  uint8_t RB_CFG_RESET_EN : 1;        /*!< RO, manual reset input enable status                                      */
      __IM  uint8_t RB_CFG_BOOT_EN : 1;         /*!< RO, boot-loader enable status                                             */
      __IM  uint8_t RB_CFG_DEBUG_EN : 1;        /*!< RO, debug enable status                                                   */
      __IM  uint8_t RB_BOOT_LOADER : 1;         /*!< RO, indicate boot loader status: 0=application status (by software
                                                     reset), 1=boot loader status                                              */
            uint8_t             : 2;
    } bit;
  } R8_GLOB_CFG_INFO;
  
  union {
    __IOM uint8_t reg;                          /*!< RWA, reset and watch-dog control, SAM                                     */
    
    struct {
      __IOM uint8_t RB_SOFTWARE_RESET : 1;      /*!< WA or WZ, global software reset, high action, auto clear                  */
      __IOM uint8_t RB_WDOG_RST_EN : 1;         /*!< RWA, enable watch-dog reset if watch-dog timer overflow: 0=as
                                                     timer only, 1=enable reset if timer overflow                              */
      __IOM uint8_t RB_WDOG_INT_EN : 1;         /*!< RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable       */
            uint8_t             : 1;
      __IOM uint8_t RB_WDOG_INT_FLAG : 1;       /*!< RW1, watch-dog timer overflow interrupt flag, cleared by RW1
                                                     or reload watch-dog count or __SEV(Send-Event)                            */
            uint8_t             : 3;
    } bit;
  } R8_RST_WDOG_CTRL;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, value keeper during global reset                                      */
    
    struct {
      __IOM uint8_t R8_GLOB_RESET_KEEP : 8;     /*!< RW, value keeper during global reset                                      */
    } bit;
  } R8_GLOB_RESET_KEEP;
  __IM  uint16_t  RESERVED1;
  __IM  uint8_t   RESERVED2;
  
  union {
    __IOM uint8_t reg;                          /*!< RWA, PLL configuration control, SAM                                       */
    
    struct {
      __IOM uint8_t RB_PLL_CFG_DAT : 7;         /*!< RWA, PLL configure data                                                   */
            uint8_t             : 1;
    } bit;
  } R8_PLL_CONFIG;
  __IM  uint16_t  RESERVED3;
  
  union {
    __IOM uint8_t reg;                          /*!< RWA, external 32MHz oscillator tune control, SAM                          */
    
    struct {
      __IOM uint8_t RB_XT32M_I_BIAS : 2;        /*!< RWA, external 32MHz oscillator bias current tune: 00=75% current,
                                                     01=standard current, 10=125% current, 11=150% current                     */
            uint8_t             : 2;
      __IOM uint8_t RB_XT32M_C_LOAD : 3;        /*!< RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD
                                                     * 2 + 10pF                                                                */
            uint8_t             : 1;
    } bit;
  } R8_XT32M_TUNE;
  __IM  uint8_t   RESERVED4;
  
  union {
    __IM  uint16_t reg;                         /*!< RO, system clock count value for 32KHz multi-cycles                       */
    
    struct {
      __IM  uint16_t RB_OSC_CAL_CNT : 14;       /*!< RO, system clock count value for 32KHz multi-cycles                       */
      __IM  uint16_t RB_OSC_CAL_OV_CLR : 1;     /*!< RW1, indicate R8_OSC_CAL_OV_CNT not zero, set 1 to clear R8_OSC_CAL_OV_CNT */
      __IM  uint16_t RB_OSC_CAL_IF : 1;         /*!< RW1, interrupt flag for oscillator capture end, set 1 to clear            */
    } bit;
  } R16_OSC_CAL_CNT;
  
  union {
    __IOM uint8_t reg;                          /*!< RO, oscillator frequency calibration overflow times                       */
    
    struct {
      __IOM uint8_t R8_OSC_CAL_OV_CNT : 8;      /*!< RO, oscillator frequency calibration overflow times                       */
    } bit;
  } R8_OSC_CAL_OV_CNT;
  
  union {
    __IOM uint8_t reg;                          /*!< RWA, oscillator frequency calibration control, SAM                        */
    
    struct {
      __IOM uint8_t RB_OSC_CNT_TOTAL : 3;       /*!< RWA, total cycles mode for oscillator capture                             */
      __IM  uint8_t RB_OSC_CNT_HALT : 1;        /*!< RO, calibration counter halt status: 0=counting, 1=halt for
                                                     reading count value                                                       */
      __IOM uint8_t RB_OSC_CAL_IE : 1;          /*!< RWA, interrupt enable for oscillator capture end                          */
      __IOM uint8_t RB_OSC_CNT_EN : 1;          /*!< RWA, calibration counter enable                                           */
      __IOM uint8_t RB_OSC_CNT_END : 1;         /*!< RWA, select oscillator capture end mode: 0=normal, 1=append
                                                     2 cycles                                                                  */
            uint8_t             : 1;
    } bit;
  } R8_OSC_CAL_CTRL;
} System_control_Type;                          /*!< Size = 84 (0x54)                                                          */



/* =========================================================================================================================== */
/* ================                                         TouchKey                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Touch buttons (TouchKey)
  */

typedef struct {                                /*!< TouchKey Structure                                                        */
  __IM  uint8_t   RESERVED[84];
  
  union {
    __IOM uint8_t reg;                          /*!< RW, Touchkey charge and discharge count                                   */
    
    struct {
      __IOM uint8_t RB_TKEY_CHARG_CNT : 5;      /*!< RW, Touchkey charge count                                                 */
      __IOM uint8_t RB_TKEY_DISCH_CNT : 3;      /*!< RW, Touchkey discharge count                                              */
    } bit;
  } R8_TKEY_COUNT;
  __IM  uint8_t   RESERVED1;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, Touchkey convert start control                                        */
    
    struct {
      __IOM uint8_t RB_TKEY_START : 1;          /*!< RW, Touchkey convert start control                                        */
            uint8_t             : 7;
    } bit;
  } R8_TKEY_CONVERT;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, Touchkey configure                                                    */
    
    struct {
      __IOM uint8_t RB_TKEY_PWR_ON : 1;         /*!< RW, Touchkey power on                                                     */
      __IOM uint8_t RB_TKEY_CURRENT : 1;        /*!< R0, Touchkey charge current selection                                     */
      __IOM uint8_t RB_TKEY_DRV_EN : 1;         /*!< RW, Touchkey drive shield enable                                          */
      __IOM uint8_t RB_TKEY_PGA_ADJ : 1;        /*!< RW, ADC input PGA speed selection                                         */
      __IOM uint8_t RB_TKEY_DMA_EN : 1;         /*!< RW, TouchKey DMA Enable                                                   */
      __IOM uint8_t RB_TKEY_AUTO_EN : 1;        /*!< RW, TouchKey automatic trigger enable                                     */
      __IOM uint8_t RB_TKEY_RAND_EN : 1;        /*!< RW, TouchKey Trigger enable at will                                       */
            uint8_t             : 1;
    } bit;
  } R8_TKEY_CFG;
} TouchKey_Type;                                /*!< Size = 88 (0x58)                                                          */



/* =========================================================================================================================== */
/* ================                                            ADC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Analog to Digital Converter (ADC)
  */

typedef struct {                                /*!< ADC Structure                                                             */
  __IM  uint16_t  RESERVED[44];
  
  union {
    __IOM uint8_t reg;                          /*!< RW, ADC input channel selection                                           */
    
    struct {
      __IOM uint8_t RB_ADC_CH_INX : 4;          /*!< RW, ADC input channel index                                               */
            uint8_t             : 4;
    } bit;
  } R8_ADC_CHANNEL;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, ADC configure                                                         */
    
    struct {
      __IOM uint8_t RB_ADC_POWER_ON : 1;        /*!< RW, ADC power control: 0=power down, 1=power on                           */
      __IOM uint8_t RB_ADC_BUF_EN : 1;          /*!< RW, ADC input buffer enable                                               */
      __IOM uint8_t RB_ADC_DIFF_EN : 1;         /*!< RW, ADC input channel mode: 0=single-end, 1=differnetial                  */
      __IOM uint8_t RB_ADC_OFS_TEST : 1;        /*!< RW, enable ADC offset test mode: 0=normal mode, 1=short to test
                                                     offset                                                                    */
            uint8_t             : 2;
      __IOM uint8_t RB_ADC_CLK_DIV : 2;         /*!< RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz,
                                                     11=4MHz                                                                   */
    } bit;
  } R8_ADC_CFG;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, ADC convert control                                                   */
    
    struct {
      __IOM uint8_t RB_ADC_START : 1;           /*!< RW, ADC convert start control: 0=stop ADC convert, 1=start an
                                                     ADC convert, auto clear                                                   */
            uint8_t             : 6;
      __IM  uint8_t RB_ADC_EOC_X : 1;           /*!< RO, end of ADC conversion flag                                            */
    } bit;
  } R8_ADC_CONVERT;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, temperature sensor control                                            */
    
    struct {
            uint8_t             : 7;
      __IOM uint8_t RB_TEM_SEN_PWR_ON : 1;      /*!< RW, temperature sensor power control: 0=power down, 1=power
                                                     on                                                                        */
    } bit;
  } R8_TEM_SENSOR;
  
  union {
    __IM  uint16_t reg;                         /*!< RO, ADC data                                                              */
    
    struct {
      __IM  uint16_t RB_ADC_DATA : 12;          /*!< RO, ADC conversion data                                                   */
            uint16_t            : 4;
    } bit;
  } R16_ADC_DATA;
  
  union {
    __IM  uint8_t reg;                          /*!< RO, ADC interrupt flag register                                           */
    
    struct {
            uint8_t             : 7;
      __IM  uint8_t RB_ADC_IF_EOC : 1;          /*!< RO, ADC conversion interrupt flag                                         */
    } bit;
  } R8_ADC_INT_FLAG;
  __IM  uint8_t   RESERVED1[2];
  
  union {
    __IOM uint8_t reg;                          /*!< RW, ADC DMA control                                                       */
    
    struct {
      __IOM uint8_t RB_ADC_DMA_ENABLE : 1;      /*!< RW, ADC DMA enable                                                        */
            uint8_t             : 1;
      __IOM uint8_t RB_ADC_DMA_LOOP : 1;        /*!< RW, ADC DMA address loop enable                                           */
      __IOM uint8_t RB_ADC_IE_DMA_END : 1;      /*!< RW, enable interrupt for ADC DMA completion                               */
      __IOM uint8_t RB_ADC_IE_EOC : 1;          /*!< RW, enable interrupt for end of ADC conversion                            */
            uint8_t             : 1;
      __IOM uint8_t RB_ADC_CONT_EN : 1;         /*!< RW, enable contineous conversion ADC                                      */
      __IOM uint8_t RB_ADC_AUTO_EN : 1;         /*!< RW, enable auto continuing ADC for DMA                                    */
    } bit;
  } R8_ADC_CTRL_DMA;
  
  union {
    __IOM uint8_t reg;                          /*!< RW1, ADC and DMA interrupt flag registers                                 */
    
    struct {
            uint8_t             : 3;
      __IOM uint8_t RB_ADC_IF_DMA_END : 1;      /*!< interrupt flag for ADC DMA completion                                     */
      __IOM uint8_t RB_ADC_IF_END_ADC : 1;      /*!< interrupt flag for end of ADC conversion                                  */
            uint8_t             : 3;
    } bit;
  } R8_ADC_DMA_IF;
  
  union {
    __IOM uint8_t reg;                          /*!< RO, ADC interrupt flag                                                    */
    
    struct {
      __IOM uint8_t R8_ADC_AUTO_CYCLE : 8;      /*!< auto ADC cycle value, unit is 16 Fsys                                     */
    } bit;
  } R8_ADC_AUTO_CYCLE;
  __IM  uint8_t   R16_ADC_DMA_NOW;              /*!< RO, ADC DMA current address                                               */
  __IM  uint8_t   RESERVED2;
  __IM  uint16_t  RESERVED3;
  __IOM uint8_t   R16_ADC_DMA_BEG;              /*!< RW, ADC DMA begin address                                                 */
  __IM  uint8_t   RESERVED4;
  __IM  uint16_t  RESERVED5;
  __IOM uint8_t   R16_ADC_DMA_END;              /*!< RW, ADC DMA end address                                                   */
  __IM  uint8_t   RESERVED6;
  __IM  uint16_t  RESERVED7;
} ADC_Type;                                     /*!< Size = 112 (0x70)                                                         */



/* =========================================================================================================================== */
/* ================                                           GPIO                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief General porpose intput output (GPIO)
  */

typedef struct {                                /*!< GPIO Structure                                                            */
  __IM  uint32_t  RESERVED[36];
  
  union {
    __IOM uint16_t reg;                         /*!< RW, GPIO PA interrupt enable                                              */
    
    struct {
      __IOM uint16_t R16_PA_INT_EN : 16;        /*!< GPIO PA interrupt enable                                                  */
    } bit;
  } R16_PA_INT_EN;
  
  union {
    __IOM uint16_t reg;                         /*!< RW, GPIO PB interrupt enable                                              */
    
    struct {
      __IOM uint16_t R16_PB_INT_EN : 16;        /*!< GPIO PB interrupt enable                                                  */
    } bit;
  } R16_PB_INT_EN;
  
  union {
    __IOM uint16_t reg;                         /*!< RW, GPIO PA interrupt mode: 0=level action, 1=edge action                 */
    
    struct {
      __IOM uint16_t R16_PA_INT_MODE : 16;      /*!< GPIO PA interrupt mode                                                    */
    } bit;
  } R16_PA_INT_MODE;
  
  union {
    __IOM uint16_t reg;                         /*!< RW, GPIO PB interrupt mode: 0=level action, 1=edge action;RW,
                                                     status for parallel slave read                                            */
    
    struct {
      __IOM uint16_t R16_PB_INT_MODE : 16;      /*!< GPIO PB interrupt mode                                                    */
    } bit;
  } R16_PB_INT_MODE;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint16_t reg;                         /*!< RW1, GPIO PA interrupt flag                                               */
    
    struct {
      __IOM uint16_t R16_PA_INT_IF : 16;        /*!< GPIO PA interrupt flag                                                    */
    } bit;
  } R16_PA_INT_IF;
  
  union {
    __IOM uint16_t reg;                         /*!< RW1, GPIO PB interrupt flag                                               */
    
    struct {
      __IOM uint16_t R16_PB_INT_IF : 16;        /*!< GPIO PB interrupt flag                                                    */
    } bit;
  } R16_PB_INT_IF;
  
  union {
    __IOM uint32_t reg;                         /*!< RW, GPIO PA I/O direction: 0=in, 1=out                                    */
    
    struct {
      __IOM uint32_t R8_PA_DIR_0 : 8;           /*!< GPIO PA I/O direction byte 0                                              */
      __IOM uint32_t R8_PA_DIR_1 : 8;           /*!< GPIO PA I/O direction byte 1                                              */
            uint32_t            : 16;
    } bit;
  } R32_PA_DIR;
  
  union {
    __IM  uint32_t reg;                         /*!< RO, GPIO PA input                                                         */
    
    struct {
      __IM  uint32_t R8_PA_PIN_0 : 8;           /*!< GPIO PA input byte 0                                                      */
      __IM  uint32_t R8_PA_PIN_1 : 8;           /*!< GPIO PA input byte 1                                                      */
            uint32_t            : 16;
    } bit;
  } R32_PA_PIN;
  
  union {
    __IOM uint32_t reg;                         /*!< RW, GPIO PA output                                                        */
    
    struct {
      __IOM uint32_t R8_PA_OUT_0 : 8;           /*!< GPIO PA output byte 0                                                     */
      __IOM uint32_t R8_PA_OUT_1 : 8;           /*!< GPIO PA output byte 1                                                     */
            uint32_t            : 16;
    } bit;
  } R32_PA_OUT;
  
  union {
    __OM  uint32_t reg;                         /*!< WZ, GPIO PA clear output: 0=keep, 1=clear                                 */
    
    struct {
      __OM  uint32_t R8_PA_CLR_0 : 8;           /*!< GPIO PA clear output byte 0                                               */
      __OM  uint32_t R8_PA_CLR_1 : 8;           /*!< GPIO PA clear output byte 1                                               */
            uint32_t            : 16;
    } bit;
  } R32_PA_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< RW, GPIO PA pullup resistance enable                                      */
    
    struct {
      __IOM uint32_t R8_PA_PU_0 : 8;            /*!< GPIO PA pullup resistance enable byte 0                                   */
      __IOM uint32_t R8_PA_PU_1 : 8;            /*!< GPIO PA pullup resistance enable byte 0                                   */
            uint32_t            : 16;
    } bit;
  } R32_PA_PU;
  
  union {
    __IOM uint32_t reg;                         /*!< RW, PA pulldown for input or PA driving capability for output             */
    
    struct {
      __IOM uint32_t R8_PA_PD_DRV_0 : 8;        /*!< PA pulldown for input or PA driving capability for output byte
                                                     0                                                                         */
      __IOM uint32_t R8_PA_PD_DRV_1 : 8;        /*!< PA pulldown for input or PA driving capability for output byte
                                                     1                                                                         */
            uint32_t            : 16;
    } bit;
  } R32_PA_PD_DRV;
  __IM  uint32_t  RESERVED2[2];
  
  union {
    __IOM uint32_t reg;                         /*!< RW, GPIO PB I/O direction: 0=in, 1=out                                    */
    
    struct {
      __IOM uint32_t R8_PB_DIR_0 : 8;           /*!< GPIO PB I/O direction byte 0                                              */
      __IOM uint32_t R8_PB_DIR_1 : 8;           /*!< GPIO PB I/O direction byte 1                                              */
      __IOM uint32_t R8_PB_DIR_2 : 8;           /*!< GPIO PB I/O direction byte 2                                              */
            uint32_t            : 8;
    } bit;
  } R32_PB_DIR;
  
  union {
    __IM  uint32_t reg;                         /*!< RO, GPIO PB input                                                         */
    
    struct {
      __IM  uint32_t R8_PB_PIN_0 : 8;           /*!< GPIO PB input byte 0                                                      */
      __IM  uint32_t R8_PB_PIN_1 : 8;           /*!< GPIO PB input byte 1                                                      */
      __IM  uint32_t R8_PB_PIN_2 : 8;           /*!< GPIO PB input byte 2                                                      */
            uint32_t            : 8;
    } bit;
  } R32_PB_PIN;
  
  union {
    __IOM uint32_t reg;                         /*!< RW, GPIO PB output;RW, data for parallel slave read                       */
    
    struct {
      __IOM uint32_t R8_PB_OUT_0 : 8;           /*!< GPIO PB output byte 0                                                     */
      __IOM uint32_t R8_PB_OUT_1 : 8;           /*!< GPIO PB output byte 1                                                     */
      __IOM uint32_t R8_PB_OUT_2 : 8;           /*!< GPIO PB output byte 2                                                     */
            uint32_t            : 8;
    } bit;
  } R32_PB_OUT;
  
  union {
    __IOM uint32_t reg;                         /*!< WZ, GPIO PB clear output: 0=keep, 1=clear                                 */
    
    struct {
      __IOM uint32_t R8_PB_CLR_0 : 8;           /*!< GPIO PB clear output byte 0                                               */
      __IOM uint32_t R8_PB_CLR_1 : 8;           /*!< GPIO PB clear output byte 1                                               */
      __IOM uint32_t R8_PB_CLR_2 : 8;           /*!< GPIO PB clear output byte 2                                               */
            uint32_t            : 8;
    } bit;
  } R32_PB_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< RW, GPIO PB pullup resistance enable                                      */
    
    struct {
      __IOM uint32_t R8_PB_PU_0 : 8;            /*!< GPIO PB pullup resistance enable byte 0                                   */
      __IOM uint32_t R8_PB_PU_1 : 8;            /*!< GPIO PB pullup resistance enable byte 1                                   */
      __IOM uint32_t R8_PB_PU_2 : 8;            /*!< GPIO PB pullup resistance enable byte 2                                   */
            uint32_t            : 8;
    } bit;
  } R32_PB_PU;
  
  union {
    __IOM uint32_t reg;                         /*!< RW, PB pulldown for input or PB driving capability for output             */
    
    struct {
      __IOM uint32_t R8_PB_PD_DRV_0 : 8;        /*!< PB pulldown for input or PB driving capability for output byte
                                                     0                                                                         */
      __IOM uint32_t R8_PB_PD_DRV_1 : 8;        /*!< PB pulldown for input or PB driving capability for output byte
                                                     0                                                                         */
      __IOM uint32_t R8_PB_PD_DRV_2 : 8;        /*!< PB pulldown for input or PB driving capability for output byte
                                                     0                                                                         */
            uint32_t            : 8;
    } bit;
  } R32_PB_PD_DRV;
} GPIO_Type;                                    /*!< Size = 216 (0xd8)                                                         */



/* =========================================================================================================================== */
/* ================                                           TMR0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Timer0 register (TMR0)
  */

typedef struct {                                /*!< TMR0 Structure                                                            */
  
  union {
    __IOM uint8_t reg;                          /*!< RW, TMR0 mode control                                                     */
    
    struct {
      __IOM uint8_t RB_TMR_MODE_IN : 1;         /*!< RW, timer in mode: 0=timer/PWM, 1=capture/count                           */
      __IOM uint8_t RB_TMR_ALL_CLEAR : 1;       /*!< RW, force clear timer FIFO and count                                      */
      __IOM uint8_t RB_TMR_COUNT_EN : 1;        /*!< RW, timer count enable                                                    */
      __IOM uint8_t RB_TMR_OUT_EN : 1;          /*!< RW, timer output enable                                                   */
      __IOM uint8_t RB_TMR_OUT_POLAR_RB_TMR_CAP_COUNT : 1;/*!< RW, timer PWM output polarity: 0=default low and high action,
                                                     1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1:
                                                     0=capture, 1=count                                                        */
            uint8_t             : 1;
      __IOM uint8_t RB_TMR_PWM_REPEAT_RB_TMR_CAP_EDGE : 2;/*!< RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer
                                                     capture edge mode: 00=disable, 01=edge change, 10=fall
                                                     to fall, 11-rise to rise                                                  */
    } bit;
  } R8_TMR0_CTRL_MOD;
  __IM  uint8_t   RESERVED;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, TMR0 interrupt enable                                                 */
    
    struct {
      __IOM uint8_t RB_TMR_IE_CYC_END : 1;      /*!< RW, enable interrupt for timer capture count timeout or PWM
                                                     cycle end                                                                 */
      __IOM uint8_t RB_TMR_IE_DATA_ACT : 1;     /*!< RW, enable interrupt for timer capture input action or PWM trigger        */
      __IOM uint8_t RB_TMR_IE_FIFO_HF : 1;      /*!< RW, enable interrupt for timer FIFO half (capture fifo >=4 or
                                                     PWM fifo less than 3)                                                     */
      __IOM uint8_t RB_TMR_IE_DMA_END : 1;      /*!< RW, enable interrupt for timer1/2 DMA completion                          */
      __IOM uint8_t RB_TMR_IE_FIFO_OV : 1;      /*!< RW, enable interrupt for timer FIFO overflow                              */
            uint8_t             : 3;
    } bit;
  } R8_TMR0_INTER_EN;
  __IM  uint8_t   RESERVED1;
  __IM  uint16_t  RESERVED2;
  
  union {
    __IOM uint8_t reg;                          /*!< RW1, TMR0 interrupt flag                                                  */
    
    struct {
      __IOM uint8_t RB_TMR_IF_CYC_END : 1;      /*!< RW1, interrupt flag for timer capture count timeout or PWM cycle
                                                     end                                                                       */
      __IOM uint8_t RB_TMR_IF_DATA_ACT : 1;     /*!< RW1, interrupt flag for timer capture input action or PWM trigger         */
      __IOM uint8_t RB_TMR_IF_FIFO_HF : 1;      /*!< RW1, interrupt flag for timer FIFO half (capture fifo >=4 or
                                                     PWM fifo less than 3                                                      */
      __IOM uint8_t RB_TMR_IF_DMA_END : 1;      /*!< RW1, interrupt flag for timer1/2 DMA completion                           */
      __IOM uint8_t RB_TMR_IF_FIFO_OV : 1;      /*!< RW1, interrupt flag for timer FIFO overflow                               */
            uint8_t             : 3;
    } bit;
  } R8_TMR0_INT_FLAG;
  
  union {
    __IM  uint8_t reg;                          /*!< RO, TMR0 FIFO count status                                                */
    
    struct {
      __IM  uint8_t R8_TMR0_FIFO_COUNT : 4;     /*!< R0,TMR0 FIFO count status                                                 */
            uint8_t             : 4;
    } bit;
  } R8_TMR0_FIFO_COUNT;
  
  union {
    __IM  uint32_t reg;                         /*!< RO, TMR0 current count                                                    */
    
    struct {
      __IM  uint32_t R32_TMR0_COUNT : 26;       /*!< RW1,TMR0 current count                                                    */
            uint32_t            : 6;
    } bit;
  } R32_TMR0_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< RW, TMR0 end count value, only low 26 bit                                 */
    
    struct {
      __IOM uint32_t R32_TMR0_CNT_END : 32;     /*!< RW1,TMR0 end count value                                                  */
    } bit;
  } R32_TMR0_CNT_END;
  
  union {
    __IM  uint32_t reg;                         /*!< RO/WO, TMR0 FIFO register, only low 26 bit                                */
    
    struct {
      __IM  uint32_t R32_TMR0_FIFO : 32;        /*!< RW1,TMR0 FIFO register                                                    */
    } bit;
  } R32_TMR0_FIFO;
} TMR0_Type;                                    /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                           TMR1                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Timer1 register (TMR1)
  */

typedef struct {                                /*!< TMR1 Structure                                                            */
  
  union {
    __IOM uint8_t reg;                          /*!< RW, TMR1 mode control                                                     */
    
    struct {
      __IOM uint8_t RB_TMR_MODE_IN : 1;         /*!< RW, timer in mode: 0=timer/PWM, 1=capture/count                           */
      __IOM uint8_t RB_TMR_ALL_CLEAR : 1;       /*!< RW, force clear timer FIFO and count                                      */
      __IOM uint8_t RB_TMR_COUNT_EN : 1;        /*!< RW, timer count enable                                                    */
      __IOM uint8_t RB_TMR_OUT_EN : 1;          /*!< RW, timer output enable                                                   */
      __IOM uint8_t RB_TMR_OUT_POLAR_RB_TMR_CAP_COUNT : 1;/*!< RW, timer PWM output polarity: 0=default low and high action,
                                                     1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1:
                                                     0=capture, 1=count                                                        */
            uint8_t             : 1;
      __IOM uint8_t RB_TMR_PWM_REPEAT_RB_TMR_CAP_EDGE : 2;/*!< RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer
                                                     capture edge mode: 00=disable, 01=edge change, 10=fall
                                                     to fall, 11-rise to rise                                                  */
    } bit;
  } R8_TMR1_CTRL_MOD;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, TMR1 DMA control                                                      */
    
    struct {
      __IOM uint8_t RB_TMR_DMA_ENABLE : 1;      /*!< RW, timer1/2 DMA enable                                                   */
            uint8_t             : 1;
      __IOM uint8_t RB_TMR_DMA_LOOP : 1;        /*!< RW, timer1/2 DMA address loop enable                                      */
            uint8_t             : 5;
    } bit;
  } R8_TMR1_CTRL_DMA;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, TMR1 interrupt enable                                                 */
    
    struct {
      __IOM uint8_t RB_TMR_IE_CYC_END : 1;      /*!< RW, enable interrupt for timer capture count timeout or PWM
                                                     cycle end                                                                 */
      __IOM uint8_t RB_TMR_IE_DATA_ACT : 1;     /*!< RW, enable interrupt for timer capture input action or PWM trigger        */
      __IOM uint8_t RB_TMR_IE_FIFO_HF : 1;      /*!< RW, enable interrupt for timer FIFO half (capture fifo >=4 or
                                                     PWM fifo less than 3)                                                     */
      __IOM uint8_t RB_TMR_IE_DMA_END : 1;      /*!< RW, enable interrupt for timer1/2 DMA completion                          */
      __IOM uint8_t RB_TMR_IE_FIFO_OV : 1;      /*!< RW, enable interrupt for timer FIFO overflow                              */
            uint8_t             : 3;
    } bit;
  } R8_TMR1_INTER_EN;
  __IM  uint8_t   RESERVED;
  __IM  uint16_t  RESERVED1;
  
  union {
    __IOM uint8_t reg;                          /*!< RW1, TMR1 interrupt flag                                                  */
    
    struct {
      __IOM uint8_t RB_TMR_IF_CYC_END : 1;      /*!< RW1, interrupt flag for timer capture count timeout or PWM cycle
                                                     end                                                                       */
      __IOM uint8_t RB_TMR_IF_DATA_ACT : 1;     /*!< RW1, interrupt flag for timer capture input action or PWM trigger         */
      __IOM uint8_t RB_TMR_IF_FIFO_HF : 1;      /*!< RW1, interrupt flag for timer FIFO half (capture fifo >=4 or
                                                     PWM fifo less than 3                                                      */
      __IOM uint8_t RB_TMR_IF_DMA_END : 1;      /*!< RW1, interrupt flag for timer1/2 DMA completion                           */
      __IOM uint8_t RB_TMR_IF_FIFO_OV : 1;      /*!< RW1, interrupt flag for timer FIFO overflow                               */
            uint8_t             : 3;
    } bit;
  } R8_TMR1_INT_FLAG;
  
  union {
    __IM  uint8_t reg;                          /*!< RO, TMR1 FIFO count status                                                */
    
    struct {
      __IM  uint8_t R8_TMR1_FIFO_COUNT : 4;     /*!< RW1, TMR1 FIFO count status                                               */
            uint8_t             : 4;
    } bit;
  } R8_TMR1_FIFO_COUNT;
  
  union {
    __IM  uint32_t reg;                         /*!< RO, TMR1 current count                                                    */
    
    struct {
      __IM  uint32_t R32_TMR1_COUNT : 26;       /*!< RW1,TMR1 current count                                                    */
            uint32_t            : 6;
    } bit;
  } R32_TMR1_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< RW, TMR1 end count value, only low 26 bit                                 */
    
    struct {
      __IOM uint32_t R32_TMR1_CNT_END : 32;     /*!< RW1,TMR1 end count value,                                                 */
    } bit;
  } R32_TMR1_CNT_END;
  
  union {
    __IM  uint32_t reg;                         /*!< RO, TMR1 FIFO register, only low 26 bit                                   */
    
    struct {
      __IM  uint32_t R32_TMR1_FIFO : 32;        /*!< RW1,TMR1 FIFO register                                                    */
    } bit;
  } R32_TMR1_FIFO;
  
  union {
    __IM  uint16_t reg;                         /*!< RO, TMR1 DMA current address                                              */
    
    struct {
            uint16_t            : 2;
      __IM  uint16_t R16_TMR1_DMA_NOW : 13;     /*!< RO,DMA data buffer current address                                        */
            uint16_t            : 1;
    } bit;
  } R16_TMR1_DMA_NOW;
  __IM  uint16_t  RESERVED2;
  
  union {
    __IOM uint16_t reg;                         /*!< RW, TMR1 DMA begin address                                                */
    
    struct {
            uint16_t            : 2;
      __IOM uint16_t R16_TMR1_DMA_BEG : 13;     /*!< RW,TMR1 DMA data buffer start address                                     */
            uint16_t            : 1;
    } bit;
  } R16_TMR1_DMA_BEG;
  __IM  uint16_t  RESERVED3;
  
  union {
    __IOM uint16_t reg;                         /*!< RW, TMR1 DMA end address                                                  */
    
    struct {
            uint16_t            : 2;
      __IOM uint16_t R16_TMR1_DMA_END : 13;     /*!< RW,DMA data buffer end address                                            */
            uint16_t            : 1;
    } bit;
  } R16_TMR1_DMA_END;
  __IM  uint16_t  RESERVED4;
} TMR1_Type;                                    /*!< Size = 32 (0x20)                                                          */



/* =========================================================================================================================== */
/* ================                                           TMR2                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Timer2 register (TMR2)
  */

typedef struct {                                /*!< TMR2 Structure                                                            */
  
  union {
    __IOM uint8_t reg;                          /*!< RW, TMR2 mode control                                                     */
    
    struct {
      __IOM uint8_t RB_TMR_MODE_IN : 1;         /*!< RW, timer in mode: 0=timer_PWM, 1=capture_count                           */
      __IOM uint8_t RB_TMR_ALL_CLEAR : 1;       /*!< RW, force clear timer FIFO and count                                      */
      __IOM uint8_t RB_TMR_COUNT_EN : 1;        /*!< RW, timer count enable                                                    */
      __IOM uint8_t RB_TMR_OUT_EN : 1;          /*!< RW, timer output enable                                                   */
      __IOM uint8_t RB_TMR_OUT_POLAR_RB_TMR_CAP_COUNT : 1;/*!< RW, timer PWM output polarity: 0=default low and high action,
                                                     1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1:
                                                     0=capture, 1=count                                                        */
            uint8_t             : 1;
      __IOM uint8_t RB_TMR_PWM_REPEAT_RB_TMR_CAP_EDGE : 2;/*!< RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer
                                                     capture edge mode: 00=disable, 01=edge change, 10=fall
                                                     to fall, 11-rise to rise                                                  */
    } bit;
  } R8_TMR2_CTRL_MOD;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, TMR2 DMA control                                                      */
    
    struct {
      __IOM uint8_t RB_TMR_DMA_ENABLE : 1;      /*!< RW, timer1_2 DMA enable                                                   */
            uint8_t             : 1;
      __IOM uint8_t RB_TMR_DMA_LOOP : 1;        /*!< RW, timer1_2 DMA address loop enable                                      */
            uint8_t             : 5;
    } bit;
  } R8_TMR2_CTRL_DMA;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, TMR2 interrupt enable                                                 */
    
    struct {
      __IOM uint8_t RB_TMR_IE_CYC_END : 1;      /*!< RW, enable interrupt for timer capture count timeout or PWM
                                                     cycle end                                                                 */
      __IOM uint8_t RB_TMR_IE_DATA_ACT : 1;     /*!< RW, enable interrupt for timer capture input action or PWM trigger        */
      __IOM uint8_t RB_TMR_IE_FIFO_HF : 1;      /*!< RW, enable interrupt for timer FIFO half (capture fifo >=4 or
                                                     PWM fifo less than 3)                                                     */
      __IOM uint8_t RB_TMR_IE_DMA_END : 1;      /*!< RW, enable interrupt for timer1/2 DMA completion                          */
      __IOM uint8_t RB_TMR_IE_FIFO_OV : 1;      /*!< RW, enable interrupt for timer FIFO overflow                              */
            uint8_t             : 3;
    } bit;
  } R8_TMR2_INTER_EN;
  __IM  uint8_t   RESERVED;
  __IM  uint16_t  RESERVED1;
  
  union {
    __IOM uint8_t reg;                          /*!< RW1, TMR2 interrupt flag                                                  */
    
    struct {
      __IOM uint8_t RB_TMR_IF_CYC_END : 1;      /*!< RW1, interrupt flag for timer capture count timeout or PWM cycle
                                                     end                                                                       */
      __IOM uint8_t RB_TMR_IF_DATA_ACT : 1;     /*!< RW1, interrupt flag for timer capture input action or PWM trigger         */
      __IOM uint8_t RB_TMR_IF_FIFO_HF : 1;      /*!< RW1, interrupt flag for timer FIFO half (capture fifo >=4 or
                                                     PWM fifo less than 3                                                      */
      __IOM uint8_t RB_TMR_IF_DMA_END : 1;      /*!< RW1, interrupt flag for timer1/2 DMA completion                           */
      __IOM uint8_t RB_TMR_IF_FIFO_OV : 1;      /*!< RW1, interrupt flag for timer FIFO overflow                               */
            uint8_t             : 3;
    } bit;
  } R8_TMR2_INT_FLAG;
  
  union {
    __IM  uint8_t reg;                          /*!< RO, TMR2 FIFO count status                                                */
    
    struct {
      __IM  uint8_t R8_TMR2_FIFO_COUNT : 4;     /*!< RW, TMR2 FIFO count status                                                */
            uint8_t             : 4;
    } bit;
  } R8_TMR2_FIFO_COUNT;
  
  union {
    __IM  uint32_t reg;                         /*!< RO, TMR2 current count                                                    */
    
    struct {
      __IM  uint32_t R32_TMR2_COUNT : 26;       /*!< RW, TMR2 current count                                                    */
            uint32_t            : 6;
    } bit;
  } R32_TMR2_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< RW, TMR2 end count value, only low 26 bit                                 */
    
    struct {
      __IOM uint32_t R32_TMR2_COUNT : 32;       /*!< RW, TMR2 current count                                                    */
    } bit;
  } R32_TMR2_CNT_END;
  
  union {
    __IOM uint32_t reg;                         /*!< RO, TMR2 FIFO register, only low 26 bit                                   */
    
    struct {
      __IOM uint32_t R32_TMR2_FIFO : 32;        /*!< RW, TMR2 current count                                                    */
    } bit;
  } R32_TMR2_FIFO;
  
  union {
    __IM  uint16_t reg;                         /*!< RO, TMR2 DMA current address                                              */
    
    struct {
            uint16_t            : 2;
      __IM  uint16_t R16_TMR2_DMA_NOW : 13;     /*!< RO, DMA data buffer current address                                       */
            uint16_t            : 1;
    } bit;
  } R16_TMR2_DMA_NOW;
  __IM  uint16_t  RESERVED2;
  
  union {
    __IOM uint16_t reg;                         /*!< RW, TMR2 DMA begin address                                                */
    
    struct {
            uint16_t            : 2;
      __IOM uint16_t R16_TMR2_DMA_BEG : 13;     /*!< RW, TMR2 DMA data buffer start address                                    */
            uint16_t            : 1;
    } bit;
  } R16_TMR2_DMA_BEG;
  __IM  uint16_t  RESERVED3;
  
  union {
    __IOM uint16_t reg;                         /*!< RW, TMR2 DMA end address                                                  */
    
    struct {
            uint16_t            : 2;
      __IOM uint16_t R16_TMR2_DMA_END : 13;     /*!< RW, TMR2 DMA end address                                                  */
            uint16_t            : 1;
    } bit;
  } R16_TMR2_DMA_END;
  __IM  uint16_t  RESERVED4;
} TMR2_Type;                                    /*!< Size = 32 (0x20)                                                          */



/* =========================================================================================================================== */
/* ================                                           TMR3                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Timer3 register (TMR3)
  */

typedef struct {                                /*!< TMR3 Structure                                                            */
  
  union {
    __IOM uint8_t reg;                          /*!< RW, TMR3 mode control                                                     */
    
    struct {
      __IOM uint8_t RB_TMR_MODE_IN : 1;         /*!< RW, timer in mode: 0=timer/PWM, 1=capture/count                           */
      __IOM uint8_t RB_TMR_ALL_CLEAR : 1;       /*!< RW, force clear timer FIFO and count                                      */
      __IOM uint8_t RB_TMR_COUNT_EN : 1;        /*!< RW, timer count enable                                                    */
      __IOM uint8_t RB_TMR_OUT_EN : 1;          /*!< RW, timer output enable                                                   */
      __IOM uint8_t RB_TMR_OUT_POLAR_RB_TMR_CAP_COUNT : 1;/*!< RW, timer PWM output polarity: 0=default low and high action,
                                                     1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1:
                                                     0=capture, 1=count                                                        */
            uint8_t             : 1;
      __IOM uint8_t RB_TMR_PWM_REPEAT_RB_TMR_CAP_EDGE : 2;/*!< RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer
                                                     capture edge mode: 00=disable, 01=edge change, 10=fall
                                                     to fall, 11-rise to rise                                                  */
    } bit;
  } R8_TMR3_CTRL_MOD;
  __IM  uint8_t   RESERVED;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, TMR3 interrupt enable                                                 */
    
    struct {
      __IOM uint8_t RB_TMR_IE_CYC_END : 1;      /*!< RW, enable interrupt for timer capture count timeout or PWM
                                                     cycle end                                                                 */
      __IOM uint8_t RB_TMR_IE_DATA_ACT : 1;     /*!< RW, enable interrupt for timer capture input action or PWM trigger        */
      __IOM uint8_t RB_TMR_IE_FIFO_HF : 1;      /*!< RW, enable interrupt for timer FIFO half (capture fifo more
                                                     than 4 or PWM fifo less than 3)                                           */
      __IOM uint8_t RB_TMR_IE_DMA_END : 1;      /*!< RW, enable interrupt for timer1/2 DMA completion                          */
      __IOM uint8_t RB_TMR_IE_FIFO_OV : 1;      /*!< RW, enable interrupt for timer FIFO overflow                              */
            uint8_t             : 3;
    } bit;
  } R8_TMR3_INTER_EN;
  __IM  uint8_t   RESERVED1;
  __IM  uint16_t  RESERVED2;
  
  union {
    __IOM uint8_t reg;                          /*!< RW1, TMR3 interrupt flag                                                  */
    
    struct {
      __IOM uint8_t RB_TMR_IF_CYC_END : 1;      /*!< RW1, interrupt flag for timer capture count timeout or PWM cycle
                                                     end                                                                       */
      __IOM uint8_t RB_TMR_IF_DATA_ACT : 1;     /*!< RW1, interrupt flag for timer capture input action or PWM trigger         */
      __IOM uint8_t RB_TMR_IF_FIFO_HF : 1;      /*!< RW1, interrupt flag for timer FIFO half (capture fifo more than
                                                     4 or PWM fifo less than 3)                                                */
      __IOM uint8_t RB_TMR_IF_DMA_END : 1;      /*!< RW1, interrupt flag for timer1/2 DMA completion                           */
      __IOM uint8_t RB_TMR_IF_FIFO_OV : 1;      /*!< RW1, interrupt flag for timer FIFO overflow                               */
            uint8_t             : 3;
    } bit;
  } R8_TMR3_INT_FLAG;
  
  union {
    __IM  uint8_t reg;                          /*!< RO, TMR3 FIFO count status                                                */
    
    struct {
      __IM  uint8_t R8_TMR3_FIFO_COUNT : 4;     /*!< RO, TMR3 FIFO count status                                                */
            uint8_t             : 4;
    } bit;
  } R8_TMR3_FIFO_COUNT;
  
  union {
    __IM  uint32_t reg;                         /*!< RO, TMR3 current count                                                    */
    
    struct {
      __IM  uint32_t R32_TMR3_COUNT : 26;       /*!< RO, TMR3 current count                                                    */
            uint32_t            : 6;
    } bit;
  } R32_TMR3_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< RW, TMR3 end count value, only low 26 bit                                 */
    
    struct {
      __IOM uint32_t R32_TMR3_CNT_END : 32;     /*!< RW, TMR3 end count value, only low 26 bit                                 */
    } bit;
  } R32_TMR3_CNT_END;
  
  union {
    __IOM uint32_t reg;                         /*!< RO/WO, TMR3 FIFO register, only low 26 bit                                */
    
    struct {
      __IOM uint32_t R32_TMR3_FIFO : 32;        /*!< RO/WO, TMR3 FIFO register, only low 26 bit                                */
    } bit;
  } R32_TMR3_FIFO;
} TMR3_Type;                                    /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                           UART0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief UART0 register (UART0)
  */

typedef struct {                                /*!< UART0 Structure                                                           */
  
  union {
    __IOM uint8_t reg;                          /*!< RW, UART0 modem control                                                   */
    
    struct {
      __IOM uint8_t RB_MCR_DTR  : 1;            /*!< RW, UART0 control DTR                                                     */
      __IOM uint8_t RB_MCR_RTS  : 1;            /*!< RW, UART0 control RTS                                                     */
      __IOM uint8_t RB_MCR_OUT1 : 1;            /*!< RW, UART0 control OUT1                                                    */
      __IOM uint8_t RB_MCR_OUT2_RB_MCR_INT_OE : 1;/*!< RW, UART control OUT2/ UART interrupt output enable                     */
      __IOM uint8_t RB_MCR_LOOP : 1;            /*!< RW, UART0 enable local loop back                                          */
      __IOM uint8_t RB_MCR_AU_FLOW_EN : 1;      /*!< RW, UART0 enable autoflow control                                         */
      __IOM uint8_t RB_MCR_TNOW : 1;            /*!< RW, UART0 enable TNOW output on DTR pin                                   */
      __IOM uint8_t RB_MCR_HALF : 1;            /*!< RW, UART0 enable half-duplex                                              */
    } bit;
  } R8_UART0_MCR;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, UART0 interrupt enable                                                */
    
    struct {
      __IOM uint8_t RB_IER_RECV_RDY : 1;        /*!< RW, UART interrupt enable for receiver data ready                         */
      __IOM uint8_t RB_IER_THR_EMPTY : 1;       /*!< RW, UART interrupt enable for THR empty                                   */
      __IOM uint8_t RB_IER_LINE_STAT : 1;       /*!< RW, UART interrupt enable for receiver line status                        */
      __IOM uint8_t RB_IER_MODEM_CHG : 1;       /*!< RW, UART0 interrupt enable for modem status change                        */
      __IOM uint8_t RB_IER_DTR_EN : 1;          /*!< RW, UART0 DTR/TNOW output pin enable                                      */
      __IOM uint8_t RB_IER_RTS_EN : 1;          /*!< RW, UART0 RTS output pin enable                                           */
      __IOM uint8_t RB_IER_TXD_EN : 1;          /*!< RW, UART TXD pin enable                                                   */
      __IOM uint8_t RB_IER_RESET : 1;           /*!< WZ, UART software reset control, high action, auto clear                  */
    } bit;
  } R8_UART0_IER;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, UART0 FIFO control                                                    */
    
    struct {
      __IOM uint8_t RB_FCR_FIFO_EN : 1;         /*!< RW, UART FIFO enable                                                      */
      __IOM uint8_t RB_FCR_RX_FIFO_CLR : 1;     /*!< WZ, clear UART receiver FIFO, high action, auto clear                     */
      __IOM uint8_t RB_FCR_TX_FIFO_CLR : 1;     /*!< WZ, clear UART transmitter FIFO, high action, auto clear                  */
            uint8_t             : 3;
      __IOM uint8_t RB_FCR_FIFO_TRIG : 2;       /*!< RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes,
                                                     11-7bytes                                                                 */
    } bit;
  } R8_UART0_FCR;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, UART0 line control                                                    */
    
    struct {
      __IOM uint8_t RB_LCR_WORD_SZ : 2;         /*!< RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit              */
      __IOM uint8_t RB_LCR_STOP_BIT : 1;        /*!< RW, UART stop bit length: 0-1bit, 1-2bit                                  */
      __IOM uint8_t RB_LCR_PAR_EN : 1;          /*!< RW, UART parity enable                                                    */
      __IOM uint8_t RB_LCR_PAR_MOD : 2;         /*!< RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space                  */
      __IOM uint8_t RB_LCR_BREAK_EN : 1;        /*!< RW, UART break control enable                                             */
      __IOM uint8_t RB_LCR_GP_BIT_RB_LCR_DLAB : 1;/*!< RW, UART general purpose bit;RW, UART reserved bit                      */
    } bit;
  } R8_UART0_LCR;
  
  union {
    __IM  uint8_t reg;                          /*!< RO, UART0 interrupt identification                                        */
    
    struct {
      __IM  uint8_t RB_IIR_NO_INT : 1;          /*!< RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt            */
      __IM  uint8_t RB_IIR_INT_MASK : 3;        /*!< RO, UART interrupt flag bit mask                                          */
            uint8_t             : 2;
      __IM  uint8_t RB_IIR_FIFO_ID : 2;         /*!< RO, UART FIFO enabled flag                                                */
    } bit;
  } R8_UART0_IIR;
  
  union {
    __IM  uint8_t reg;                          /*!< RO, UART0 line status                                                     */
    
    struct {
      __IM  uint8_t RB_LSR_DATA_RDY : 1;        /*!< RO, UART receiver fifo data ready status                                  */
      __IM  uint8_t RB_LSR_OVER_ERR : 1;        /*!< RZ, UART receiver overrun error                                           */
      __IM  uint8_t RB_LSR_PAR_ERR : 1;         /*!< RZ, UART receiver parity error                                            */
      __IM  uint8_t RB_LSR_FRAME_ERR : 1;       /*!< RZ, UART receiver frame error                                             */
      __IM  uint8_t RB_LSR_BREAK_ERR : 1;       /*!< RZ, UART receiver break error                                             */
      __IM  uint8_t RB_LSR_TX_FIFO_EMP : 1;     /*!< RO, UART transmitter fifo empty status                                    */
      __IM  uint8_t RB_LSR_TX_ALL_EMP : 1;      /*!< RO, UART transmitter all empty status                                     */
      __IM  uint8_t RB_LSR_ERR_RX_FIFO : 1;     /*!< RO, indicate error in UART receiver fifo                                  */
    } bit;
  } R8_UART0_LSR;
  
  union {
    __IM  uint8_t reg;                          /*!< RO, UART0 modem status                                                    */
    
    struct {
      __IM  uint8_t RB_MSR_CTS_CHG : 1;         /*!< RZ, UART0 CTS changed status, high action                                 */
      __IM  uint8_t RB_MSR_DSR_CHG : 1;         /*!< RZ, UART0 DSR changed status, high action                                 */
      __IM  uint8_t RB_MSR_RI_CHG : 1;          /*!< RZ, UART0 RI changed status, high action                                  */
      __IM  uint8_t RB_MSR_DCD_CHG : 1;         /*!< RZ, UART0 DCD changed status, high action                                 */
      __IM  uint8_t RB_MSR_CTS  : 1;            /*!< RO, UART0 CTS action status                                               */
      __IM  uint8_t RB_MSR_DSR  : 1;            /*!< RO, UART0 DSR action statusv                                              */
      __IM  uint8_t RB_MSR_RI   : 1;            /*!< RO, UART0 RI action status                                                */
      __IM  uint8_t RB_MSR_DCD  : 1;            /*!< RO, UART0 DCD action status                                               */
    } bit;
  } R8_UART0_MSR;
  __IM  uint8_t   RESERVED;
  
  union {
    union {
      __IM  uint8_t reg;                        /*!< RO, UART0 receiver buffer, receiving byte                                 */
      
      struct {
        __IM  uint8_t R8_UART0_RBR : 8;         /*!< RO, UART0 receiver buffer, receiving byte                                 */
      } bit;
    } R8_UART0_RBR;
    
    union {
      __OM  uint8_t reg;                        /*!< WO, UART0 transmitter holding, transmittal byte                           */
      
      struct {
        __OM  uint8_t R8_UART0_THR : 8;         /*!< RO, UART0 transmitter holding, transmittal byte                           */
      } bit;
    } R8_UART0_THR;
  };
  __IM  uint8_t   RESERVED1;
  
  union {
    __IM  uint8_t reg;                          /*!< RO, UART0 receiver FIFO count                                             */
    
    struct {
      __IM  uint8_t R8_UART0_RFC : 8;           /*!< RO, UART0 receiver FIFO count                                             */
    } bit;
  } R8_UART0_RFC;
  
  union {
    __IM  uint8_t reg;                          /*!< RO, UART0 transmitter FIFO count                                          */
    
    struct {
      __IM  uint8_t R8_UART0_TFC : 8;           /*!< RO, UART0 transmitter FIFO count                                          */
    } bit;
  } R8_UART0_TFC;
  
  union {
    __IOM uint16_t reg;                         /*!< RW, UART0 divisor latch                                                   */
    
    struct {
      __IOM uint16_t R16_UART0_DL : 16;         /*!< RW, UART0 divisor latch                                                   */
    } bit;
  } R16_UART0_DL;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, UART0 pre-divisor latch byte, only low 7 bit, from 1 to
                                                     0/128                                                                     */
    
    struct {
      __IOM uint8_t R8_UART0_DIV : 8;           /*!< RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128          */
    } bit;
  } R8_UART0_DIV;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, UART0 slave address: 0xFF=disable, other=enable                       */
    
    struct {
      __IOM uint8_t R8_UART0_ADR : 8;           /*!< RW,UART0 slave address: 0xFF=disable, other=enable                        */
    } bit;
  } R8_UART0_ADR;
} UART0_Type;                                   /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                           UART1                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief UART1 register (UART1)
  */

typedef struct {                                /*!< UART1 Structure                                                           */
  
  union {
    __IOM uint8_t reg;                          /*!< RW, UART1 modem control                                                   */
    
    struct {
            uint8_t             : 3;
      __IOM uint8_t RB_MCR_OUT2_RB_MCR_INT_OE : 1;/*!< RW, UART control OUT2/UART interrupt output enable                      */
            uint8_t             : 4;
    } bit;
  } R8_UART1_MCR;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, UART1 interrupt enable                                                */
    
    struct {
      __IOM uint8_t RB_IER_RECV_RDY : 1;        /*!< RW, UART interrupt enable for receiver data ready                         */
      __IOM uint8_t RB_IER_THR_EMPTY : 1;       /*!< RW, UART interrupt enable for THR empty                                   */
      __IOM uint8_t RB_IER_LINE_STAT : 1;       /*!< RW, UART interrupt enable for receiver line status                        */
            uint8_t             : 3;
      __IOM uint8_t RB_IER_TXD_EN : 1;          /*!< RW, UART TXD pin enable                                                   */
      __IOM uint8_t RB_IER_RESET : 1;           /*!< WZ, UART software reset control, high action, auto clear                  */
    } bit;
  } R8_UART1_IER;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, UART1 FIFO control                                                    */
    
    struct {
      __IOM uint8_t RB_FCR_FIFO_EN : 1;         /*!< RW, UART FIFO enable                                                      */
      __IOM uint8_t RB_FCR_RX_FIFO_CLR : 1;     /*!< WZ, clear UART receiver FIFO, high action, auto clear                     */
      __IOM uint8_t RB_FCR_TX_FIFO_CLR : 1;     /*!< WZ, clear UART transmitter FIFO, high action, auto clear                  */
            uint8_t             : 3;
      __IOM uint8_t RB_FCR_FIFO_TRIG : 2;       /*!< RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes,
                                                     11-7bytes                                                                 */
    } bit;
  } R8_UART1_FCR;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, UART1 line control                                                    */
    
    struct {
      __IOM uint8_t RB_LCR_WORD_SZ : 2;         /*!< RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit              */
      __IOM uint8_t RB_LCR_STOP_BIT : 1;        /*!< RW, UART stop bit length: 0-1bit, 1-2bit                                  */
      __IOM uint8_t RB_LCR_PAR_EN : 1;          /*!< RW, UART parity enable                                                    */
      __IOM uint8_t RB_LCR_PAR_MOD : 2;         /*!< RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space                  */
      __IOM uint8_t RB_LCR_BREAK_EN : 1;        /*!< RW, UART break control enable                                             */
      __IOM uint8_t RB_LCR_GP_BIT_RB_LCR_DLAB : 1;/*!< RW, UART general purpose bit;RW, UART reserved bit                      */
    } bit;
  } R8_UART1_LCR;
  
  union {
    __IM  uint8_t reg;                          /*!< RO, UART1 interrupt identification                                        */
    
    struct {
      __IM  uint8_t RB_IIR_NO_INT : 1;          /*!< RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt            */
      __IM  uint8_t RB_IIR_INT_MASK : 3;        /*!< RO, UART interrupt flag bit mask                                          */
            uint8_t             : 2;
      __IM  uint8_t RB_IIR_FIFO_ID : 2;         /*!< RO, UART FIFO enabled flag                                                */
    } bit;
  } R8_UART1_IIR;
  
  union {
    __IM  uint8_t reg;                          /*!< RO, UART1 line status                                                     */
    
    struct {
      __IM  uint8_t RB_LSR_DATA_RDY : 1;        /*!< RO, UART receiver fifo data ready status                                  */
      __IM  uint8_t RB_LSR_OVER_ERR : 1;        /*!< RZ, UART receiver overrun error                                           */
      __IM  uint8_t RB_LSR_PAR_ERR : 1;         /*!< RZ, UART receiver parity error                                            */
      __IM  uint8_t RB_LSR_FRAME_ERR : 1;       /*!< RZ, UART receiver frame error                                             */
      __IM  uint8_t RB_LSR_BREAK_ERR : 1;       /*!< RZ, UART receiver break error                                             */
      __IM  uint8_t RB_LSR_TX_FIFO_EMP : 1;     /*!< RO, UART transmitter fifo empty status                                    */
      __IM  uint8_t RB_LSR_TX_ALL_EMP : 1;      /*!< RO, UART transmitter all empty status                                     */
      __IM  uint8_t RB_LSR_ERR_RX_FIFO : 1;     /*!< RO, indicate error in UART receiver fifo                                  */
    } bit;
  } R8_UART1_LSR;
  __IM  uint16_t  RESERVED;
  
  union {
    union {
      __IM  uint8_t reg;                        /*!< RO, UART1 receiver buffer, receiving byte                                 */
      
      struct {
        __IM  uint8_t R8_UART1_RBR : 8;         /*!< RO, UART1 receiver buffer, receiving byte                                 */
      } bit;
    } R8_UART1_RBR;
    
    union {
      __OM  uint8_t reg;                        /*!< WO, UART1 transmitter holding, transmittal byte                           */
      
      struct {
        __OM  uint8_t R8_UART1_RBR : 8;         /*!< WO, UART1 transmitter holding, transmittal byte                           */
      } bit;
    } R8_UART1_THR;
  };
  __IM  uint8_t   RESERVED1;
  
  union {
    __IM  uint8_t reg;                          /*!< RO, UART1 receiver FIFO count                                             */
    
    struct {
      __IM  uint8_t R8_UART1_RFC : 8;           /*!< RO, UART1 receiver FIFO count                                             */
    } bit;
  } R8_UART1_RFC;
  
  union {
    __IM  uint8_t reg;                          /*!< RO, UART1 transmitter FIFO count                                          */
    
    struct {
      __IM  uint8_t R8_UART1_TFC : 8;           /*!< RO, UART1 receiver FIFO count                                             */
    } bit;
  } R8_UART1_TFC;
  
  union {
    __IOM uint16_t reg;                         /*!< RW, UART1 divisor latch                                                   */
    
    struct {
      __IOM uint16_t R16_UART1_DL : 16;         /*!< RW, UART1 divisor latch                                                   */
    } bit;
  } R16_UART1_DL;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to
                                                     128                                                                       */
    
    struct {
      __IOM uint8_t R8_UART1_DIV : 8;           /*!< RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to
                                                     128                                                                       */
    } bit;
  } R8_UART1_DIV;
  __IM  uint8_t   RESERVED2;
  __IM  uint16_t  RESERVED3;
} UART1_Type;                                   /*!< Size = 18 (0x12)                                                          */



/* =========================================================================================================================== */
/* ================                                           UART2                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief UART2 register (UART2)
  */

typedef struct {                                /*!< UART2 Structure                                                           */
  
  union {
    __IOM uint8_t reg;                          /*!< RW, UART2 modem control                                                   */
    
    struct {
            uint8_t             : 3;
      __IOM uint8_t RB_MCR_OUT2_RB_MCR_INT_OE : 1;/*!< RW, UART control OUT2;UART interrupt output enable                      */
            uint8_t             : 4;
    } bit;
  } R8_UART2_MCR;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, UART2 interrupt enable                                                */
    
    struct {
      __IOM uint8_t RB_IER_RECV_RDY : 1;        /*!< RW, UART interrupt enable for receiver data ready                         */
      __IOM uint8_t RB_IER_THR_EMPTY : 1;       /*!< RW, UART interrupt enable for THR empty                                   */
      __IOM uint8_t RB_IER_LINE_STAT : 1;       /*!< RW, UART interrupt enable for receiver line status                        */
            uint8_t             : 3;
      __IOM uint8_t RB_IER_TXD_EN : 1;          /*!< RW, UART TXD pin enable                                                   */
      __IOM uint8_t RB_IER_RESET : 1;           /*!< WZ, UART software reset control, high action, auto clear                  */
    } bit;
  } R8_UART2_IER;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, UART2 FIFO control                                                    */
    
    struct {
      __IOM uint8_t RB_FCR_FIFO_EN : 1;         /*!< RW, UART FIFO enable                                                      */
      __IOM uint8_t RB_FCR_RX_FIFO_CLR : 1;     /*!< WZ, clear UART receiver FIFO, high action, auto clear                     */
      __IOM uint8_t RB_FCR_TX_FIFO_CLR : 1;     /*!< WZ, clear UART transmitter FIFO, high action, auto clear                  */
            uint8_t             : 3;
      __IOM uint8_t RB_FCR_FIFO_TRIG : 2;       /*!< RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes,
                                                     11-7bytes                                                                 */
    } bit;
  } R8_UART2_FCR;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, UART2 line control                                                    */
    
    struct {
      __IOM uint8_t RB_LCR_WORD_SZ : 2;         /*!< RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit              */
      __IOM uint8_t RB_LCR_STOP_BIT : 1;        /*!< RW, UART stop bit length: 0-1bit, 1-2bit                                  */
      __IOM uint8_t RB_LCR_PAR_EN : 1;          /*!< RW, UART parity enable                                                    */
      __IOM uint8_t RB_LCR_PAR_MOD : 2;         /*!< RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space                  */
      __IOM uint8_t RB_LCR_BREAK_EN : 1;        /*!< RW, UART break control enable                                             */
      __IOM uint8_t RB_LCR_GP_BIT_RB_LCR_DLAB : 1;/*!< RW, UART general purpose bit;RW, UART reserved bit                      */
    } bit;
  } R8_UART2_LCR;
  
  union {
    __IM  uint8_t reg;                          /*!< RO, UART2 interrupt identification                                        */
    
    struct {
      __IM  uint8_t RB_IIR_NO_INT : 1;          /*!< RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt            */
      __IM  uint8_t RB_IIR_INT_MASK : 3;        /*!< RO, UART interrupt flag bit mask                                          */
            uint8_t             : 2;
      __IM  uint8_t RB_IIR_FIFO_ID : 2;         /*!< RO, UART FIFO enabled flag                                                */
    } bit;
  } R8_UART2_IIR;
  
  union {
    __IM  uint8_t reg;                          /*!< RO, UART2 line status                                                     */
    
    struct {
      __IM  uint8_t RB_LSR_DATA_RDY : 1;        /*!< RO, UART receiver fifo data ready status                                  */
      __IM  uint8_t RB_LSR_OVER_ERR : 1;        /*!< RZ, UART receiver overrun error                                           */
      __IM  uint8_t RB_LSR_PAR_ERR : 1;         /*!< RZ, UART receiver parity error                                            */
      __IM  uint8_t RB_LSR_FRAME_ERR : 1;       /*!< RZ, UART receiver frame error                                             */
      __IM  uint8_t RB_LSR_BREAK_ERR : 1;       /*!< RZ, UART receiver break error                                             */
      __IM  uint8_t RB_LSR_TX_FIFO_EMP : 1;     /*!< RO, UART transmitter fifo empty status                                    */
      __IM  uint8_t RB_LSR_TX_ALL_EMP : 1;      /*!< RO, UART transmitter all empty status                                     */
      __IM  uint8_t RB_LSR_ERR_RX_FIFO : 1;     /*!< RO, indicate error in UART receiver fifo                                  */
    } bit;
  } R8_UART2_LSR;
  __IM  uint16_t  RESERVED;
  
  union {
    union {
      __IM  uint8_t reg;                        /*!< RO, UART2 receiver buffer, receiving byte                                 */
      
      struct {
        __IM  uint8_t R8_UART2_RBR : 8;         /*!< RO, UART2 receiver buffer, receiving byte                                 */
      } bit;
    } R8_UART2_RBR;
    
    union {
      __OM  uint8_t reg;                        /*!< WO, UART2 transmitter holding, transmittal byte                           */
      
      struct {
        __OM  uint8_t R8_UART2_THR : 8;         /*!< WO, UART2 transmitter holding, transmittal byte                           */
      } bit;
    } R8_UART2_THR;
  };
  __IM  uint8_t   RESERVED1;
  
  union {
    __IM  uint8_t reg;                          /*!< RO, UART2 receiver FIFO count                                             */
    
    struct {
      __IM  uint8_t R8_UART2_RFC : 8;           /*!< RO, UART2 receiver FIFO count                                             */
    } bit;
  } R8_UART2_RFC;
  
  union {
    __IM  uint8_t reg;                          /*!< RO, UART2 transmitter FIFO count                                          */
    
    struct {
      __IM  uint8_t R8_UART2_TFC : 8;           /*!< RO, UART2 transmitter FIFO count                                          */
    } bit;
  } R8_UART2_TFC;
  
  union {
    __IOM uint16_t reg;                         /*!< RW, UART2 divisor latch                                                   */
    
    struct {
      __IOM uint16_t R16_UART2_DL : 16;         /*!< RW, UART2 divisor latch                                                   */
    } bit;
  } R16_UART2_DL;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to
                                                     128                                                                       */
    
    struct {
      __IOM uint8_t R8_UART2_DIV : 8;           /*!< RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to
                                                     128                                                                       */
    } bit;
  } R8_UART2_DIV;
  __IM  uint8_t   RESERVED2;
  __IM  uint16_t  RESERVED3;
} UART2_Type;                                   /*!< Size = 18 (0x12)                                                          */



/* =========================================================================================================================== */
/* ================                                           UART3                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief UART3 register (UART3)
  */

typedef struct {                                /*!< UART3 Structure                                                           */
  
  union {
    __IOM uint8_t reg;                          /*!< RW, UART3 modem control                                                   */
    
    struct {
            uint8_t             : 3;
      __IOM uint8_t RB_MCR_OUT2_RB_MCR_INT_OE : 1;/*!< RW, UART control OUT2;UART interrupt output enable                      */
            uint8_t             : 4;
    } bit;
  } R8_UART3_MCR;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, UART3 interrupt enable                                                */
    
    struct {
      __IOM uint8_t RB_IER_RECV_RDY : 1;        /*!< RW, UART interrupt enable for receiver data ready                         */
      __IOM uint8_t RB_IER_THR_EMPTY : 1;       /*!< RW, UART interrupt enable for THR empty                                   */
      __IOM uint8_t RB_IER_LINE_STAT : 1;       /*!< RW, UART interrupt enable for receiver line status                        */
            uint8_t             : 3;
      __IOM uint8_t RB_IER_TXD_EN : 1;          /*!< RW, UART TXD pin enable                                                   */
      __IOM uint8_t RB_IER_RESET : 1;           /*!< WZ, UART software reset control, high action, auto clear                  */
    } bit;
  } R8_UART3_IER;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, UART3 FIFO control                                                    */
    
    struct {
      __IOM uint8_t RB_FCR_FIFO_EN : 1;         /*!< RW, UART FIFO enable                                                      */
      __IOM uint8_t RB_FCR_RX_FIFO_CLR : 1;     /*!< WZ, clear UART receiver FIFO, high action, auto clear                     */
      __IOM uint8_t RB_FCR_TX_FIFO_CLR : 1;     /*!< WZ, clear UART transmitter FIFO, high action, auto clear                  */
            uint8_t             : 3;
      __IOM uint8_t RB_FCR_FIFO_TRIG : 2;       /*!< RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes,
                                                     11-7bytes                                                                 */
    } bit;
  } R8_UART3_FCR;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, UART3 line control                                                    */
    
    struct {
      __IOM uint8_t RB_LCR_WORD_SZ : 2;         /*!< RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit              */
      __IOM uint8_t RB_LCR_STOP_BIT : 1;        /*!< RW, UART stop bit length: 0-1bit, 1-2bit                                  */
      __IOM uint8_t RB_LCR_PAR_EN : 1;          /*!< RW, UART parity enable                                                    */
      __IOM uint8_t RB_LCR_PAR_MOD : 2;         /*!< RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space                  */
      __IOM uint8_t RB_LCR_BREAK_EN : 1;        /*!< RW, UART break control enable                                             */
      __IOM uint8_t RB_LCR_GP_BIT_RB_LCR_DLAB : 1;/*!< RW, UART general purpose bit;RW, UART reserved bit                      */
    } bit;
  } R8_UART3_LCR;
  
  union {
    __IM  uint8_t reg;                          /*!< RO, UART3 interrupt identification                                        */
    
    struct {
      __IM  uint8_t RB_IIR_NO_INT : 1;          /*!< RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt            */
      __IM  uint8_t RB_IIR_INT_MASK : 3;        /*!< RO, UART interrupt flag bit mask                                          */
            uint8_t             : 2;
      __IM  uint8_t RB_IIR_FIFO_ID : 2;         /*!< RO, UART FIFO enabled flag                                                */
    } bit;
  } R8_UART3_IIR;
  
  union {
    __IM  uint8_t reg;                          /*!< RO, UART3 line status                                                     */
    
    struct {
      __IM  uint8_t RB_LSR_DATA_RDY : 1;        /*!< RO, UART receiver fifo data ready status                                  */
      __IM  uint8_t RB_LSR_OVER_ERR : 1;        /*!< RZ, UART receiver overrun error                                           */
      __IM  uint8_t RB_LSR_PAR_ERR : 1;         /*!< RZ, UART receiver parity error                                            */
      __IM  uint8_t RB_LSR_FRAME_ERR : 1;       /*!< RZ, UART receiver frame error                                             */
      __IM  uint8_t RB_LSR_BREAK_ERR : 1;       /*!< RZ, UART receiver break error                                             */
      __IM  uint8_t RB_LSR_TX_FIFO_EMP : 1;     /*!< RO, UART transmitter fifo empty status                                    */
      __IM  uint8_t RB_LSR_TX_ALL_EMP : 1;      /*!< RO, UART transmitter all empty status                                     */
      __IM  uint8_t RB_LSR_ERR_RX_FIFO : 1;     /*!< RO, indicate error in UART receiver fifo                                  */
    } bit;
  } R8_UART3_LSR;
  __IM  uint16_t  RESERVED;
  
  union {
    union {
      __IM  uint8_t reg;                        /*!< RO, UART3 receiver buffer, receiving byte                                 */
      
      struct {
        __IM  uint8_t R8_UART3_RBR : 8;         /*!< RO, UART3 receiver buffer, receiving byte                                 */
      } bit;
    } R8_UART3_RBR;
    
    union {
      __OM  uint8_t reg;                        /*!< WO, UART3 transmitter holding, transmittal byte                           */
      
      struct {
        __OM  uint8_t R8_UART3_THR : 8;         /*!< WO, UART3 transmitter holding, transmittal byte                           */
      } bit;
    } R8_UART3_THR;
  };
  __IM  uint8_t   RESERVED1;
  
  union {
    __IM  uint8_t reg;                          /*!< RO, UART3 receiver FIFO count                                             */
    
    struct {
      __IM  uint8_t R8_UART3_RFC : 8;           /*!< RO, UART3 receiver FIFO count                                             */
    } bit;
  } R8_UART3_RFC;
  
  union {
    __IM  uint8_t reg;                          /*!< RO, UART3 transmitter FIFO count                                          */
    
    struct {
      __IM  uint8_t R8_UART3_TFC : 8;           /*!< RO, UART3 transmitter FIFO count                                          */
    } bit;
  } R8_UART3_TFC;
  
  union {
    __IOM uint16_t reg;                         /*!< RW, UART3 divisor latch                                                   */
    
    struct {
      __IOM uint16_t R16_UART3_DL : 16;         /*!< RW, UART3 divisor latch                                                   */
    } bit;
  } R16_UART3_DL;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to
                                                     128                                                                       */
    
    struct {
      __IOM uint8_t R8_UART3_DIV : 8;           /*!< RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to
                                                     128                                                                       */
    } bit;
  } R8_UART3_DIV;
  __IM  uint8_t   RESERVED2;
  __IM  uint16_t  RESERVED3;
} UART3_Type;                                   /*!< Size = 18 (0x12)                                                          */



/* =========================================================================================================================== */
/* ================                                           SPI0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief SPI0 register (SPI0)
  */

typedef struct {                                /*!< SPI0 Structure                                                            */
  
  union {
    __IOM uint8_t reg;                          /*!< RW, SPI0 mode control                                                     */
    
    struct {
      __IOM uint8_t RB_SPI_MODE_SLAVE : 1;      /*!< RW, SPI0 slave mode: 0=master or host, 1=slave or device                  */
      __IOM uint8_t RB_SPI_ALL_CLEAR : 1;       /*!< RW, force clear SPI FIFO and count                                        */
      __IOM uint8_t RB_SPI_2WIRE_MOD : 1;       /*!< RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO),
                                                     1=2wire(SCK0,MISO=MXSX)                                                   */
      __IOM uint8_t RB_SPI_MST_SCK_MOD_RB_SPI_SLV_CMD_MOD : 1;/*!< RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave
                                                     command mode: 0=byte stream, 1=first byte command                         */
      __IOM uint8_t RB_SPI_FIFO_DIR : 1;        /*!< RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read
                                                     @master mode)                                                             */
      __IOM uint8_t RB_SPI_SCK_OE : 1;          /*!< RW, SPI SCK output enable                                                 */
      __IOM uint8_t RB_SPI_MOSI_OE : 1;         /*!< RW, SPI MOSI output enable                                                */
      __IOM uint8_t RB_SPI_MISO_OE : 1;         /*!< RW, SPI MISO output enable                                                */
    } bit;
  } R8_SPI0_CTRL_MOD;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, SPI0 configuration control                                            */
    
    struct {
      __IOM uint8_t RB_SPI_DMA_ENABLE : 1;      /*!< RW, SPI0 DMA enable                                                       */
            uint8_t             : 1;
      __IOM uint8_t RB_SPI_DMA_LOOP : 1;        /*!< RW, SPI0 DMA address loop enable                                          */
            uint8_t             : 1;
      __IOM uint8_t RB_SPI_AUTO_IF : 1;         /*!< RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END
                                                     interrupt flag                                                            */
      __IOM uint8_t RB_SPI_BIT_ORDER : 1;       /*!< RW, SPI bit data order: 0=MSB first, 1=LSB first                          */
      __IOM uint8_t RB_SPI_MST_DLY_EN : 1;      /*!< RW, SPI master input delay enable                                         */
            uint8_t             : 1;
    } bit;
  } R8_SPI0_CTRL_CFG;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, SPI0 interrupt enable                                                 */
    
    struct {
      __IOM uint8_t RB_SPI_IE_CNT_END : 1;      /*!< RW, enable interrupt for SPI total byte count end                         */
      __IOM uint8_t RB_SPI_IE_BYTE_END : 1;     /*!< RW, enable interrupt for SPI byte exchanged                               */
      __IOM uint8_t RB_SPI_IE_FIFO_HF : 1;      /*!< RW, enable interrupt for SPI FIFO half                                    */
      __IOM uint8_t RB_SPI_IE_DMA_END : 1;      /*!< RW, enable interrupt for SPI0 DMA completion                              */
      __IOM uint8_t RB_SPI_IE_FIFO_OV : 1;      /*!< RW, enable interrupt for SPI0 FIFO overflow                               */
            uint8_t             : 2;
      __IOM uint8_t RB_SPI_IE_FST_BYTE : 1;     /*!< RW, enable interrupt for SPI0 slave mode first byte received              */
    } bit;
  } R8_SPI0_INTER_EN;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, SPI0 master clock divisor;RW, SPI0 slave preset value                 */
    
    struct {
      __IOM uint8_t R8_SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE : 8;/*!< RW, SPI0 master clock divisor;RW, SPI0 slave preset value     */
    } bit;
  } R8_SPI0_CLOCK_DIV_R8_SPI0_SLAVE_PRE;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, SPI0 data buffer                                                      */
    
    struct {
      __IOM uint8_t R8_SPI0_BUFFER : 8;         /*!< RW, SPI0 data buffer                                                      */
    } bit;
  } R8_SPI0_BUFFER;
  
  union {
    __IM  uint8_t reg;                          /*!< RO, SPI0 work flag                                                        */
    
    struct {
            uint8_t             : 4;
      __IM  uint8_t RB_SPI_SLV_CMD_ACT : 1;     /*!< RO, SPI0 slave first byte or command flag                                 */
      __IM  uint8_t RB_SPI_FIFO_READY : 1;      /*!< RO, SPI FIFO ready status                                                 */
      __IM  uint8_t RB_SPI_SLV_CS_LOAD : 1;     /*!< RO, SPI0 slave chip-select loading status                                 */
      __IM  uint8_t RB_SPI_SLV_SELECT : 1;      /*!< RO, SPI0 slave selection status                                           */
    } bit;
  } R8_SPI0_RUN_FLAG;
  
  union {
    __IOM uint8_t reg;                          /*!< RW1, SPI0 interrupt flag                                                  */
    
    struct {
      __IOM uint8_t RB_SPI_IF_CNT_END : 1;      /*!< RW1, interrupt flag for SPI total byte count end                          */
      __IOM uint8_t RB_SPI_IF_BYTE_END : 1;     /*!< RW1, interrupt flag for SPI byte exchanged                                */
      __IOM uint8_t RB_SPI_IF_FIFO_HF : 1;      /*!< RW1, interrupt flag for SPI FIFO half                                     */
      __IOM uint8_t RB_SPI_IF_DMA_END : 1;      /*!< RW1, interrupt flag for SPI0 DMA completion                               */
      __IOM uint8_t RB_SPI_IF_FIFO_OV : 1;      /*!< RW1, interrupt flag for SPI0 FIFO overflow                                */
            uint8_t             : 1;
      __IOM uint8_t RB_SPI_FREE : 1;            /*!< RO, current SPI free status                                               */
      __IOM uint8_t RB_SPI_IF_FST_BYTE : 1;     /*!< RW1, interrupt flag for SPI0 slave mode first byte received               */
    } bit;
  } R8_SPI0_INT_FLAG;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, SPI0 FIFO count status                                                */
    
    struct {
      __IOM uint8_t R8_SPI0_FIFO_COUNT : 4;     /*!< RW, SPI0 FIFO count status                                                */
            uint8_t             : 4;
    } bit;
  } R8_SPI0_FIFO_COUNT;
  __IM  uint16_t  RESERVED[2];
  
  union {
    __IOM uint16_t reg;                         /*!< RW, SPI0 total byte count, only low 12 bit                                */
    
    struct {
      __IOM uint16_t R16_SPI0_TOTAL_CNT : 16;   /*!< RW, SPI0 total byte count, only low 12 bit                                */
    } bit;
  } R16_SPI0_TOTAL_CNT;
  __IM  uint16_t  RESERVED1;
  
  union {
    __IOM uint8_t reg;                          /*!< RO/WO, SPI0 FIFO register                                                 */
    
    struct {
      __IOM uint8_t R8_SPI0_FIFO : 8;           /*!< RO/WO, SPI0 FIFO register                                                 */
    } bit;
  } R8_SPI0_FIFO;
  __IM  uint8_t   RESERVED2[2];
  
  union {
    __IM  uint8_t reg;                          /*!< RO, SPI0 FIFO count status                                                */
    
    struct {
      __IM  uint8_t R8_SPI0_FIFO_COUNT1 : 8;    /*!< RO, SPI0 FIFO count status                                                */
    } bit;
  } R8_SPI0_FIFO_COUNT1;
  
  union {
    __IOM uint16_t reg;                         /*!< RW, SPI0 DMA current address                                              */
    
    struct {
      __IOM uint16_t R16_SPI0_DMA_NOW : 16;     /*!< RW, SPI0 DMA current address                                              */
    } bit;
  } R16_SPI0_DMA_NOW;
  __IM  uint16_t  RESERVED3;
  
  union {
    __IOM uint16_t reg;                         /*!< RW, SPI0 DMA begin address                                                */
    
    struct {
      __IOM uint16_t R16_SPI0_DMA_BEG : 16;     /*!< RW, SPI0 DMA begin address                                                */
    } bit;
  } R16_SPI0_DMA_BEG;
  __IM  uint16_t  RESERVED4;
  
  union {
    __IOM uint16_t reg;                         /*!< RW, SPI0 DMA end address                                                  */
    
    struct {
      __IOM uint16_t R16_SPI0_DMA_END : 16;     /*!< RW, SPI0 DMA end address                                                  */
    } bit;
  } R16_SPI0_DMA_END;
} SPI0_Type;                                    /*!< Size = 30 (0x1e)                                                          */



/* =========================================================================================================================== */
/* ================                                            I2C                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief I2C register (I2C)
  */

typedef struct {                                /*!< I2C Structure                                                             */
  
  union {
    __IOM uint16_t reg;                         /*!< RW, I2C control 1                                                         */
    
    struct {
      __IOM uint16_t RB_I2C_PE  : 1;            /*!< RW, Peripheral enable                                                     */
      __IOM uint16_t RB_I2C_SMBUS : 1;          /*!< RW, SMBUS mode: 0=I2C mode, 1=SMBUS mode                                  */
            uint16_t            : 1;
      __IOM uint16_t RB_I2C_SMBTYPE : 1;        /*!< RW, SMBus type: 0=Device, 1=Host                                          */
      __IOM uint16_t RB_I2C_EBARP : 1;          /*!< RW, ARP enable                                                            */
      __IOM uint16_t RB_I2C_ENPEC : 1;          /*!< RW, PEC ebable                                                            */
      __IOM uint16_t RB_I2C_ENGC : 1;           /*!< RW, General call enable                                                   */
      __IOM uint16_t RB_I2C_NOSTRETCH : 1;      /*!< RW, Clock stretching disable (Slave mode)                                 */
      __IOM uint16_t RB_I2C_START : 1;          /*!< RW, Start generation: master mode: 0=no start, 1=repeated start;
                                                     slave mode: 0=no start, 1=start at bus free                               */
      __IOM uint16_t RB_I2C_STOP : 1;           /*!< RW, Stop generation: master mode: 0=no stop, 1=stop after the
                                                     current byte transfer or after the current Start condition
                                                     is sent; slave mode: 0=no stop, 1=Release the SCL and SDA
                                                     lines after the current byte transfer                                     */
      __IOM uint16_t RB_I2C_ACK : 1;            /*!< RW, Acknowledge enable                                                    */
      __IOM uint16_t RB_I2C_POS : 1;            /*!< RW, Acknowledge/PEC Position (for data reception)                         */
      __IOM uint16_t RB_I2C_PEC : 1;            /*!< RW, Packet error checking: 0=No PEC transfer, 1=PEC transfer
                                                     (in Tx or Rx mode)                                                        */
      __IOM uint16_t RB_I2C_ALERT : 1;          /*!< RW, SMBus alert: 0=Releases SMBA pin high, 1=Drives SMBA pin
                                                     low.                                                                      */
            uint16_t            : 1;
      __IOM uint16_t RB_I2C_SWRST : 1;          /*!< RW, Software reset                                                        */
    } bit;
  } R16_I2C_CTRL1;
  __IM  uint16_t  RESERVED;
  
  union {
    __IOM uint16_t reg;                         /*!< RW, I2C control 2                                                         */
    
    struct {
      __IOM uint16_t RB_I2C_FREQ : 6;           /*!< RW, Peripheral clock frequency, The minimum allowed frequency
                                                     is 2 MHz,the maximum frequency is 36 MHz                                  */
            uint16_t            : 2;
      __IOM uint16_t RB_I2C_ITERREN : 1;        /*!< RW, Error interrupt enable                                                */
      __IOM uint16_t RB_I2C_ITEVTEN : 1;        /*!< RW, Event interrupt enable                                                */
      __IOM uint16_t RB_I2C_ITBUFEN : 1;        /*!< RW, Buffer interrupt enable                                               */
            uint16_t            : 5;
    } bit;
  } R16_I2C_CTRL2;
  __IM  uint16_t  RESERVED1;
  
  union {
    __IOM uint16_t reg;                         /*!< RW, I2C own address register 1                                            */
    
    struct {
      __IOM uint16_t RB_I2C_ADD0 : 1;           /*!< RW, bit0 of address in 10-bit addressing mode                             */
      __IOM uint16_t RB_I2C_ADD7_1 : 7;         /*!< RW, bit[7:1] of address                                                   */
      __IOM uint16_t RB_I2C_ADD9_8 : 2;         /*!< RW, bit[9:8] of address in 10-bit addressing mode                         */
            uint16_t            : 5;
      __IOM uint16_t RB_I2C_ADDMODE : 1;        /*!< RW, Addressing mode (slave mode): 0=7-bit slave address, 1=10-bit
                                                     slave address                                                             */
    } bit;
  } R16_I2C_OADDR1;
  __IM  uint16_t  RESERVED2;
  
  union {
    __IOM uint16_t reg;                         /*!< RW, I2C own address register 2                                            */
    
    struct {
      __IOM uint16_t RB_I2C_ENDUAL : 1;         /*!< RW, Dual addressing mode enable                                           */
      __IOM uint16_t RB_I2C_ADD2 : 7;           /*!< RW, bit[7:1] of address2                                                  */
            uint16_t            : 8;
    } bit;
  } R16_I2C_OADDR2;
  __IM  uint16_t  RESERVED3;
  
  union {
    __IOM uint16_t reg;                         /*!< RW, I2C data register                                                     */
    
    struct {
      __IOM uint16_t R16_I2C_DATAR : 8;         /*!< RW, I2C data register                                                     */
            uint16_t            : 8;
    } bit;
  } R16_I2C_DATAR;
  __IM  uint16_t  RESERVED4;
  
  union {
    __IM  uint16_t reg;                         /*!< RO, I2C stauts register 1                                                 */
    
    struct {
      __IM  uint16_t RB_I2C_SB  : 1;            /*!< RW0, Start bit flag (Master mode)                                         */
      __IM  uint16_t RB_I2C_ADDR : 1;           /*!< RW0, Address sent (master mode)/matched (slave mode) flag                 */
      __IM  uint16_t RB_I2C_BTF : 1;            /*!< RO, Byte transfer finished flag                                           */
      __IM  uint16_t RB_I2C_ADD10 : 1;          /*!< RO, 10-bit header sent flag (Master mode)                                 */
      __IM  uint16_t RB_I2C_STOPF : 1;          /*!< RO, Stop detection flag (slave mode)                                      */
            uint16_t            : 1;
      __IM  uint16_t RB_I2C_RxNE : 1;           /*!< RO, Data register not empty flag (receivers)                              */
      __IM  uint16_t RB_I2C_TxE : 1;            /*!< RO, Data register empty flag (transmitters)                               */
      __IM  uint16_t RB_I2C_BERR : 1;           /*!< RW0, Bus error flag                                                       */
      __IM  uint16_t RB_I2C_ARLO : 1;           /*!< RW0, Arbitration lost flag (master mode)                                  */
      __IM  uint16_t RB_I2C_AF  : 1;            /*!< RW0, Acknowledge failure flag                                             */
      __IM  uint16_t RB_I2C_OVR : 1;            /*!< RW0, Overrun/Underrun flag                                                */
      __IM  uint16_t RB_I2C_PECERR : 1;         /*!< RW0, PEC Error flag in reception                                          */
      __IM  uint16_t RB_I2C_TIMEOUT : 1;        /*!< RW0, Timeout or Tlow error flag                                           */
            uint16_t            : 1;
      __IM  uint16_t RB_I2C_SMBALERT : 1;       /*!< RW0, SMBus alert flag                                                     */
    } bit;
  } R16_I2C_STAR1;
  __IM  uint16_t  RESERVED5;
  
  union {
    __IM  uint16_t reg;                         /*!< RO, I2C status register 2                                                 */
    
    struct {
      __IM  uint16_t RB_I2C_MSL : 1;            /*!< RO, Mode statu: 0=Slave mode, 1=Master mode                               */
      __IM  uint16_t RB_I2C_BUSY : 1;           /*!< RO, Bus busy flag                                                         */
      __IM  uint16_t RB_I2C_TRA : 1;            /*!< RO, Trans flag: 0=data bytes received, 1=data bytes transmitted           */
            uint16_t            : 1;
      __IM  uint16_t RB_I2C_GENCALL : 1;        /*!< RO, General call address (Slave mode) received flag                       */
      __IM  uint16_t RB_I2C_SMBDEFAULT : 1;     /*!< RO, SMBus device default address (Slave mode) received flag               */
      __IM  uint16_t RB_I2C_SMBHOST : 1;        /*!< RO, SMBus host header (Slave mode) received flag                          */
      __IM  uint16_t RB_I2C_DUALF : 1;          /*!< RO, Dual flag (Slave mode): 0=Received address matched with
                                                     OAR1, 1=Received address matched with OAR2                                */
      __IM  uint16_t RB_I2C_PECX : 8;           /*!< RO, Packet error checking register                                        */
    } bit;
  } R16_I2C_STAR2;
  __IM  uint16_t  RESERVED6;
  
  union {
    __IOM uint16_t reg;                         /*!< RW, I2C clock control register                                            */
    
    struct {
      __IOM uint16_t RB_I2C_CCR : 12;           /*!< RW, Controls the SCL clock in Fm/Sm mode (Master mode)                    */
            uint16_t            : 2;
      __IOM uint16_t RB_I2C_DUTY : 1;           /*!< RW, Fm mode duty cycle: 0=L/H=2, 1=L/H=16/9                               */
      __IOM uint16_t RB_I2C_F_S : 1;            /*!< RW, I2C master mode selection: 0=standard mode, 1=fast mode               */
    } bit;
  } R16_I2C_CKCFGR;
  __IM  uint16_t  RESERVED7;
  
  union {
    __IOM uint16_t reg;                         /*!< RW, I2C trise register                                                    */
    
    struct {
      __IOM uint16_t RB_I2C_TRISE : 6;          /*!< RW, Maximum rise time in Fm/Sm mode (Master mode)                         */
            uint16_t            : 10;
    } bit;
  } R16_I2C_RTR;
} I2C_Type;                                     /*!< Size = 34 (0x22)                                                          */



/* =========================================================================================================================== */
/* ================                                           PWMx                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief PWMx register (PWMx)
  */

typedef struct {                                /*!< PWMx Structure                                                            */
  
  union {
    __IOM uint8_t reg;                          /*!< RW, PWM output enable control                                             */
    
    struct {
      __IOM uint8_t RB_PWM4_OUT_EN : 1;         /*!< RW, PWM4 output enable                                                    */
      __IOM uint8_t RB_PWM5_OUT_EN : 1;         /*!< RW, PWM5 output enable                                                    */
      __IOM uint8_t RB_PWM6_OUT_EN : 1;         /*!< RW, PWM6 output enable                                                    */
      __IOM uint8_t RB_PWM7_OUT_EN : 1;         /*!< RW, PWM7 output enable                                                    */
      __IOM uint8_t RB_PWM8_OUT_EN : 1;         /*!< RW, PWM8 output enable                                                    */
      __IOM uint8_t RB_PWM9_OUT_EN : 1;         /*!< RW, PWM9 output enable                                                    */
      __IOM uint8_t RB_PWM10_OUT_EN : 1;        /*!< RW, PWM10 output enable                                                   */
      __IOM uint8_t RB_PWM11_OUT_EN : 1;        /*!< RW, PWM11 output enable                                                   */
    } bit;
  } R8_PWM_OUT_EN;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, PWM output polarity control                                           */
    
    struct {
      __IOM uint8_t RB_PWM4_POLAR : 1;          /*!< RW, PWM4 output polarity: 0=default low and high action, 1=default
                                                     high and low action                                                       */
      __IOM uint8_t RB_PWM5_POLAR : 1;          /*!< RW, PWM5 output polarity: 0=default low and high action, 1=default
                                                     high and low action                                                       */
      __IOM uint8_t RB_PWM6_POLAR : 1;          /*!< RW, PWM6 output polarity: 0=default low and high action, 1=default
                                                     high and low action                                                       */
      __IOM uint8_t RB_PWM7_POLAR : 1;          /*!< RW, PWM7 output polarity: 0=default low and high action, 1=default
                                                     high and low action                                                       */
      __IOM uint8_t RB_PWM8_POLAR : 1;          /*!< RW, PWM8 output polarity: 0=default low and high action, 1=default
                                                     high and low action                                                       */
      __IOM uint8_t RB_PWM9_POLAR : 1;          /*!< RW, PWM9 output polarity: 0=default low and high action, 1=default
                                                     high and low action                                                       */
      __IOM uint8_t RB_PWM10_POLAR : 1;         /*!< RW, PWM10 output polarity: 0=default low and high action, 1=default
                                                     high and low action                                                       */
      __IOM uint8_t RB_PWM11_POLAR : 1;         /*!< RW, PWM11 output polarity: 0=default low and high action, 1=default
                                                     high and low action                                                       */
    } bit;
  } R8_PWM_POLAR;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, PWM configuration                                                     */
    
    struct {
      __IOM uint8_t RB_PWM_CYCLE_SEL : 1;       /*!< RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31
                                                     clocks                                                                    */
      __IM  uint8_t RB_PWM_STAG_ST : 1;         /*!< RO, PWM stagger cycle status                                              */
      __IOM uint8_t RB_PWM_CYC_MOD : 2;         /*!< RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6
                                                     bits data, 11=5 bits data                                                 */
      __IOM uint8_t RB_PWM4_5_STAG_EN : 1;      /*!< RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger
                                                     output                                                                    */
      __IOM uint8_t RB_PWM6_7_STAG_EN : 1;      /*!< RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger
                                                     output                                                                    */
      __IOM uint8_t RB_PWM8_9_STAG_EN : 1;      /*!< RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger
                                                     output                                                                    */
      __IOM uint8_t RB_PWM10_11_STAG_EN : 1;    /*!< RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger
                                                     output                                                                    */
    } bit;
  } R8_PWM_CONFIG;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, PWM clock divisor                                                     */
    
    struct {
      __IOM uint8_t R8_PWM_CLOCK_DIV : 8;       /*!< RW, PWM clock divisor                                                     */
    } bit;
  } R8_PWM_CLOCK_DIV;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, PWM4 data holding                                                     */
    
    struct {
      __IOM uint8_t R8_PWM4_DATA : 8;           /*!< RW, PWM4 data holding                                                     */
    } bit;
  } R8_PWM4_DATA;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, PWM5 data holding                                                     */
    
    struct {
      __IOM uint8_t R8_PWM5_DATA : 8;           /*!< RW, PWM5 data holding                                                     */
    } bit;
  } R8_PWM5_DATA;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, PWM6 data holding                                                     */
    
    struct {
      __IOM uint8_t R8_PWM6_DATA : 8;           /*!< RW, PWM6 data holding                                                     */
    } bit;
  } R8_PWM6_DATA;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, PWM7 data holding                                                     */
    
    struct {
      __IOM uint8_t R8_PWM7_DATA : 8;           /*!< RW, PWM7 data holding                                                     */
    } bit;
  } R8_PWM7_DATA;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, PWM8 data holding                                                     */
    
    struct {
      __IOM uint8_t R8_PWM8_DATA : 8;           /*!< RW, PWM8 data holding                                                     */
    } bit;
  } R8_PWM8_DATA;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, PWM9 data holding                                                     */
    
    struct {
      __IOM uint8_t R8_PWM9_DATA : 8;           /*!< RW, PWM9 data holding                                                     */
    } bit;
  } R8_PWM9_DATA;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, PWM10 data holding                                                    */
    
    struct {
      __IOM uint8_t R8_PWM10_DATA : 8;          /*!< RW, PWM10 data holding                                                    */
    } bit;
  } R8_PWM10_DATA;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, PWM11 data holding                                                    */
    
    struct {
      __IOM uint8_t R8_PWM11_DATA : 8;          /*!< RW, PWM11 data holding                                                    */
    } bit;
  } R8_PWM11_DATA;
  
  union {
    __IOM uint8_t reg;                          /*!< RW, PWM interrupt control                                                 */
    
    struct {
      __IOM uint8_t RB_PWM_IE_CYC : 1;          /*!< RW, enable interrupt for PWM cycle end                                    */
      __IOM uint8_t RB_PWM_CYC_PRE : 1;         /*!< RW, select PWM cycle interrupt point                                      */
            uint8_t             : 5;
      __IOM uint8_t RB_PWM_IF_CYC : 1;          /*!< RW1, interrupt flag for PWM cycle end                                     */
    } bit;
  } R8_PWM_INT_CTRL;
  __IM  uint8_t   RESERVED;
  __IM  uint16_t  RESERVED1;
  
  union {
    __IOM uint32_t reg;                         /*!< RW, PWM8/9 data register                                                  */
    
    struct {
      __IOM uint32_t RB_PWM8_REG_DATA : 16;     /*!< RW, 16 bit data of PWM8 channel                                           */
      __IOM uint32_t RB_PWM9_REG_DATA : 16;     /*!< RW, 16 bit data of PWM9 channel                                           */
    } bit;
  } R32_PWM_REG_DATA8;
  
  union {
    __IOM uint32_t reg;                         /*!< RW, PWM cycle end register                                                */
    
    struct {
      __IOM uint32_t RB_PWM_CYC_VALUE : 16;     /*!< RW, PWM End Cycles                                                        */
            uint32_t            : 16;
    } bit;
  } R32_PWM_REG_CYCLE;
} PWMx_Type;                                    /*!< Size = 24 (0x18)                                                          */



/* =========================================================================================================================== */
/* ================                                            LCD                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief LCD register (LCD)
  */

typedef struct {                                /*!< LCD Structure                                                             */
  
  union {
    __IOM uint32_t reg;                         /*!< RW, LCD Command Register                                                  */
    
    struct {
      __IOM uint32_t SYS_EN     : 1;            /*!< RW, System Enable                                                         */
      __IOM uint32_t LCD_ON     : 1;            /*!< RW, LCD switch                                                            */
      __IOM uint32_t LCD_BIAS   : 1;            /*!< RW, PWM6 Bias ratio selection enable                                      */
      __IOM uint32_t LCD_DUTY   : 2;            /*!< RW, LCD duty cycle selection                                              */
      __IOM uint32_t SCAN_CLK_SEL : 2;          /*!< RW, Scan clock selection                                                  */
      __IOM uint32_t VLCD_SEL   : 1;            /*!< RW, LCD driver voltage selection                                          */
      __IOM uint32_t LCD_SEG_EN : 8;            /*!< RW, Enabling SEG0-SEG7 segments                                           */
            uint32_t            : 16;
    } bit;
  } R32_LCD_CMD;
  
  union {
    __IOM uint32_t reg;                         /*!< RW, LCD RAM0 register                                                     */
    
    struct {
      __IOM uint32_t LCD_SEG0   : 4;            /*!< RW, SEG0 segment data                                                     */
      __IOM uint32_t LCD_SEG1   : 4;            /*!< RW, SEG1 segment data                                                     */
      __IOM uint32_t LCD_SEG2   : 4;            /*!< RW, SEG2 segment data                                                     */
      __IOM uint32_t LCD_SEG3   : 4;            /*!< RW, SEG3 segment data                                                     */
      __IOM uint32_t LCD_SEG4   : 4;            /*!< RW, SEG4 segment data                                                     */
      __IOM uint32_t LCD_SEG5   : 4;            /*!< RW, SEG5 segment data                                                     */
      __IOM uint32_t LCD_SEG6   : 4;            /*!< RW, SEG6 segment data                                                     */
      __IOM uint32_t LCD_SEG7   : 4;            /*!< RW, SEG7 segment data                                                     */
    } bit;
  } R32_LCD_RAM0;
  
  union {
    __IOM uint32_t reg;                         /*!< RW, LCD RAM1 register                                                     */
    
    struct {
      __IOM uint32_t LCD_SEG8   : 4;            /*!< RW, SEG8 segment data                                                     */
      __IOM uint32_t LCD_SEG9   : 4;            /*!< RW, SEG9 segment data                                                     */
      __IOM uint32_t LCD_SEG10  : 4;            /*!< RW, SEG10 segment data                                                    */
      __IOM uint32_t LCD_SEG11  : 4;            /*!< RW, SEG11 segment data                                                    */
      __IOM uint32_t LCD_SEG12  : 4;            /*!< RW, SEG12 segment data                                                    */
      __IOM uint32_t LCD_SEG13  : 4;            /*!< RW, SEG13 segment data                                                    */
      __IOM uint32_t LCD_SEG14  : 4;            /*!< RW, SEG14 segment data                                                    */
      __IOM uint32_t LCD_SEG15  : 4;            /*!< RW, SEG15 segment data                                                    */
    } bit;
  } R32_LCD_RAM1;
  
  union {
    __IOM uint32_t reg;                         /*!< RW, LCD RAM2 register                                                     */
    
    struct {
      __IOM uint32_t LCD_SEG16  : 4;            /*!< RW, SEG16 segment data                                                    */
      __IOM uint32_t LCD_SEG17  : 4;            /*!< RW, SEG17 segment data                                                    */
      __IOM uint32_t LCD_SEG18  : 4;            /*!< RW, SEG18 segment data                                                    */
      __IOM uint32_t LCD_SEG19  : 4;            /*!< RW, SEG19 segment data                                                    */
            uint32_t            : 16;
    } bit;
  } R32_LCD_RAM2;
} LCD_Type;                                     /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                            USB                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief USB register (USB)
  */

typedef struct {                                /*!< USB Structure                                                             */
  
  union {
    __IOM uint8_t reg;                          /*!< USB base control                                                          */
    
    struct {
      __IOM uint8_t RB_UC_DMA_EN : 1;           /*!< DMA enable and DMA interrupt enable for USB                               */
      __IOM uint8_t RB_UC_CLR_ALL : 1;          /*!< force clear FIFO and count of USB                                         */
      __IOM uint8_t RB_UC_RESET_SIE : 1;        /*!< force reset USB SIE, need software clear                                  */
      __IOM uint8_t RB_UC_INT_BUSY : 1;         /*!< enable automatic responding busy for device mode or automatic
                                                     pause for host mode during interrupt flag UIF_TRANSFER
                                                     valid                                                                     */
      __IOM uint8_t MASK_UC_SYS_CTRL : 2;       /*!< bit mask of USB system control                                            */
      __IOM uint8_t RB_UC_LOW_SPEED : 1;        /*!< enable USB low speed: 0=12Mbps, 1=1.5Mbps                                 */
      __IOM uint8_t RB_UC_HOST_MODE : 1;        /*!< enable USB host mode: 0=device mode, 1=host mode                          */
    } bit;
  } R8_USB_CTRL;
  
  union {
    __IOM uint8_t reg;                          /*!< USB device physical prot control                                          */
    
    struct {
      __IOM uint8_t RB_UD_PORT_EN : 1;          /*!< enable USB physical port I-O: 0=disable, 1=enable;enable USB
                                                     port: 0=disable, 1=enable port, automatic disabled if USB
                                                     device detached                                                           */
      __IOM uint8_t RB_UD_HUB0_RESET : 1;       /*!< general purpose bit;control USB bus reset: 0=normal, 1=force
                                                     bus reset                                                                 */
      __IOM uint8_t RB_UD_LOW_SPEED : 1;        /*!< enable USB physical port low speed: 0=full speed, 1=low speed;enable
                                                     USB port low speed: 0=full speed, 1=low speed                             */
            uint8_t             : 1;
      __IM  uint8_t RB_UD_DM_PIN : 1;           /*!< ReadOnly: indicate current UDM pin level                                  */
      __IM  uint8_t RB_UD_DP_PIN : 1;           /*!< ReadOnly: indicate current UDP pin level                                  */
            uint8_t             : 1;
      __IM  uint8_t RB_UD_PD_DIS : 1;           /*!< disable USB UDP-UDM pulldown resistance: 0=enable pulldown,
                                                     1=disable                                                                 */
    } bit;
  } R8_UDEV_CTRL;
  
  union {
    __IOM uint8_t reg;                          /*!< USB interrupt enable                                                      */
    
    struct {
      __IOM uint8_t RB_UIE_BUS_RST__RB_UIE_DETECT : 1;/*!< enable interrupt for USB bus reset event for USB device mode;enable
                                                     interrupt for USB device detected event for USB host mode                 */
      __IOM uint8_t RB_UIE_TRANSFER : 1;        /*!< enable interrupt for USB transfer completion                              */
      __IOM uint8_t RB_UIE_SUSPEND : 1;         /*!< enable interrupt for USB suspend or resume event                          */
      __IOM uint8_t RB_UIE_HST_SOF : 1;         /*!< enable interrupt for host SOF timer action for USB host mode              */
      __IOM uint8_t RB_UIE_FIFO_OV : 1;         /*!< enable interrupt for FIFO overflow                                        */
      __IOM uint8_t RB_MOD_1_WIRE : 1;          /*!< enable USB single line mode                                               */
      __IOM uint8_t RB_UIE_DEV_NAK : 1;         /*!< enable interrupt for NAK responded for USB device mode                    */
      __IOM uint8_t RB_UIE_DEV_SOF : 1;         /*!< enable interrupt for SOF received for USB device mode                     */
    } bit;
  } R8_USB_INT_EN;
  
  union {
    __IOM uint8_t reg;                          /*!< USB device address                                                        */
    
    struct {
      __IOM uint8_t MASK_USB_ADDR : 7;          /*!< bit mask for USB device address                                           */
      __IOM uint8_t RB_UDA_GP_BIT : 1;          /*!< general purpose bit                                                       */
    } bit;
  } R8_USB_DEV_AD;
  __IM  uint8_t   RESERVED;
  
  union {
    __IM  uint8_t reg;                          /*!< USB miscellaneous status                                                  */
    
    struct {
      __IM  uint8_t RB_UMS_DEV_ATTACH : 1;      /*!< RO, indicate device attached status on USB host                           */
      __IM  uint8_t RB_UMS_DM_LEVEL : 1;        /*!< RO, indicate UDM level saved at device attached to USB host               */
      __IM  uint8_t RB_UMS_SUSPEND : 1;         /*!< RO, indicate USB suspend status                                           */
      __IM  uint8_t RB_UMS_BUS_RESET : 1;       /*!< RO, indicate USB bus reset status                                         */
      __IM  uint8_t RB_UMS_R_FIFO_RDY : 1;      /*!< RO, indicate USB receiving FIFO ready status (not empty)                  */
      __IM  uint8_t RB_UMS_SIE_FREE : 1;        /*!< RO, indicate USB SIE free status                                          */
      __IM  uint8_t RB_UMS_SOF_ACT : 1;         /*!< RO, indicate host SOF timer action status for USB host                    */
      __IM  uint8_t RB_UMS_SOF_PRES : 1;        /*!< RO, indicate host SOF timer presage status                                */
    } bit;
  } R8_USB_MIS_ST;
  
  union {
    __IOM uint8_t reg;                          /*!< USB interrupt flag                                                        */
    
    struct {
      __IOM uint8_t RB_UIF_BUS_RST_RB_UIF_DETECT : 1;/*!< RW,bus reset event interrupt flag for USB device mode, direct
                                                     bit address clear or write 1 to clear;device detected event
                                                     interrupt flag for USB host mode, direct bit address clear
                                                     or write 1 to clear                                                       */
      __IOM uint8_t RB_UIF_TRANSFER : 1;        /*!< RW,USB transfer completion interrupt flag, direct bit address
                                                     clear or write 1 to clear                                                 */
      __IOM uint8_t RB_UIF_SUSPEND : 1;         /*!< RW,USB suspend or resume event interrupt flag, direct bit address
                                                     clear or write 1 to clear                                                 */
      __IOM uint8_t RB_UIF_HST_SOF : 1;         /*!< RW,host SOF timer interrupt flag for USB host, direct bit address
                                                     clear or write 1 to clear                                                 */
      __IOM uint8_t RB_UIF_FIFO_OV : 1;         /*!< RW,FIFO overflow interrupt flag for USB, direct bit address
                                                     clear or write 1 to clear                                                 */
      __IM  uint8_t RB_U_SIE_FREE : 1;          /*!< RO, indicate USB SIE free status                                          */
      __IM  uint8_t RB_U_TOG_OK : 1;            /*!< RO, indicate current USB transfer toggle is OK                            */
      __IM  uint8_t RB_U_IS_NAK : 1;            /*!< RO, indicate current USB transfer is NAK received                         */
    } bit;
  } R8_USB_INT_FG;
  
  union {
    __IM  uint8_t reg;                          /*!< USB interrupt status                                                      */
    
    struct {
      __IM  uint8_t MASK_UIS_H_RES__MASK_UIS_ENDP : 4;/*!< RO, bit mask of current transfer handshake response for USB
                                                     host mode: 0000=no response, time out from device, others=handshake
                                                     response PID received;RO, bit mask of current transfer
                                                     endpoint number for USB device mode                                       */
      __IM  uint8_t MASK_UIS_TOKEN : 2;         /*!< RO, bit mask of current token PID code received for USB device
                                                     mode                                                                      */
      __IM  uint8_t RB_UIS_TOG_OK : 1;          /*!< RO, indicate current USB transfer toggle is OK                            */
      __IM  uint8_t RB_UIS_SETUP_ACT : 1;       /*!< RO, indicate current USB transfer is NAK received for USB device
                                                     mode                                                                      */
    } bit;
  } R8_USB_INT_ST;
  
  union {
    __IM  uint8_t reg;                          /*!< USB receiving length                                                      */
    
    struct {
      __IM  uint8_t R8_USB_RX_LEN : 7;          /*!< RO,USB receiving length                                                   */
            uint8_t             : 1;
    } bit;
  } R8_USB_RX_LEN;
  __IM  uint8_t   RESERVED1;
  __IM  uint16_t  RESERVED2;
  
  union {
    __IOM uint8_t reg;                          /*!< endpoint 1/4 mode                                                         */
    
    struct {
            uint8_t             : 2;
      __IOM uint8_t RB_UEP4_TX_EN : 1;          /*!< enable USB endpoint 4 transmittal (IN)                                    */
      __IOM uint8_t RB_UEP4_RX_EN : 1;          /*!< enable USB endpoint 4 receiving (OUT)                                     */
      __IOM uint8_t RB_UEP1_BUF_MOD : 1;        /*!< buffer mode of USB endpoint 1                                             */
            uint8_t             : 1;
      __IOM uint8_t RB_UEP1_TX_EN : 1;          /*!< enable USB endpoint 1 transmittal (IN)                                    */
      __IOM uint8_t RB_UEP1_RX_EN : 1;          /*!< enable USB endpoint 1 receiving (OUT)                                     */
    } bit;
  } R8_UEP4_1_MOD;
  
  union {
    __IOM uint8_t reg;                          /*!< endpoint 2/3 mode;host endpoint mode                                      */
    
    struct {
      __IOM uint8_t RB_UEP2_BUF_MOD : 1;        /*!< buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint         */
            uint8_t             : 1;
      __IOM uint8_t RB_UEP2_TX_EN : 1;          /*!< enable USB endpoint 2 transmittal (IN)                                    */
      __IOM uint8_t RB_UEP2_RX_EN : 1;          /*!< enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint
                                                     receiving                                                                 */
      __IOM uint8_t RB_UEP3_BUF_MOD : 1;        /*!< buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint        */
            uint8_t             : 1;
      __IOM uint8_t RB_UEP3_TX_EN : 1;          /*!< enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint
                                                     transmittal                                                               */
      __IOM uint8_t RB_UEP3_RX_EN : 1;          /*!< enable USB endpoint 3 receiving (OUT)                                     */
    } bit;
  } R8_UEP2_3_MOD;
  
  union {
    __IOM uint8_t reg;                          /*!< endpoint 5/6/7 mode                                                       */
    
    struct {
      __IOM uint8_t RB_UEP5_TX_EN : 1;          /*!< enable USB endpoint 5 transmittal (IN)                                    */
      __IOM uint8_t RB_UEP5_RX_EN : 1;          /*!< enable USB endpoint 5 receiving (OUT)                                     */
      __IOM uint8_t RB_UEP6_TX_EN : 1;          /*!< enable USB endpoint 6 transmittal (IN)                                    */
      __IOM uint8_t RB_UEP6_RX_EN : 1;          /*!< enable USB endpoint 6 receiving (OUT)                                     */
      __IOM uint8_t RB_UEP7_TX_EN : 1;          /*!< enable USB endpoint 7 transmittal (IN)                                    */
      __IOM uint8_t RB_UEP7_RX_EN : 1;          /*!< enable USB endpoint 7 receiving (OUT)                                     */
            uint8_t             : 2;
    } bit;
  } R8_UEP567_MOD;
  __IM  uint8_t   RESERVED3;
  
  union {
    __IOM uint16_t reg;                         /*!< endpoint 0 DMA buffer address                                             */
    
    struct {
            uint16_t            : 2;
      __IOM uint16_t R16_UEP0_DMA : 13;         /*!< RW,endpoint 0 DMA buffer address                                          */
            uint16_t            : 1;
    } bit;
  } R16_UEP0_DMA;
  __IM  uint16_t  RESERVED4;
  
  union {
    __IOM uint16_t reg;                         /*!< endpoint 1 DMA buffer address                                             */
    
    struct {
            uint16_t            : 2;
      __IOM uint16_t R16_UEP1_DMA : 13;         /*!< RW,endpoint 1 DMA buffer address                                          */
            uint16_t            : 1;
    } bit;
  } R16_UEP1_DMA;
  __IM  uint16_t  RESERVED5;
  
  union {
    __IOM uint16_t reg;                         /*!< endpoint 2 DMA buffer address;host rx endpoint buffer high address        */
    
    struct {
            uint16_t            : 2;
      __IOM uint16_t R16_UEP2_DMA : 13;         /*!< RW,endpoint 2 DMA buffer address;host rx endpoint buffer high
                                                     address                                                                   */
            uint16_t            : 1;
    } bit;
  } R16_UEP2_DMA;
  __IM  uint16_t  RESERVED6;
  
  union {
    __IOM uint16_t reg;                         /*!< endpoint 3 DMA buffer address;host tx endpoint buffer high address        */
    
    struct {
            uint16_t            : 2;
      __IOM uint16_t R16_UEP3_DMA : 13;         /*!< RW,endpoint 3 DMA buffer address;host rx endpoint buffer high
                                                     address                                                                   */
            uint16_t            : 1;
    } bit;
  } R16_UEP3_DMA;
  __IM  uint16_t  RESERVED7;
  
  union {
    __IOM uint8_t reg;                          /*!< endpoint 0 transmittal length                                             */
    
    struct {
      __IOM uint8_t R8_UEP0_T_LEN : 7;          /*!< endpoint 0 transmittal length                                             */
            uint8_t             : 1;
    } bit;
  } R8_UEP0_T_LEN;
  __IM  uint8_t   RESERVED8;
  
  union {
    __IOM uint8_t reg;                          /*!< endpoint 0 control                                                        */
    
    struct {
      __IOM uint8_t MASK_UEP_T_RES : 2;         /*!< bit mask of handshake response type for USB endpoint X transmittal
                                                     (IN)                                                                      */
      __IOM uint8_t MASK_UEP_R_RES : 2;         /*!< bit mask of handshake response type for USB endpoint X receiving
                                                     (OUT)                                                                     */
      __IOM uint8_t RB_UEP_AUTO_TOG : 1;        /*!< enable automatic toggle after successful transfer completion
                                                     on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle                    */
            uint8_t             : 1;
      __IOM uint8_t RB_UEP_T_TOG : 1;           /*!< prepared data toggle flag of USB endpoint X transmittal (IN):
                                                     0=DATA0, 1=DATA1                                                          */
      __IOM uint8_t RB_UEP_R_TOG : 1;           /*!< expected data toggle flag of USB endpoint X receiving (OUT):
                                                     0=DATA0, 1=DATA1                                                          */
    } bit;
  } R8_UEP0_CTRL;
  __IM  uint8_t   RESERVED9;
  
  union {
    __IOM uint8_t reg;                          /*!< endpoint 1 transmittal length                                             */
    
    struct {
      __IOM uint8_t R8_UEP1_T_LEN : 7;          /*!< endpoint 1 transmittal length                                             */
            uint8_t             : 1;
    } bit;
  } R8_UEP1_T_LEN;
  __IM  uint8_t   RESERVED10;
  
  union {
    __IOM uint8_t reg;                          /*!< endpoint 1 control;host aux setup                                         */
    
    struct {
      __IOM uint8_t MASK_UEP_T_RES : 2;         /*!< bit mask of handshake response type for USB endpoint X transmittal
                                                     (IN)                                                                      */
      __IOM uint8_t MASK_UEP_R_RES : 2;         /*!< bit mask of handshake response type for USB endpoint X receiving
                                                     (OUT)                                                                     */
      __IOM uint8_t RB_UEP_AUTO_TOG : 1;        /*!< enable automatic toggle after successful transfer completion
                                                     on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle                    */
            uint8_t             : 1;
      __IOM uint8_t RB_UEP_T_TOG : 1;           /*!< prepared data toggle flag of USB endpoint X transmittal (IN):
                                                     0=DATA0, 1=DATA1;USB host automatic SOF enable                            */
      __IOM uint8_t RB_UEP_R_TOG : 1;           /*!< expected data toggle flag of USB endpoint X receiving (OUT):
                                                     0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable
                                                     for low speed device via hub                                              */
    } bit;
  } R8_UEP1_CTRL;
  __IM  uint8_t   RESERVED11;
  
  union {
    __IOM uint8_t reg;                          /*!< endpoint 2 transmittal length;host endpoint and PID                       */
    
    struct {
      __IOM uint8_t R8_UEP2_T_LEN : 7;          /*!< Set the number of data bytes to be sent by USB endpoint n                 */
      __IOM uint8_t R8_UEP2_HOST_PID3 : 1;      /*!< The token in host mode identifies the bit3 of the PID                     */
    } bit;
  } R8_UEP2_T_LEN;
  __IM  uint8_t   RESERVED12;
  
  union {
    __IOM uint8_t reg;                          /*!< endpoint 2 control;host receiver endpoint control                         */
    
    struct {
      __IOM uint8_t MASK_UEP_T_RES : 2;         /*!< bit mask of handshake response type for USB endpoint X transmittal
                                                     (IN)                                                                      */
      __IOM uint8_t MASK_UH_R_RES : 1;          /*!< bit mask of handshake response type for USB endpoint X receiving
                                                     (OUT)                                                                     */
            uint8_t             : 1;
      __IOM uint8_t RB_UEP_AUTO_TOG : 1;        /*!< enable automatic toggle after successful transfer completion
                                                     on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable
                                                     automatic toggle after successful transfer completion:
                                                     0=manual toggle, 1=automatic toggle                                       */
            uint8_t             : 1;
      __IOM uint8_t RB_UEP_T_TOG : 1;           /*!< prepared data toggle flag of USB endpoint X transmittal (IN):
                                                     0=DATA0, 1=DATA1                                                          */
      __IOM uint8_t RB_UEP_R_TOG : 1;           /*!< expected data toggle flag of USB endpoint X receiving (OUT):
                                                     0=DATA0, 1=DATA1;expected data toggle flag of host receiving
                                                     (IN): 0=DATA0, 1=DATA1                                                    */
    } bit;
  } R8_UEP2_CTRL;
  __IM  uint8_t   RESERVED13;
  
  union {
    __IOM uint8_t reg;                          /*!< endpoint 3 transmittal length;host transmittal endpoint transmittal
                                                     length                                                                    */
    
    struct {
      __IOM uint8_t R8_UEP3_T_LEN : 7;          /*!< endpoint 1 transmittal length                                             */
            uint8_t             : 1;
    } bit;
  } R8_UEP3_T_LEN;
  __IM  uint8_t   RESERVED14;
  
  union {
    __IOM uint8_t reg;                          /*!< endpoint 3 control;host transmittal endpoint control                      */
    
    struct {
      __IOM uint8_t MASK_UEP_T_RES : 2;         /*!< bit mask of handshake response type for USB endpoint X transmittal
                                                     (IN)                                                                      */
      __IOM uint8_t MASK_UEP_R_RES : 2;         /*!< bit mask of handshake response type for USB endpoint X receiving
                                                     (OUT)                                                                     */
      __IOM uint8_t RB_UEP_AUTO_TOG : 1;        /*!< enable automatic toggle after successful transfer completion
                                                     on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle                    */
            uint8_t             : 1;
      __IOM uint8_t RB_UEP_T_TOG : 1;           /*!< prepared data toggle flag of USB endpoint X transmittal (IN):
                                                     0=DATA0, 1=DATA1                                                          */
      __IOM uint8_t RB_UEP_R_TOG : 1;           /*!< expected data toggle flag of USB endpoint X receiving (OUT):
                                                     0=DATA0, 1=DATA1                                                          */
    } bit;
  } R8_UEP3_CTRL;
  __IM  uint8_t   RESERVED15;
  
  union {
    __IOM uint8_t reg;                          /*!< endpoint 4 transmittal length                                             */
    
    struct {
      __IOM uint8_t R8_UEP4_T_LEN : 7;          /*!< endpoint 4 transmittal length                                             */
            uint8_t             : 1;
    } bit;
  } R8_UEP4_T_LEN;
  __IM  uint8_t   RESERVED16;
  
  union {
    __IOM uint8_t reg;                          /*!< endpoint 4 control                                                        */
    
    struct {
      __IOM uint8_t MASK_UEP_T_RES : 2;         /*!< bit mask of handshake response type for USB endpoint X transmittal
                                                     (IN)                                                                      */
      __IOM uint8_t MASK_UEP_R_RES : 2;         /*!< bit mask of handshake response type for USB endpoint X receiving
                                                     (OUT)                                                                     */
      __IOM uint8_t RB_UEP_AUTO_TOG : 1;        /*!< enable automatic toggle after successful transfer completion
                                                     on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle                    */
            uint8_t             : 1;
      __IOM uint8_t RB_UEP_T_TOG : 1;           /*!< prepared data toggle flag of USB endpoint X transmittal (IN):
                                                     0=DATA0, 1=DATA1                                                          */
      __IOM uint8_t RB_UEP_R_TOG : 1;           /*!< expected data toggle flag of USB endpoint X receiving (OUT):
                                                     0=DATA0, 1=DATA1                                                          */
    } bit;
  } R8_UEP4_CTRL;
  __IM  uint8_t   RESERVED17;
  __IM  uint16_t  RESERVED18[16];
  
  union {
    __IOM uint16_t reg;                         /*!< endpoint 5 DMA buffer address                                             */
    
    struct {
            uint16_t            : 2;
      __IOM uint16_t R16_UEP5_DMA : 13;         /*!< RW,endpoint 5 DMA buffer address;host rx endpoint buffer high
                                                     address                                                                   */
            uint16_t            : 1;
    } bit;
  } R16_UEP5_DMA;
  __IM  uint16_t  RESERVED19;
  
  union {
    __IOM uint16_t reg;                         /*!< endpoint 6 DMA buffer address                                             */
    
    struct {
            uint16_t            : 2;
      __IOM uint16_t R16_UEP6_DMA : 13;         /*!< RW,endpoint 6 DMA buffer address;host rx endpoint buffer high
                                                     address                                                                   */
            uint16_t            : 1;
    } bit;
  } R16_UEP6_DMA;
  __IM  uint16_t  RESERVED20;
  
  union {
    __IOM uint16_t reg;                         /*!< endpoint 7 DMA buffer address                                             */
    
    struct {
            uint16_t            : 2;
      __IOM uint16_t R16_UEP7_DMA : 13;         /*!< RW,endpoint 7 DMA buffer address;host rx endpoint buffer high
                                                     address                                                                   */
            uint16_t            : 1;
    } bit;
  } R16_UEP7_DMA;
  __IM  uint16_t  RESERVED21[3];
  
  union {
    __IOM uint8_t reg;                          /*!< endpoint 5 transmittal length                                             */
    
    struct {
      __IOM uint8_t R8_UEP5_T_LEN : 7;          /*!< endpoint 5 transmittal length                                             */
            uint8_t             : 1;
    } bit;
  } R8_UEP5_T_LEN;
  __IM  uint8_t   RESERVED22;
  
  union {
    __IOM uint8_t reg;                          /*!< endpoint 5 control                                                        */
    
    struct {
      __IOM uint8_t MASK_UEP_T_RES : 2;         /*!< bit mask of handshake response type for USB endpoint X transmittal
                                                     (IN)                                                                      */
      __IOM uint8_t MASK_UEP_R_RES : 2;         /*!< bit mask of handshake response type for USB endpoint X receiving
                                                     (OUT)                                                                     */
      __IOM uint8_t RB_UEP_AUTO_TOG : 1;        /*!< enable automatic toggle after successful transfer completion
                                                     on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle                    */
            uint8_t             : 1;
      __IOM uint8_t RB_UEP_T_TOG : 1;           /*!< prepared data toggle flag of USB endpoint X transmittal (IN):
                                                     0=DATA0, 1=DATA1                                                          */
      __IOM uint8_t RB_UEP_R_TOG : 1;           /*!< expected data toggle flag of USB endpoint X receiving (OUT):
                                                     0=DATA0, 1=DATA1                                                          */
    } bit;
  } R8_UEP5_CTRL;
  __IM  uint8_t   RESERVED23;
  
  union {
    __IOM uint8_t reg;                          /*!< endpoint 6 transmittal length                                             */
    
    struct {
      __IOM uint8_t R8_UEP6_T_LEN : 7;          /*!< endpoint 6 transmittal length                                             */
            uint8_t             : 1;
    } bit;
  } R8_UEP6_T_LEN;
  __IM  uint8_t   RESERVED24;
  
  union {
    __IOM uint8_t reg;                          /*!< endpoint 6 control                                                        */
    
    struct {
      __IOM uint8_t MASK_UEP_T_RES : 2;         /*!< bit mask of handshake response type for USB endpoint X transmittal
                                                     (IN)                                                                      */
      __IOM uint8_t MASK_UEP_R_RES : 2;         /*!< bit mask of handshake response type for USB endpoint X receiving
                                                     (OUT)                                                                     */
      __IOM uint8_t RB_UEP_AUTO_TOG : 1;        /*!< enable automatic toggle after successful transfer completion
                                                     on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle                    */
            uint8_t             : 1;
      __IOM uint8_t RB_UEP_T_TOG : 1;           /*!< prepared data toggle flag of USB endpoint X transmittal (IN):
                                                     0=DATA0, 1=DATA1                                                          */
      __IOM uint8_t RB_UEP_R_TOG : 1;           /*!< expected data toggle flag of USB endpoint X receiving (OUT):
                                                     0=DATA0, 1=DATA1                                                          */
    } bit;
  } R8_UEP6_CTRL;
  __IM  uint8_t   RESERVED25;
  
  union {
    __IOM uint8_t reg;                          /*!< endpoint 7 transmittal length                                             */
    
    struct {
      __IOM uint8_t R8_UEP7_T_LEN : 7;          /*!< endpoint 7 transmittal length                                             */
            uint8_t             : 1;
    } bit;
  } R8_UEP7_T_LEN;
  __IM  uint8_t   RESERVED26;
  
  union {
    __IOM uint8_t reg;                          /*!< endpoint 7 control                                                        */
    
    struct {
      __IOM uint8_t MASK_UEP_T_RES : 2;         /*!< bit mask of handshake response type for USB endpoint X transmittal
                                                     (IN)                                                                      */
      __IOM uint8_t MASK_UEP_R_RES : 2;         /*!< bit mask of handshake response type for USB endpoint X receiving
                                                     (OUT)                                                                     */
      __IOM uint8_t RB_UEP_AUTO_TOG : 1;        /*!< enable automatic toggle after successful transfer completion
                                                     on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle                    */
            uint8_t             : 1;
      __IOM uint8_t RB_UEP_T_TOG : 1;           /*!< prepared data toggle flag of USB endpoint X transmittal (IN):
                                                     0=DATA0, 1=DATA1                                                          */
      __IOM uint8_t RB_UEP_R_TOG : 1;           /*!< expected data toggle flag of USB endpoint X receiving (OUT):
                                                     0=DATA0, 1=DATA1                                                          */
    } bit;
  } R8_UEP7_CTRL;
  __IM  uint8_t   RESERVED27;
  __IM  uint16_t  RESERVED28;
} USB_Type;                                     /*!< Size = 114 (0x72)                                                         */



/* =========================================================================================================================== */
/* ================                                           PFIC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Program Fast Interrupt Controller (PFIC)
  */

typedef struct {                                /*!< PFIC Structure                                                            */
  
  union {
    __IM  uint32_t reg;                         /*!< RO,Interrupt Status Register 1                                            */
    
    struct {
            uint32_t            : 12;
      __IM  uint32_t INTENSTA   : 20;           /*!< Interrupt ID Status                                                       */
    } bit;
  } R32_PFIC_ISR1;
  
  union {
    __IM  uint32_t reg;                         /*!< RO,Interrupt Status Register 2                                            */
    
    struct {
      __IM  uint32_t INTENSTA   : 4;            /*!< Interrupt ID Status                                                       */
            uint32_t            : 28;
    } bit;
  } R32_PFIC_ISR2;
  __IM  uint32_t  RESERVED[6];
  
  union {
    __IM  uint32_t reg;                         /*!< RO,Interrupt Pending Register 1                                           */
    
    struct {
            uint32_t            : 12;
      __IM  uint32_t PENDSTA    : 20;           /*!< PENDSTA                                                                   */
    } bit;
  } R32_PFIC_IPR1;
  
  union {
    __IM  uint32_t reg;                         /*!< RO,Interrupt Pending Register 2                                           */
    
    struct {
      __IM  uint32_t PENDSTA    : 4;            /*!< PENDSTA                                                                   */
            uint32_t            : 28;
    } bit;
  } R32_PFIC_IPR2;
  __IM  uint32_t  RESERVED1[6];
  
  union {
    __IOM uint32_t reg;                         /*!< RW,Interrupt Priority Register                                            */
    
    struct {
      __IOM uint32_t THRESHOLD  : 8;            /*!< RW,THRESHOLD                                                              */
            uint32_t            : 24;
    } bit;
  } R32_PFIC_ITHRESDR;
  __IM  uint32_t  RESERVED2;
  
  union {
    __OM  uint32_t reg;                         /*!< Interrupt Config Register                                                 */
    
    struct {
            uint32_t            : 7;
      __OM  uint32_t RESETSYS   : 1;            /*!< WO,RESETSYS                                                               */
            uint32_t            : 8;
      __OM  uint32_t KEYCODE    : 16;           /*!< WO,KEYCODE                                                                */
    } bit;
  } R32_PFIC_CFGR;
  
  union {
    __IM  uint32_t reg;                         /*!< Interrupt Global Register                                                 */
    
    struct {
      __IM  uint32_t NESTSTA    : 8;            /*!< RO,NESTSTA                                                                */
      __IM  uint32_t GACTSTA    : 1;            /*!< RO,GACTSTA                                                                */
      __IM  uint32_t GPENDSTA   : 1;            /*!< RO,GPENDSTA                                                               */
            uint32_t            : 22;
    } bit;
  } R32_PFIC_GISR;
  
  union {
    __IOM uint32_t reg;                         /*!< RW,Interrupt Fast ID Config Register                                      */
    
    struct {
      __IOM uint32_t FIID0      : 8;            /*!< RW,FIID0                                                                  */
      __IOM uint32_t FIID1      : 8;            /*!< RW,FIID1                                                                  */
      __IOM uint32_t FIID2      : 8;            /*!< RW,FIID2                                                                  */
      __IOM uint32_t FIID3      : 8;            /*!< RW,FIID3                                                                  */
    } bit;
  } R32_PFIC_IDCFGR;
  __IM  uint32_t  RESERVED3[3];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt 0 address Register                                              */
    
    struct {
      __IOM uint32_t FI0EN      : 1;            /*!< RW,Fast interrupt channel 0 enable bit                                    */
      __IOM uint32_t ADDR0      : 31;           /*!< RW,ADDR0                                                                  */
    } bit;
  } R32_PFIC_FIADDRR0;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt 1 address Register                                              */
    
    struct {
      __IOM uint32_t FI1EN      : 1;            /*!< RW,Fast interrupt channel 1 enable bit                                    */
      __IOM uint32_t ADDR1      : 31;           /*!< RW,ADDR1                                                                  */
    } bit;
  } R32_PFIC_FIADDRR1;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt 2 address Register                                              */
    
    struct {
      __IOM uint32_t FI2EN      : 1;            /*!< RW,Fast interrupt channel 2 enable bit                                    */
      __IOM uint32_t ADDR2      : 31;           /*!< RW,ADDR2                                                                  */
    } bit;
  } R32_PFIC_FIADDRR2;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt 3 address Register                                              */
    
    struct {
      __IOM uint32_t FI3EN      : 1;            /*!< RW,Fast interrupt channel 3 enable bit                                    */
      __IOM uint32_t ADDR3      : 31;           /*!< RW,ADDR3                                                                  */
    } bit;
  } R32_PFIC_FIADDRR3;
  __IM  uint32_t  RESERVED4[36];
  
  union {
    __OM  uint32_t reg;                         /*!< Interrupt Setting Register                                                */
    
    struct {
            uint32_t            : 12;
      __OM  uint32_t INTEN      : 20;           /*!< RW1,INTEN                                                                 */
    } bit;
  } R32_PFIC_IENR1;
  
  union {
    __OM  uint32_t reg;                         /*!< Interrupt Setting Register                                                */
    
    struct {
      __OM  uint32_t INTEN      : 4;            /*!< RW1,INTEN                                                                 */
            uint32_t            : 28;
    } bit;
  } R32_PFIC_IENR2;
  __IM  uint32_t  RESERVED5[30];
  
  union {
    __OM  uint32_t reg;                         /*!< Interrupt Clear Register                                                  */
    
    struct {
            uint32_t            : 12;
      __OM  uint32_t INTRESET   : 20;           /*!< RW1,INTRESET                                                              */
    } bit;
  } R32_PFIC_IRER1;
  
  union {
    __OM  uint32_t reg;                         /*!< Interrupt Clear Register                                                  */
    
    struct {
      __OM  uint32_t INTRESET   : 4;            /*!< RW1,INTRESET                                                              */
            uint32_t            : 28;
    } bit;
  } R32_PFIC_IRER2;
  __IM  uint32_t  RESERVED6[30];
  
  union {
    __OM  uint32_t reg;                         /*!< Interrupt Pending Register                                                */
    
    struct {
            uint32_t            : 12;
      __OM  uint32_t PENDSET    : 20;           /*!< RW1,PENDSET                                                               */
    } bit;
  } R32_PFIC_IPSR1;
  
  union {
    __OM  uint32_t reg;                         /*!< Interrupt Pending Register                                                */
    
    struct {
      __OM  uint32_t PENDSET    : 4;            /*!< RW1,PENDSET                                                               */
            uint32_t            : 28;
    } bit;
  } R32_PFIC_IPSR2;
  __IM  uint32_t  RESERVED7[30];
  
  union {
    __OM  uint32_t reg;                         /*!< Interrupt Pending Clear Register                                          */
    
    struct {
            uint32_t            : 12;
      __OM  uint32_t PENDRESET  : 20;           /*!< RW1,PENDRESET                                                             */
    } bit;
  } R32_PFIC_IPRR1;
  
  union {
    __OM  uint32_t reg;                         /*!< Interrupt Pending Clear Register                                          */
    
    struct {
      __OM  uint32_t PENDRESET  : 4;            /*!< RW1,PENDRESET                                                             */
            uint32_t            : 28;
    } bit;
  } R32_PFIC_IPRR2;
  __IM  uint32_t  RESERVED8[30];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt ACTIVE Register                                                 */
    
    struct {
            uint32_t            : 12;
      __IOM uint32_t IACTS      : 20;           /*!< RW1,IACTS                                                                 */
    } bit;
  } R32_PFIC_IACTR1;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt ACTIVE Register                                                 */
    
    struct {
      __IOM uint32_t IACTS      : 4;            /*!< RW1,IACTS                                                                 */
            uint32_t            : 28;
    } bit;
  } R32_PFIC_IACTR2;
  __IM  uint32_t  RESERVED9[62];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 0                               */
    
    struct {
      __IOM uint32_t IPRIOR0    : 32;           /*!< RW,Interrupt priority for number 0-3                                      */
    } bit;
  } R32_PFIC_IPRIOR0;
  __IM  uint32_t  RESERVED10[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 1                               */
    
    struct {
      __IOM uint32_t IPRIOR1    : 32;           /*!< >RW,Interrupt priority for number 4-7                                     */
    } bit;
  } R32_PFIC_IPRIOR1;
  __IM  uint32_t  RESERVED11[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 2                               */
    
    struct {
      __IOM uint32_t IPRIOR2    : 32;           /*!< >RW,Interrupt priority for number 8-11                                    */
    } bit;
  } R32_PFIC_IPRIOR2;
  __IM  uint32_t  RESERVED12[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 3                               */
    
    struct {
      __IOM uint32_t IPRIOR3    : 32;           /*!< >RW,Interrupt priority for number 12-15                                   */
    } bit;
  } R32_PFIC_IPRIOR3;
  __IM  uint32_t  RESERVED13[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 4                               */
    
    struct {
      __IOM uint32_t IPRIOR4    : 32;           /*!< >RW,Interrupt priority for number 16-19                                   */
    } bit;
  } R32_PFIC_IPRIOR4;
  __IM  uint32_t  RESERVED14[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 5                               */
    
    struct {
      __IOM uint32_t IPRIOR5    : 32;           /*!< >RW,Interrupt priority for number 20-23                                   */
    } bit;
  } R32_PFIC_IPRIOR5;
  __IM  uint32_t  RESERVED15[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 6                               */
    
    struct {
      __IOM uint32_t IPRIOR6    : 32;           /*!< >RW,Interrupt priority for number 24-27                                   */
    } bit;
  } R32_PFIC_IPRIOR6;
  __IM  uint32_t  RESERVED16[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 7                               */
    
    struct {
      __IOM uint32_t IPRIOR7    : 32;           /*!< >RW,Interrupt priority for number 28-31                                   */
    } bit;
  } R32_PFIC_IPRIOR7;
  __IM  uint32_t  RESERVED17[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 8                               */
    
    struct {
      __IOM uint32_t IPRIOR8    : 32;           /*!< RW,Interrupt priority for number 32-35                                    */
    } bit;
  } R32_PFIC_IPRIOR8;
  __IM  uint32_t  RESERVED18[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 9                               */
    
    struct {
      __IOM uint32_t IPRIOR9    : 32;           /*!< >RW,Interrupt priority for number 36-39                                   */
    } bit;
  } R32_PFIC_IPRIOR9;
  __IM  uint32_t  RESERVED19[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 10                              */
    
    struct {
      __IOM uint32_t IPRIOR10   : 32;           /*!< >RW,Interrupt priority for number 40-43                                   */
    } bit;
  } R32_PFIC_IPRIOR10;
  __IM  uint32_t  RESERVED20[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 11                              */
    
    struct {
      __IOM uint32_t IPRIOR11   : 32;           /*!< RW,Interrupt priority for number 44-47                                    */
    } bit;
  } R32_PFIC_IPRIOR11;
  __IM  uint32_t  RESERVED21[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 12                              */
    
    struct {
      __IOM uint32_t IPRIOR12   : 32;           /*!< RW,Interrupt priority for number 48-51                                    */
    } bit;
  } R32_PFIC_IPRIOR12;
  __IM  uint32_t  RESERVED22[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 13                              */
    
    struct {
      __IOM uint32_t IPRIOR13   : 32;           /*!< RW,Interrupt priority for number 52-55                                    */
    } bit;
  } R32_PFIC_IPRIOR13;
  __IM  uint32_t  RESERVED23[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 14                              */
    
    struct {
      __IOM uint32_t IPRIOR14   : 32;           /*!< RW,Interrupt priority for number 56-59                                    */
    } bit;
  } R32_PFIC_IPRIOR14;
  __IM  uint32_t  RESERVED24[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 15                              */
    
    struct {
      __IOM uint32_t IPRIOR15   : 32;           /*!< RW,Interrupt priority for number 60-63                                    */
    } bit;
  } R32_PFIC_IPRIOR15;
  __IM  uint32_t  RESERVED25[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 16                              */
    
    struct {
      __IOM uint32_t IPRIOR16   : 32;           /*!< RW,Interrupt priority for number 64-67                                    */
    } bit;
  } R32_PFIC_IPRIOR16;
  __IM  uint32_t  RESERVED26[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 17                              */
    
    struct {
      __IOM uint32_t IPRIOR17   : 32;           /*!< RW,Interrupt priority for number 68-71                                    */
    } bit;
  } R32_PFIC_IPRIOR17;
  __IM  uint32_t  RESERVED27[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 18                              */
    
    struct {
      __IOM uint32_t IPRIOR18   : 32;           /*!< RW,Interrupt priority for number 72-75                                    */
    } bit;
  } R32_PFIC_IPRIOR18;
  __IM  uint32_t  RESERVED28[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 19                              */
    
    struct {
      __IOM uint32_t IPRIOR19   : 32;           /*!< RW,Interrupt priority for number 76-79                                    */
    } bit;
  } R32_PFIC_IPRIOR19;
  __IM  uint32_t  RESERVED29[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 20                              */
    
    struct {
      __IOM uint32_t IPRIOR20   : 32;           /*!< RW,RW,Interrupt priority for number 80-83                                 */
    } bit;
  } R32_PFIC_IPRIOR20;
  __IM  uint32_t  RESERVED30[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 21                              */
    
    struct {
      __IOM uint32_t IPRIOR21   : 32;           /*!< RW,Interrupt priority for number 84-87                                    */
    } bit;
  } R32_PFIC_IPRIOR21;
  __IM  uint32_t  RESERVED31[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 22                              */
    
    struct {
      __IOM uint32_t IPRIOR22   : 32;           /*!< RW,Interrupt priority for number 88-91                                    */
    } bit;
  } R32_PFIC_IPRIOR22;
  __IM  uint32_t  RESERVED32[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 23                              */
    
    struct {
      __IOM uint32_t IPRIOR23   : 32;           /*!< RW,Interrupt priority for number 92-95                                    */
    } bit;
  } R32_PFIC_IPRIOR23;
  __IM  uint32_t  RESERVED33[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 24                              */
    
    struct {
      __IOM uint32_t IPRIOR24   : 32;           /*!< RW,Interrupt priority for number 96-99                                    */
    } bit;
  } R32_PFIC_IPRIOR24;
  __IM  uint32_t  RESERVED34[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 25                              */
    
    struct {
      __IOM uint32_t IPRIOR25   : 32;           /*!< RW,Interrupt priority for number 100-103                                  */
    } bit;
  } R32_PFIC_IPRIOR25;
  __IM  uint32_t  RESERVED35[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 26                              */
    
    struct {
      __IOM uint32_t IPRIOR26   : 32;           /*!< RW,Interrupt priority for number 104-107                                  */
    } bit;
  } R32_PFIC_IPRIOR26;
  __IM  uint32_t  RESERVED36[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 27                              */
    
    struct {
      __IOM uint32_t IPRIOR27   : 32;           /*!< RW,Interrupt priority for number 108-111                                  */
    } bit;
  } R32_PFIC_IPRIOR27;
  __IM  uint32_t  RESERVED37[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 28                              */
    
    struct {
      __IOM uint32_t IPRIOR28   : 32;           /*!< RW,Interrupt priority for number 112-115                                  */
    } bit;
  } R32_PFIC_IPRIOR28;
  __IM  uint32_t  RESERVED38[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 29                              */
    
    struct {
      __IOM uint32_t IPRIOR29   : 32;           /*!< RW,Interrupt priority for number 116-119                                  */
    } bit;
  } R32_PFIC_IPRIOR29;
  __IM  uint32_t  RESERVED39[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 30                              */
    
    struct {
      __IOM uint32_t IPRIOR30   : 32;           /*!< RW,Interrupt priority for number 120-123                                  */
    } bit;
  } R32_PFIC_IPRIOR30;
  __IM  uint32_t  RESERVED40[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 31                              */
    
    struct {
      __IOM uint32_t IPRIOR31   : 32;           /*!< RW,Interrupt priority for number 124-127                                  */
    } bit;
  } R32_PFIC_IPRIOR31;
  __IM  uint32_t  RESERVED41[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 32                              */
    
    struct {
      __IOM uint32_t IPRIOR32   : 32;           /*!< RW,Interrupt priority for number 128-131                                  */
    } bit;
  } R32_PFIC_IPRIOR32;
  __IM  uint32_t  RESERVED42[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 33                              */
    
    struct {
      __IOM uint32_t IPRIOR33   : 32;           /*!< RW,Interrupt priority for number 132-135                                  */
    } bit;
  } R32_PFIC_IPRIOR33;
  __IM  uint32_t  RESERVED43[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 34                              */
    
    struct {
      __IOM uint32_t IPRIOR34   : 32;           /*!< RW,Interrupt priority for number 136-139                                  */
    } bit;
  } R32_PFIC_IPRIOR34;
  __IM  uint32_t  RESERVED44[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 35                              */
    
    struct {
      __IOM uint32_t IPRIOR35   : 32;           /*!< RW,Interrupt priority for number 140-143                                  */
    } bit;
  } R32_PFIC_IPRIOR35;
  __IM  uint32_t  RESERVED45[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 36                              */
    
    struct {
      __IOM uint32_t IPRIOR36   : 32;           /*!< RW,Interrupt priority for number 144-147                                  */
    } bit;
  } R32_PFIC_IPRIOR36;
  __IM  uint32_t  RESERVED46[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 37                              */
    
    struct {
      __IOM uint32_t IPRIOR37   : 32;           /*!< RW,Interrupt priority for number 148-151                                  */
    } bit;
  } R32_PFIC_IPRIOR37;
  __IM  uint32_t  RESERVED47[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 38                              */
    
    struct {
      __IOM uint32_t IPRIOR38   : 32;           /*!< RW,Interrupt priority for number 152-155                                  */
    } bit;
  } R32_PFIC_IPRIOR38;
  __IM  uint32_t  RESERVED48[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 39                              */
    
    struct {
      __IOM uint32_t IPRIOR39   : 32;           /*!< RW,Interrupt priority for number 156-159                                  */
    } bit;
  } R32_PFIC_IPRIOR39;
  __IM  uint32_t  RESERVED49[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 40                              */
    
    struct {
      __IOM uint32_t IPRIOR40   : 32;           /*!< RW,Interrupt priority for number 160-163                                  */
    } bit;
  } R32_PFIC_IPRIOR40;
  __IM  uint32_t  RESERVED50[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 41                              */
    
    struct {
      __IOM uint32_t IPRIOR41   : 32;           /*!< RW,Interrupt priority for number 164-167                                  */
    } bit;
  } R32_PFIC_IPRIOR41;
  __IM  uint32_t  RESERVED51[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 42                              */
    
    struct {
      __IOM uint32_t IPRIOR42   : 32;           /*!< RW,Interrupt priority for number 168-171                                  */
    } bit;
  } R32_PFIC_IPRIOR42;
  __IM  uint32_t  RESERVED52[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 43                              */
    
    struct {
      __IOM uint32_t IPRIOR43   : 32;           /*!< RW,Interrupt priority for number 172-175                                  */
    } bit;
  } R32_PFIC_IPRIOR43;
  __IM  uint32_t  RESERVED53[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 44                              */
    
    struct {
      __IOM uint32_t IPRIOR44   : 32;           /*!< RW,Interrupt priority for number 176-179                                  */
    } bit;
  } R32_PFIC_IPRIOR44;
  __IM  uint32_t  RESERVED54[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 45                              */
    
    struct {
      __IOM uint32_t IPRIOR45   : 32;           /*!< RW,Interrupt priority for number 180-183                                  */
    } bit;
  } R32_PFIC_IPRIOR45;
  __IM  uint32_t  RESERVED55[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 46                              */
    
    struct {
      __IOM uint32_t IPRIOR46   : 32;           /*!< RW,Interrupt priority for number 184-187                                  */
    } bit;
  } R32_PFIC_IPRIOR46;
  __IM  uint32_t  RESERVED56[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 47                              */
    
    struct {
      __IOM uint32_t IPRIOR47   : 32;           /*!< RW,Interrupt priority for number 188-191                                  */
    } bit;
  } R32_PFIC_IPRIOR47;
  __IM  uint32_t  RESERVED57[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 48                              */
    
    struct {
      __IOM uint32_t IPRIOR48   : 32;           /*!< RW,Interrupt priority for number 192-195                                  */
    } bit;
  } R32_PFIC_IPRIOR48;
  __IM  uint32_t  RESERVED58[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 49                              */
    
    struct {
      __IOM uint32_t IPRIOR49   : 32;           /*!< RW,Interrupt priority for number 196-199                                  */
    } bit;
  } R32_PFIC_IPRIOR49;
  __IM  uint32_t  RESERVED59[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 50                              */
    
    struct {
      __IOM uint32_t IPRIOR50   : 32;           /*!< RW,Interrupt priority for number 200-203                                  */
    } bit;
  } R32_PFIC_IPRIOR50;
  __IM  uint32_t  RESERVED60[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 51                              */
    
    struct {
      __IOM uint32_t IPRIOR51   : 32;           /*!< RW,Interrupt priority for number 204-207                                  */
    } bit;
  } R32_PFIC_IPRIOR51;
  __IM  uint32_t  RESERVED61[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 52                              */
    
    struct {
      __IOM uint32_t IPRIOR52   : 32;           /*!< RW,Interrupt priority for number 208-211                                  */
    } bit;
  } R32_PFIC_IPRIOR52;
  __IM  uint32_t  RESERVED62[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 53                              */
    
    struct {
      __IOM uint32_t IPRIOR53   : 32;           /*!< RW,Interrupt priority for number 212-215                                  */
    } bit;
  } R32_PFIC_IPRIOR53;
  __IM  uint32_t  RESERVED63[11];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 54                              */
    
    struct {
      __IOM uint32_t IPRIOR54   : 32;           /*!< RW,Interrupt priority for number 216-219                                  */
    } bit;
  } R32_PFIC_IPRIOR54;
  __IM  uint32_t  RESERVED64[3];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 55                              */
    
    struct {
      __IOM uint32_t IPRIOR55   : 32;           /*!< RW,Interrupt priority for number 220-223                                  */
    } bit;
  } R32_PFIC_IPRIOR55;
  __IM  uint32_t  RESERVED65[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 56                              */
    
    struct {
      __IOM uint32_t IPRIOR56   : 32;           /*!< RW,Interrupt priority for number 224-227                                  */
    } bit;
  } R32_PFIC_IPRIOR56;
  __IM  uint32_t  RESERVED66[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 57                              */
    
    struct {
      __IOM uint32_t IPRIOR57   : 32;           /*!< RW,Interrupt priority for number 228-231                                  */
    } bit;
  } R32_PFIC_IPRIOR57;
  __IM  uint32_t  RESERVED67[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 58                              */
    
    struct {
      __IOM uint32_t IPRIOR58   : 32;           /*!< RW,Interrupt priority for number 232-235                                  */
    } bit;
  } R32_PFIC_IPRIOR58;
  __IM  uint32_t  RESERVED68[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 59                              */
    
    struct {
      __IOM uint32_t IPRIOR59   : 32;           /*!< RW,Interrupt priority for number 236-239                                  */
    } bit;
  } R32_PFIC_IPRIOR59;
  __IM  uint32_t  RESERVED69[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 60                              */
    
    struct {
      __IOM uint32_t IPRIOR60   : 32;           /*!< RW,Interrupt priority for number 240-243                                  */
    } bit;
  } R32_PFIC_IPRIOR60;
  __IM  uint32_t  RESERVED70[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 61                              */
    
    struct {
      __IOM uint32_t IPRIOR61   : 32;           /*!< RW,Interrupt priority for number 244-247                                  */
    } bit;
  } R32_PFIC_IPRIOR61;
  __IM  uint32_t  RESERVED71[15];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 62                              */
    
    struct {
      __IOM uint32_t IPRIOR62   : 32;           /*!< RW,Interrupt priority for number 248-251                                  */
    } bit;
  } R32_PFIC_IPRIOR62;
  __IM  uint32_t  RESERVED72[7];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Priority configuration Register 63                              */
    
    struct {
      __IOM uint32_t IPRIOR63   : 32;           /*!< RW,Interrupt priority for number 252-255                                  */
    } bit;
  } R32_PFIC_IPRIOR63;
  __IM  uint32_t  RESERVED73[67];
  
  union {
    __IOM uint32_t reg;                         /*!< System Control Register                                                   */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t SLEEPONEXIT : 1;           /*!< RW,SLEEPONEXIT                                                            */
      __IOM uint32_t SLEEPDEEP  : 1;            /*!< RW,SLEEPDEEP                                                              */
      __IOM uint32_t WFITOWFE   : 1;            /*!< RW,WFITOWFE                                                               */
      __IOM uint32_t SEVONPEND  : 1;            /*!< RW,SEVONPEND                                                              */
      __IOM uint32_t SETEVENT   : 1;            /*!< WO,SETEVENT                                                               */
            uint32_t            : 26;
    } bit;
  } R32_PFIC_SCTLR;
} PFIC_Type;                                    /*!< Size = 3348 (0xd14)                                                       */



/* =========================================================================================================================== */
/* ================                                          Systick                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Systick register (Systick)
  */

typedef struct {                                /*!< Systick Structure                                                         */
  
  union {
    __IOM uint32_t reg;                         /*!< Systick counter control register                                          */
    
    struct {
      __IOM uint32_t STE        : 1;            /*!< Systick counter enable                                                    */
      __IOM uint32_t STIE       : 1;            /*!< Systick counter interrupt enable                                          */
      __IOM uint32_t STCLK      : 1;            /*!< System counter clock Source selection                                     */
      __IOM uint32_t STRE       : 1;            /*!< System counter reload control                                             */
      __IOM uint32_t MODE       : 1;            /*!< counter mode                                                              */
      __IOM uint32_t INIT       : 1;            /*!< Initial counter value updated                                             */
            uint32_t            : 25;
      __IOM uint32_t SWIE       : 1;            /*!< RW0,System soft interrupt enable                                          */
    } bit;
  } R32_STK_CTLR;
  
  union {
    __IOM uint32_t reg;                         /*!< Systick count status register                                             */
    
    struct {
      __IOM uint32_t CNTIF      : 1;            /*!< RW,CNTIF                                                                  */
            uint32_t            : 31;
    } bit;
  } R32_STK_SR;
  
  union {
    __IOM uint32_t reg;                         /*!< Systick counter low register                                              */
    
    struct {
      __IOM uint32_t CNTL       : 32;           /*!< RW,CNTL                                                                   */
    } bit;
  } R32_STK_CNTL;
  
  union {
    __IOM uint32_t reg;                         /*!< Systick counter high register                                             */
    
    struct {
      __IOM uint32_t CNTH       : 32;           /*!< RW,CNTH                                                                   */
    } bit;
  } R32_STK_CNTH;
  
  union {
    __IOM uint32_t reg;                         /*!< Systick compare low register                                              */
    
    struct {
      __IOM uint32_t CMPL       : 32;           /*!< RW,CMPL                                                                   */
    } bit;
  } R32_STK_CMPLR;
  
  union {
    __IOM uint32_t reg;                         /*!< Systick compare high register                                             */
    
    struct {
      __IOM uint32_t CMPH       : 32;           /*!< RW,CMPH                                                                   */
    } bit;
  } R32_STK_CMPHR;
} Systick_Type;                                 /*!< Size = 24 (0x18)                                                          */


/** @} */ /* End of group Device_Peripheral_peripherals */


/* =========================================================================================================================== */
/* ================                          Device Specific Peripheral Address Map                           ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripheralAddr
  * @{
  */

#define SYS_BASE                    0x40001000UL
#define RTC_BASE                    0x40001000UL
#define System_control_BASE         0x40001000UL
#define TouchKey_BASE               0x40001000UL
#define ADC_BASE                    0x40001000UL
#define GPIO_BASE                   0x40001000UL
#define TMR0_BASE                   0x40002000UL
#define TMR1_BASE                   0x40002400UL
#define TMR2_BASE                   0x40002800UL
#define TMR3_BASE                   0x40002C00UL
#define UART0_BASE                  0x40003000UL
#define UART1_BASE                  0x40003400UL
#define UART2_BASE                  0x40003800UL
#define UART3_BASE                  0x40003C00UL
#define SPI0_BASE                   0x40004000UL
#define I2C_BASE                    0x40004800UL
#define PWMx_BASE                   0x40005000UL
#define LCD_BASE                    0x40006000UL
#define USB_BASE                    0x40008000UL
#define PFIC_BASE                   0xE000E000UL
#define Systick_BASE                0xE000F000UL

/** @} */ /* End of group Device_Peripheral_peripheralAddr */


/* =========================================================================================================================== */
/* ================                                  Peripheral declaration                                   ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_declaration
  * @{
  */

#define SYS                         ((SYS_Type*)               SYS_BASE)
#define RTC                         ((RTC_Type*)               RTC_BASE)
#define System_control              ((System_control_Type*)    System_control_BASE)
#define TouchKey                    ((TouchKey_Type*)          TouchKey_BASE)
#define ADC                         ((ADC_Type*)               ADC_BASE)
#define GPIO                        ((GPIO_Type*)              GPIO_BASE)
#define TMR0                        ((TMR0_Type*)              TMR0_BASE)
#define TMR1                        ((TMR1_Type*)              TMR1_BASE)
#define TMR2                        ((TMR2_Type*)              TMR2_BASE)
#define TMR3                        ((TMR3_Type*)              TMR3_BASE)
#define UART0                       ((UART0_Type*)             UART0_BASE)
#define UART1                       ((UART1_Type*)             UART1_BASE)
#define UART2                       ((UART2_Type*)             UART2_BASE)
#define UART3                       ((UART3_Type*)             UART3_BASE)
#define SPI0                        ((SPI0_Type*)              SPI0_BASE)
#define I2C                         ((I2C_Type*)               I2C_BASE)
#define PWMx                        ((PWMx_Type*)              PWMx_BASE)
#define LCD                         ((LCD_Type*)               LCD_BASE)
#define USB                         ((USB_Type*)               USB_BASE)
#define PFIC                        ((PFIC_Type*)              PFIC_BASE)
#define Systick                     ((Systick_Type*)           Systick_BASE)

/** @} */ /* End of group Device_Peripheral_declaration */


/* =========================================  End of section using anonymous unions  ========================================= */
#if defined (__CC_ARM)
  #pragma pop
#elif defined (__ICCARM__)
  /* leave anonymous unions enabled */
#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic pop
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning restore
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#endif


#ifdef __cplusplus
}
#endif

#endif /* CH592SFR_H */


/** @} */ /* End of group CH592SFR */

/** @} */ /* End of group WCH Ltd. */
