This is a machine translation of https://github.com/openwch/ch592/blob/main/EVT/EXAM/BLE/%E6%B2%81%E6%81%92%E4%BD%8E%E5%8A%9F%E8%80%97%E8%93%9D%E7%89%99%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C.PDF

I converted the document into text using pdftotext and split the file
into segments of 400 lines each. These were then summarized and
translated with Google Gemini Advanced 1.0.



**Document Title:** 沁恒低功耗蓝牙软件开发参考手册

**Document Date:** 2024年1月3日

**Document Summary:**

* This document is a reference manual for the software development of low-power Bluetooth on沁恒 chips.
* It covers the following topics:
    * Development platform
    * Task management system (TMOS)
    * Application examples
    * Low-power Bluetooth protocol stack
    * Creating a BLE application
    * APIs

**Key Takeaways:**

* The software development platform for沁恒 low-power Bluetooth is based on the RISC-V core and includes the TMOS operating system, the HAL hardware abstraction layer, the BLE protocol stack, and the application layer.
* TMOS is a task-based operating system that provides a scheduling mechanism for任务 and events.
* The BLE protocol stack consists of the PHY layer, the Link Layer, the GAP layer, the GATT layer, and the SMP layer.
* To create a BLE application, you need to:
    * Configure the BLE protocol stack
    * Define the low-power Bluetooth behavior
    * Define the application task
    * Implement the application logic

**Document Availability:**

* The document is available for download from the沁恒 website.

**Translation:**

* The document is available in Chinese only.

**Additional Resources:**

* 沁恒低功耗蓝牙技术介绍: [[移除了无效网址]]([移除了无效网址])
* 沁恒低功耗蓝牙开发例程: [[移除了无效网址]]([移除了无效网址])


Sure, here is the translation of the summary:

## 4. Application Example

### 4.1 Overview

The low-power Bluetooth EVT example includes a simple BLE project: Peripheral. Burning this project into the CH58x chip can implement a simple low-power Bluetooth slave device.

### 4.2 Project Overview

After loading the .WVPROJ file, you can see the project files in the left window of MounRiverStudio:

Figure 4.1 Project files

The files can be divided into the following categories:

1. APP – Source files and header files related to the application can be placed here, and the main function of the example is also here.
2. HAL – This folder contains the source code and header files of the HAL layer, which is the interaction layer between the Bluetooth protocol stack and the chip hardware driver.
3. LIB – Library files for the low-power Bluetooth protocol stack.
4. LD – Link script.
5. Profile – This file contains the source code and header files of the GAP role profile, GAP security profile, and GATT profile, as well as the header files required by the GATT service. For details, please refer to Section 5.
6. RVMSIS – Source code and header files for RISC-V kernel access.
7. Startup – Startup file.
8. StdPeriphDriver – Includes the underlying driver files for the chip peripherals.
9. obj – Files generated by the compiler, including map files and hex files.

### 4.3 Starting from main()

The main() function is the starting point of the program. This function first initializes the system clock; then configures the IO port status to prevent floating state from causing unstable working current; then initializes the serial port for printing and debugging, and finally initializes TMOS and low-power Bluetooth. The main() function of the Peripheral project is as follows:

```
int main( void )
{
#if (defined (DCDC_ENABLE)) && (DCDC_ENABLE == TRUE)
PWR_DCDCCfg( ENABLE );
#endif

SetSysClock( CLK_SOURCE_PLL_60MHz );

//Set system clock

GPIOA_ModeCfg( GPIO_Pin_All, GPIO_ModeIN_PU );

GPIOB_ModeCfg( GPIO_Pin_All, GPIO_ModeIN_PU );

//Configure IO port

#ifdef DEBUG
GPIOA_SetBits(bTXD1);

//Configure serial port

GPIOA_ModeCfg(bTXD1, GPIO_ModeOut_PP_5mA);

UART1_DefInit( );

//Initialize serial port

#endif

PRINT("%s\n",VER_LIB);

CH58X_BLEInit( );

HAL_Init( );

GAPRole_PeripheralInit( );

Peripheral_Init( );

while(1){

//Initialize Bluetooth library

TMOS_SystemProcess( );

//Main loop

}

}
```

### 4.4 Application Initialization

#### 4.4.1 Low-Power Bluetooth Library Initialization

The low-power Bluetooth library initialization function CH58X_BLEInit() configures the memory, clock, transmit power and other parameters of the library through the configuration parameter bleConfig_t, and then passes the configuration parameter into the library through the BLE_LibInit() function.

#### 4.4.2 HAL Layer Initialization

Register the HAL layer task, initialize the hardware parameters, such as RTC clock, sleep wake-up, RF calibration, etc.

```
void HAL_Init()
{
halTaskID = TMOS_ProcessEventRegister( HAL_ProcessEvent );

HAL_TimeInit();

#if (defined HAL_SLEEP) && (HAL_SLEEP == TRUE)
HAL_SleepInit();
#endif
#if (defined HAL_LED) && (HAL_LED == TRUE)
HAL_LedInit( );
#endif
#if (defined HAL_KEY) && (HAL_KEY == TRUE)
HAL_KeyInit( );
#endif
#if ( defined BLE_CALIBRATION_ENABLE ) && ( BLE_CALIBRATION_ENABLE == TRUE )
tmos_start_task( halTaskID, HAL_REG_INIT_EVENT, MS1_TO_SYSTEM_TIME( BLE_CALIBRATION_PERIOD ) );

// Add calibration task, single calibration takes less than 10ms

#endif
tmos_start_task( halTaskID, HAL_TEST_EVENT, 1000 );

// Add a test task

}
```

#### 4.4.3 Low-Power Bluetooth Slave Initialization

This process includes two parts:

1. Initialization of the GAP role, which is completed by the low-power Bluetooth library;
2. Initialization of the low

Sure, here is the translation of the summary:

## 5. GAP (Generic Access Profile)

### 5.1 Overview

The GAP layer defines the following states for a device:

* Standby: The Bluetooth protocol stack is not enabled.
* Advertiser: The device uses specific data to advertise, which may include the device name and address. Advertising can indicate that this device can be connected.
* Scanner: When advertising data is received, the scanning device sends a scan request packet to the advertiser, and the advertiser will return a scan response packet. The scanner will read the advertiser's information and determine if it can be connected. This process describes the process of discovering devices.
* Initiator: When establishing a connection, the connection initiator must specify the device address to be connected to. If the addresses match, a connection will be established with the advertiser. The connection initiator will initialize the connection parameters when establishing the connection.
* Master or Slave: If the device was an advertiser before the connection, it is a slave when connected; if the device was an initiator before the connection, it is a master after the connection.

### 5.2 GAP Role Configuration

The GAP layer provides the following APIs to configure the parameters of the GAP role:

* GAPRole_SetParameter()
* GAPRole_GetParameter()

The following code shows how to configure the GAP role:

```
// Setup the GAP Peripheral Role Profile
{
uint8_t initial_advertising_enable = TRUE;
uint16_t desired_min_interval = DEFAULT_DESIRED_MIN_CONN_INTERVAL;
uint16_t desired_max_interval = DEFAULT_DESIRED_MAX_CONN_INTERVAL;

// Set the GAP Role Parameters
GAPRole_SetParameter( GAPROLE_ADVERT_ENABLED, sizeof( uint8_t ), &initial_advertising_enable );
GAPRole_SetParameter( GAPROLE_SCAN_RSP_DATA, sizeof ( scanRspData ), scanRspData );
GAPRole_SetParameter( GAPROLE_ADVERT_DATA, sizeof( advertData ), advertData );
GAPRole_SetParameter( GAPROLE_MIN_CONN_INTERVAL, sizeof( uint16_t ), &desired_min_interval );
GAPRole_SetParameter( GAPROLE_MAX_CONN_INTERVAL, sizeof( uint16_t ), &desired_max_interval );
}

// Set the GAP Characteristics
GGS_SetParameter( GGS_DEVICE_NAME_ATT, GAP_DEVICE_NAME_LEN, attDeviceName );

// Set advertising interval
{
uint16_t advInt = DEFAULT_ADVERTISING_INTERVAL;

GAP_SetParamValue( TGAP_DISC_ADV_INT_MIN, advInt );
GAP_SetParamValue( TGAP_DISC_ADV_INT_MAX, advInt );
}
```

### 5.3 GAPRole Task

The GAPRole task is a separate task that runs in the Bluetooth library. The application can start and configure the GAPRole task during initialization. There are callbacks that the application can register with the GAPRole task.

The GAP layer can run the following four roles, depending on the device configuration:

* Broadcaster - Can only advertise and cannot be connected
* Observer - Can only scan advertisements and cannot establish connections
* Peripheral - Can advertise and can be connected as a slave in the link layer
* Central - Can scan advertisements and can establish one or more connections as a master in the link layer

The following describes the peripheral and central roles.

### 5.3.1 Peripheral Role

The following are the general steps to initialize the peripheral device:

1. Initialize the GAPRole parameters, as shown in the following code.

```
// Setup the GAP Peripheral Role Profile
{
uint8_t initial_advertising_enable = TRUE;
uint16_t desired_min_interval = DEFAULT_DESIRED_MIN_CONN_INTERVAL;
uint16_t desired_max_interval = DEFAULT_DESIRED_MAX_CONN_INTERVAL;

// Set the GAP Role Parameters
GAPRole_SetParameter( GAPROLE_ADVERT_ENABLED, sizeof( uint8_t ), &initial_advertising_enable );
GAPRole_SetParameter( GAPROLE_SCAN_RSP_DATA, sizeof ( scanRspData ), scanRspData );
GAPRole_SetParameter( GAPROLE_ADVERT_DATA, sizeof( advertData ), advertData );
GAPRole_SetParameter( GAPROLE_MIN_CONN_INTERVAL, sizeof( uint16_t ), &desired_min_interval );
GAPRole_SetParameter( GAPROLE_MAX_CONN_INTERVAL, sizeof( uint16_t ), &desired_max_interval );
}
```

2. Initialize the GAPRole task, including passing the function pointer to the application


Sure, here is the translation of the summary:

## 5.4 GAP (Generic Access Profile)

### 5.4.1 GAP Bonding Management

The GAPBondMgr protocol handles security management in low-energy Bluetooth connections, so that some data can only be read and written after authentication.

Table 5.1 GAP Bonding Management Terminology

Term | Description
---|---
Pairing | The process of key exchange
Encryption | Data is encrypted after pairing, or re-encrypted
Authentication | The pairing process is completed with Man-in-the-Middle (MITM) protection
Bonding | The encryption key is stored in non-volatile memory for the next encryption sequence
Authorization | In addition to authentication, additional application-level key exchange is performed
Out-of-Band (OOB) | Keys are not exchanged over the air, but through other sources such as a serial port or NFC. This also provides MITM protection.
Man-in-the-Middle (MITM) | Man-in-the-middle protection. This prevents the key from being intercepted by someone listening to the wireless transmission to crack the encryption.
JustWorks | A pairing method without a man-in-the-middle.

The general process for establishing a secure connection is as follows:

1. Key pairing (including the following two methods)
    * A. JustWorks, sends the key over the air
    * B. MITM, sends the key through a middleman
2. Encrypt the connection with the key.
3. Bind the key and store the key.
4. When connecting again, use the stored key to encrypt the connection.

### 5.4.2 Disable Pairing

```
uint8_t pairMode = GAPBOND_PAIRING_MODE_NO_PAIRING;
GAPBondMgr_SetParameter( GAPBOND_PERI_PAIRING_MODE, sizeof ( uint8_t ), &pairMode );
```

When pairing is disabled, the stack will reject any pairing attempts.

### 5.4.3 Pairing and Binding with a Man-in-the-Middle

```
uint32_t passkey = 0; // passkey "000000"
uint8_t pairMode = GAPBOND_PAIRING_MODE_WAIT_FOR_REQ;
uint8_t mitm = TRUE;
uint8_t bonding = TRUE;
uint8_t ioCap = GAPBOND_IO_CAP_DISPLAY_ONLY;
GAPBondMgr_SetParameter( GAPBOND_PERI_DEFAULT_PASSCODE, sizeof ( uint32_t ), &passkey );
GAPBondMgr_SetParameter( GAPBOND_PERI_PAIRING_MODE, sizeof ( uint8_t ), &pairMode );
GAPBondMgr_SetParameter( GAPBOND_PERI_MITM_PROTECTION, sizeof ( uint8_t ), &mitm );
GAPBondMgr_SetParameter( GAPBOND_PERI_IO_CAPABILITIES, sizeof ( uint8_t ), &ioCap );
GAPBondMgr_SetParameter( GAPBOND_PERI_BONDING_ENABLED, sizeof ( uint8_t ), &bonding );
```

Pairing and binding with a man-in-the-middle uses a 6-digit passkey to generate the key.

### 5.5 Generic Attribute Profile (GATT)

The GATT layer allows applications to communicate data between two connected devices, and the data is transmitted and stored in the form of characteristics.

In GATT, when two devices are connected, they each play one of the following two roles:

* GATT server - This device provides the GATT client with a database of characteristics to read or write.
* GATT client - This device reads and writes data from the GATT server.

Figure 5.5 shows the relationship between a low-energy Bluetooth server and client, where the peripheral device (low-energy Bluetooth module) is the GATT server and the central device (smartphone) is the GATT client.

Figure 5.5 GATT Server and Client

Typically, the GATT server and client roles are independent of the GAP central device peripheral device roles. A peripheral device can be a GATT client or server, and a central device can also be a GATT server or client. A device can also act as a GATT server or client at the same time.

### 5.5.1 GATT Characteristics and Attributes

A typical characteristic consists of the following attributes:

* Characteristic Value: This is the data value of the characteristic.

* Characteristic Declaration: Stores the properties, location, and type of the characteristic value.

* Client Characteristic Configuration: Through this configuration, the GATT server can configure the properties (notified) that need to be sent to the GATT server, or sent to the GATT server and expected to receive a response (indicated).

* Characteristic User

Sure, here is the translation of the summary:

* * *

## GATT Server

A GATT server is a device that provides data to a GATT client. To create a GATT server, you need to:

1. Define the services and characteristics that you want to provide.
2. Create a GATT database that contains the attributes for each service and characteristic.
3. Register the GATT database with the GATT server.
4. Implement the callbacks that will be called when the GATT client reads or writes to a characteristic.

## GATT Client

A GATT client is a device that reads data from a GATT server. To create a GATT client, you need to:

1. Discover the services and characteristics that are available on the GATT server.
2. Read the values of the characteristics that you are interested in.
3. Write to the values of the characteristics that you want to change.

## GATT Services and Characteristics

A GATT service is a group of related characteristics. A characteristic is a piece of data that can be read or written by a GATT client.

Each characteristic has a number of attributes, including:

* The UUID of the characteristic.
* The properties of the characteristic, such as whether it can be read or written.
* The value of the characteristic.

## GATT Database

The GATT database is a collection of attributes that define the services and characteristics that are available on a GATT server. The GATT database is stored in the GATT server's memory.

## GATT Callbacks

The GATT server and GATT client have a number of callbacks that are called when certain events occur. For example, the GATT server's `onRead()` callback is called when a GATT client reads the value of a characteristic.

## Creating a GATT Server

To create a GATT server, you need to:

1. Define the services and characteristics that you want to provide.
2. Create a GATT database that contains the attributes for each service and characteristic.
3. Register the GATT database with the GATT server.
4. Implement the callbacks that will be called when the GATT client reads or writes to a characteristic.

## Defining Services and Characteristics

The first step in creating a GATT server is to define the services and characteristics that you want to provide. A service is a group of related characteristics. A characteristic is a piece of data that can be read or written by a GATT client.

To define a service, you need to create a `GattService` object. The `GattService` object takes two parameters:

* The UUID of the service.
* The properties of the service.

The UUID of the service is a unique identifier that is used to identify the service. The properties of the service specify whether the service is primary or secondary.

To define a characteristic, you need to create a `GattCharacteristic` object. The `GattCharacteristic` object takes four parameters:

* The UUID of the characteristic.
* The properties of the characteristic.
* The value of the characteristic.
* The permissions for the characteristic.

The UUID of the characteristic is a unique identifier that is used to identify the characteristic. The properties of the characteristic specify whether the characteristic can be read, written, or both. The value of the characteristic is the data that is stored in the characteristic. The permissions for the characteristic specify who can read or write to the characteristic.

## Creating a GATT Database

The next step in creating a GATT server is to create a GATT database. The GATT database is a collection of attributes that define the services and characteristics that are available on a GATT server. The GATT database is stored in the GATT server's memory.

To create a GATT database, you need to create a `GattDatabase` object. The `GattDatabase` object takes one parameter:

* A list of `GattService` objects.

The list of `GattService` objects defines the services and characteristics that are available on the GATT server.

## Registering the GATT Database

Once you have created a GATT database, you need to register it with the GATT server. To register the GATT database, you need to call the `GattServer.registerDatabase()` method. The `GattServer.registerDatabase()` method takes one parameter:

* The `GattDatabase` object.

The `GattServer.registerDatabase()` method registers the GATT database with the GATT server.

## Implementing the Callbacks

The final step in creating a GATT server is to implement the callbacks that will be called when the GATT client reads or writes to a characteristic.

The GATT server has a number of callbacks that are called when certain events occur. For example, the GATT server's `onRead()` callback is called when a GATT client reads the value of a characteristic.

To implement a callback, you need to create a method that takes the same parameters as the callback. For example, the GATT server's `onRead()` callback takes two parameters:

* The `GattCharacteristic` object that was read.


Sure, here is the translation of the summary:

* * *

## RF Communication

The RF communication module provides a basic API for sending and receiving data over the 2.4GHz frequency band. The API is designed to be simple and easy to use, while also providing a high level of performance.

The RF communication module is divided into two layers: the physical layer (PHY) and the media access control (MAC) layer. The PHY layer is responsible for the physical transmission and reception of data. The MAC layer is responsible for managing the access to the 2.4GHz frequency band and for providing a reliable data delivery service.

The RF communication module supports two modes of operation: basic mode and auto mode. Basic mode is a simple mode that allows for the transmission and reception of data. Auto mode is a more advanced mode that provides additional features, such as automatic retransmission and flow control.

## Basic Mode

Basic mode is the simplest mode of operation for the RF communication module. In basic mode, the transmitter simply sends data over the 2.4GHz frequency band. The receiver listens for data on the 2.4GHz frequency band and receives any data that is sent.

Basic mode is a good choice for applications that require a simple and reliable way to send and receive data. For example, basic mode could be used to send and receive sensor data or to control a remote device.

## Auto Mode

Auto mode is a more advanced mode of operation for the RF communication module. In auto mode, the transmitter and receiver cooperate to ensure that data is delivered reliably.

The transmitter and receiver use a number of techniques to ensure reliable data delivery. These techniques include:

* Automatic retransmission: The transmitter will automatically retransmit any data that is not received by the receiver.
* Flow control: The transmitter and receiver will negotiate a flow control mechanism to ensure that the transmitter does not overwhelm the receiver with data.

Auto mode is a good choice for applications that require a reliable and efficient way to send and receive data. For example, auto mode could be used to stream audio or video data.

## API

The RF communication module provides a simple and easy-to-use API. The API consists of a number of functions that allow you to send and receive data, configure the RF communication module, and get status information.

The following table lists the functions that are available in the RF communication module API:

Function | Description
---|---
`RF_Init()` | Initializes the RF communication module.
`RF_Config()` | Configures the RF communication module.
`RF_Tx()` | Sends data over the 2.4GHz frequency band.
`RF_Rx()` | Receives data from the 2.4GHz frequency band.
`RF_GetStatus()` | Gets status information from the RF communication module.

The RF communication module API is designed to be simple and easy to use. The functions are well-documented and provide clear error messages. The API is also designed to be efficient and to minimize the amount of code that you need to write.

## Conclusion

The RF communication module provides a simple and easy-to-use API for sending and receiving data over the 2.4GHz frequency band. The API is designed to be efficient and to minimize the amount of code that you need to write.

The RF communication module is a good choice for a variety of applications, including:

* Sending and receiving sensor data
* Controlling a remote device
* Streaming audio or video data

If you are looking for a simple and reliable way to send and receive data over the 2.4GHz frequency band, then the RF communication module is a good choice.


Sure, here is the translation of the summary:

* * *

## TMOS API

The TMOS API provides a set of functions for managing tasks, events, timers, and memory. The API is designed to be simple and easy to use, while also providing a high level of performance.

The TMOS API is divided into a number of modules, each of which provides a set of related functions. The following table lists the modules that are available in the TMOS API:

Module | Description
---|---
`TMOS_Task` | Provides functions for managing tasks.
`TMOS_Event` | Provides functions for managing events.
`TMOS_Timer` | Provides functions for managing timers.
`TMOS_Memory` | Provides functions for managing memory.

The TMOS API is designed to be simple and easy to use. The functions are well-documented and provide clear error messages. The API is also designed to be efficient and to minimize the amount of code that you need to write.

## GAP API

The GAP API provides a set of functions for managing the Generic Access Profile (GAP). GAP is a Bluetooth profile that defines the basic procedures for discovering and connecting to Bluetooth devices.

The GAP API is divided into a number of modules, each of which provides a set of related functions. The following table lists the modules that are available in the GAP API:

Module | Description
---|---
`GAP_Device` | Provides functions for managing the device's identity and configuration.
`GAP_Discovery` | Provides functions for discovering other Bluetooth devices.
`GAP_Connection` | Provides functions for establishing and managing connections to other Bluetooth devices.
`GAP_Bonding` | Provides functions for bonding with other Bluetooth devices.

The GAP API is designed to be simple and easy to use. The functions are well-documented and provide clear error messages. The API is also designed to be efficient and to minimize the amount of code that you need to write.

## Conclusion

The TMOS API and the GAP API provide a set of functions for managing tasks, events, timers, memory, and the Generic Access Profile (GAP). The APIs are designed to be simple and easy to use, while also providing a high level of performance.

If you are developing a Bluetooth application, then the TMOS API and the GAP API are a good choice for managing the application's tasks, events, timers, memory, and GAP procedures.

Sure, here is the translation of the summary:

* * *

## GAPRole API

The GAPRole API provides a set of functions for managing the GAP Role. The GAP Role is the role that a Bluetooth device plays in a connection. There are two GAP Roles:

* **Central** - The central device initiates connections to other devices.
* **Peripheral** - The peripheral device accepts connections from other devices.

The GAPRole API is divided into two modules:

* **GAPRole Common Role API** - This module provides functions that are common to both the central and peripheral roles.
* **GAPRolePeripheral Role API** - This module provides functions that are specific to the peripheral role.

## GAPRole Common Role API

The GAPRole Common Role API provides a set of functions for managing the following:

* **Parameters** - The GAPRole Common Role API provides functions for setting and getting GAP Role parameters.
* **Connections** - The GAPRole Common Role API provides functions for establishing and terminating connections.
* **RSSI** - The GAPRole Common Role API provides functions for reading the RSSI of a connection.

## GAPRolePeripheral Role API

The GAPRolePeripheral Role API provides a set of functions for managing the following:

* **Initialization** - The GAPRolePeripheral Role API provides functions for initializing the peripheral role.
* **Advertising** - The GAPRolePeripheral Role API provides functions for advertising the device.
* **Scanning** - The GAPRolePeripheral Role API provides functions for scanning for other devices.
* **Connections** - The GAPRolePeripheral Role API provides functions for accepting connections from other devices.

## Conclusion

The GAPRole API provides a set of functions for managing the GAP Role. The API is designed to be simple and easy to use, while also providing a high level of performance.

If you are developing a Bluetooth application, then the GAPRole API is a good choice for managing the application's GAP Role.



Sure, here is the translation of the summary:

* * *

## GAPRole API

The GAPRole API provides a set of functions for managing the GAP Role. The GAP Role is the role that a Bluetooth device plays in a connection. There are two GAP Roles:

* **Central** - The central device initiates connections to other devices.
* **Peripheral** - The peripheral device accepts connections from other devices.

The GAPRole API is divided into two modules:

* **GAPRole Common Role API** - This module provides functions that are common to both the central and peripheral roles.
* **GAPRolePeripheral Role API** - This module provides functions that are specific to the peripheral role.

## GAPRole Common Role API

The GAPRole Common Role API provides a set of functions for managing the following:

* **Parameters** - The GAPRole Common Role API provides functions for setting and getting GAP Role parameters.
* **Connections** - The GAPRole Common Role API provides functions for establishing and terminating connections.
* **RSSI** - The GAPRole Common Role API provides functions for reading the RSSI of a connection.

## GAPRolePeripheral Role API

The GAPRolePeripheral Role API provides a set of functions for managing the following:

* **Initialization** - The GAPRolePeripheral Role API provides functions for initializing the peripheral role.
* **Advertising** - The GAPRolePeripheral Role API provides functions for advertising the device.
* **Scanning** - The GAPRolePeripheral Role API provides functions for scanning for other devices.
* **Connections** - The GAPRolePeripheral Role API provides functions for accepting connections from other devices.

## GAPRole Central Role API

The GAPRole Central Role API provides a set of functions for managing the following:

* **Initialization** - The GAPRole Central Role API provides functions for initializing the central role.
* **Scanning** - The GAPRole Central Role API provides functions for scanning for other devices.
* **Connections** - The GAPRole Central Role API provides functions for establishing connections to other devices.

## GATT API

The GATT API provides a set of functions for managing the GATT protocol. GATT is a Bluetooth protocol that defines the way that devices exchange data.

The GATT API is divided into two modules:

* **GATT Server API** - This module provides functions for managing the GATT server.
* **GATT Client API** - This module provides functions for managing the GATT client.

## GATT Server API

The GATT Server API provides a set of functions for managing the following:

* **Services** - The GATT Server API provides functions for adding and removing services.
* **Characteristics** - The GATT Server API provides functions for adding and removing characteristics.
* **Descriptors** - The GATT Server API provides functions for adding and removing descriptors.
* **Indications** - The GATT Server API provides functions for sending indications to clients.
* **Notifications** - The GATT Server API provides functions for sending notifications to clients.

## GATT Client API

The GATT Client API provides a set of functions for managing the following:

* **Services** - The GATT Client API provides functions for discovering services.
* **Characteristics** - The GATT Client API provides functions for discovering characteristics.
* **Descriptors** - The GATT Client API provides functions for discovering descriptors.
* **Reads** - The GATT Client API provides functions for reading characteristics.
* **Writes** - The GATT Client API provides functions for writing characteristics.

## Conclusion

The GAPRole API and the GATT API provide a set of functions for managing the GAP Role and the GATT protocol. The APIs are designed to be simple and easy to use, while also providing a high level of performance.

If you are developing a Bluetooth application, then the GAPRole API and the GATT API are a good choice for managing the application's GAP Role and GATT protocol.

Sure, here is the translation of the summary:

* * *

## GATT API

The GATT API provides a set of functions for managing the GATT protocol. GATT is a Bluetooth protocol that defines the way that devices exchange data.

The GATT API is divided into two modules:

* **GATT Server API** - This module provides functions for managing the GATT server.
* **GATT Client API** - This module provides functions for managing the GATT client.

## GATT Server API

The GATT Server API provides a set of functions for managing the following:

* **Services** - The GATT Server API provides functions for adding and removing services.
* **Characteristics** - The GATT Server API provides functions for adding and removing characteristics.
* **Descriptors** - The GATT Server API provides functions for adding and removing descriptors.
* **Indications** - The GATT Server API provides functions for sending indications to clients.
* **Notifications** - The GATT Server API provides functions for sending notifications to clients.

## GATT Client API

The GATT Client API provides a set of functions for managing the following:

* **Services** - The GATT Client API provides functions for discovering services.
* **Characteristics** - The GATT Client API provides functions for discovering characteristics.
* **Descriptors** - The GATT Client API provides functions for discovering descriptors.
* **Reads** - The GATT Client API provides functions for reading characteristics.
* **Writes** - The GATT Client API provides functions for writing characteristics.

## Conclusion

The GATT API provides a set of functions for managing the GATT protocol. The API is designed to be simple and easy to use, while also providing a high level of performance.

If you are developing a Bluetooth application, then the GATT API is a good choice for managing the application's GATT protocol.

## GATT API Commands and Events

The following tables list the GATT API commands and events.

### GATT Server API Commands

| Command | Description |
|---|---|
| GATT_Indication() | Sends an indication to a client. |
| GATT_Notification() | Sends a notification to a client. |

### GATT Client API Commands

| Command | Description |
|---|---|
| GATT_ExchangeMTU() | Exchanges MTU with a server. |
| GATT_DiscAllPrimaryServices() | Discovers all primary services on a server. |
| GATT_DiscPrimaryServiceByUUID() | Discovers a primary service on a server by UUID. |
| GATT_FindIncludedServices() | Finds included services on a server. |
| GATT_DiscAllChars() | Discovers all characteristics on a server. |
| GATT_DiscCharsByUUID() | Discovers characteristics on a server by UUID. |
| GATT_DiscAllCharDescs() | Discovers all characteristic descriptors on a server. |
| GATT_ReadCharValue() | Reads a characteristic value from a server. |
| GATT_ReadUsingCharUUID() | Reads a characteristic value from a server by UUID. |
| GATT_ReadLongCharValue() | Reads a long characteristic value from a server. |
| GATT_ReadMultiCharValues() | Reads multiple characteristic values from a server. |
| GATT_WriteNoRsp() | Writes a characteristic value to a server without a response. |
| GATT_SignedWriteNoRsp() | Writes a characteristic value to a server with a signature without a response. |
| GATT_WriteCharValue() | Writes a characteristic value to a server. |
| GATT_WriteLongCharDesc() | Writes a long characteristic descriptor to a server. |

### GATT API Events

| Event | Description |
|---|---|
| ATT_ERROR_RSP | An error response has been received. |
| ATT_EXCHANGE_MTU_REQ | An exchange MTU request has been received. |

## GATT API Return Codes

The following table lists the GATT API return codes.

| Return Code | Description |
|---|---|
| SUCCESS (0x00) | The command was executed successfully. |
| INVALIDPARAMETER (0x02) | An invalid connection handle or request field was specified. |
| MSG_BUFFER_NOT_AVAIL (0x04) | An HCI buffer is not available. Try again later. |
| bleNotConnected (0x14) | The device is not connected. |
| blePending (0x17) |

    * A server or GATT sub-procedure is in progress and there is a pending response when returned to the client function.

    * A confirmation from the client is pending when returned to the server function.

| bleTimeout (0x16) | The previous transaction timed out. No ATT or GATT messages can be sent until the connection is re-established. |
| bleMemAllocError (0x13) | A memory allocation error occurred. |
| bleLink


Sure, here is the translation of the summary:

* * *

## GATT API Commands and Events

The following tables list the GATT API commands and events.

### GATT Server API Commands

| Command | Description |
|---|---|
| GATT_Indication() | Sends an indication to a client. |
| GATT_Notification() | Sends a notification to a client. |

### GATT Client API Commands

| Command | Description |
|---|---|
| GATT_ExchangeMTU() | Exchanges MTU with a server. |
| GATT_DiscAllPrimaryServices() | Discovers all primary services on a server. |
| GATT_DiscPrimaryServiceByUUID() | Discovers a primary service on a server by UUID. |
| GATT_FindIncludedServices() | Finds included services on a server. |
| GATT_DiscAllChars() | Discovers all characteristics on a server. |
| GATT_DiscCharsByUUID() | Discovers characteristics on a server by UUID. |
| GATT_DiscAllCharDescs() | Discovers all characteristic descriptors on a server. |
| GATT_ReadCharValue() | Reads a characteristic value from a server. |
| GATT_ReadUsingCharUUID() | Reads a characteristic value from a server by UUID. |
| GATT_ReadLongCharValue() | Reads a long characteristic value from a server. |
| GATT_ReadMultiCharValues() | Reads multiple characteristic values from a server. |
| GATT_WriteNoRsp() | Writes a characteristic value to a server without a response. |
| GATT_SignedWriteNoRsp() | Writes a characteristic value to a server with a signature without a response. |
| GATT_WriteCharValue() | Writes a characteristic value to a server. |
| GATT_WriteLongCharDesc() | Writes a long characteristic descriptor to a server. |

### GATT API Events

| Event | Description |
|---|---|
| ATT_ERROR_RSP | An error response has been received. |
| ATT_EXCHANGE_MTU_REQ | An exchange MTU request has been received. |

### GATT API Return Codes

The following table lists the GATT API return codes.

| Return Code | Description |
|---|---|
| SUCCESS (0x00) | The command was executed successfully. |
| INVALIDPARAMETER (0x02) | An invalid connection handle or request field was specified. |
| MSG_BUFFER_NOT_AVAIL (0x04) | An HCI buffer is not available. Try again later. |
| bleNotConnected (0x14) | The device is not connected. |
| blePending (0x17) |

    * A server or GATT sub-procedure is in progress and there is a pending response when returned to the client function.

    * A confirmation from the client is pending when returned to the server function.

| bleTimeout (0x16) | The previous transaction timed out. No ATT or GATT messages can be sent until the connection is re-established. |
| bleMemAllocError (0x13) | A memory allocation error occurred. |
| bleLinkEncrypted (0x19) | The link is encrypted. Do not send PDUs containing an authentication signature on an encrypted link. |

### GATT Command and Corresponding ATT Event

| ATT Response Event | GATT API Call |
|---|---|
| ATT_EXCHANGE_MTU_RSP | GATT_ExchangeMTU |
| ATT_FIND_INFO_RSP | GATT_DiscAllCharDescs |
| ATT_FIND_BY_TYPE_VALUE_RSP | GATT_DiscPrimaryServiceByUUID |
| ATT_READ_BY_TYPE_RSP | GATT_PrepareWriteReq GATT_ExecuteWriteReq GATT_FindIncludedServices GATT_DiscAllChars GATT_DiscCharsByUUID GATT_ReadUsingCharUUID |
| ATT_READ_RSP | GATT_ReadCharValue GATT_ReadCharDesc |
| ATT_READ_BLOB_RSP | GATT_ReadLongCharValue GATT_ReadLongCharDesc |
| ATT_READ_MULTI_RSP | GATT_ReadMultiCharValues |
| ATT_READ_BY_GRP_TYPE_RSP | GATT_DiscAllPrimaryServices |
| ATT_WRITE_RSP | GATT_WriteCharValue GATT_WriteCharDesc |
| ATT_PREPARE_WRITE_RSP | GATT_WriteLongCharValue GATT_ReliableWrites GATT_WriteLongCharDesc |
| ATT_EXECUTE_WRITE_RSP | GATT_WriteLongCharValue GATT_ReliableWrites GATT_WriteLongCharDesc |

### ATT_ERROR_RSP Error Codes

| Error Code | Description |
|---|---|
| ATT_ERR_INVALID_HANDLE (0x01) | The given attribute handle value is not valid on this attribute server. |


Sure, here is the translation of the summary:

* * *

## GAPBondMgr API

### Commands

| Command | Description |
|---|---|
| GAPBondMgr_SetParameter() | Sets the parameters of the bonding manager. |
| GAPBondMgr_GetParameter() | Gets the parameters of the bonding manager. |
| GAPBondMgr_PasscodeRsp() | Responds to a passcode request. |

### Configuration Parameters

The following table shows the commonly used configuration parameters. For detailed parameter IDs, please refer to CH58xBLE.LIB.h.

| Parameter ID | Read/Write | Size | Description |
|---|---|---|---|
| GAPBOND_PERI_PAIRING_MODE | Readable | uint8 | Pairing mode, default: GAPBOND_PAIRING_MODE_WAIT_FOR_REQ |
| GAPBOND_PERI_DEFAULT_PASSCODE | Readable/Writable | uint32 | Default passcode, range: 0-999999, default: 0. |
| GAPBOND_PERI_MITM_PROTECTION | Readable/Writable | uint8 | Man-in-the-middle (MITM) protection. Default: 0, disabled. |
| GAPBOND_PERI_IO_CAPABILITIES | Readable/Writable | uint8 | I/O capabilities, module default: GAPBOND_IO_CAP_DISPLAY_ONLY, i.e. the device can only display. |
| GAPBOND_PERI_BONDING_ENABLED | Readable/Writable | uint8 | If enabled, bonding is requested during pairing. Default: 0, not requested. |

## RF PHY API

### Commands

| Command | Description |
|---|---|
| RF_RoleInit() | Initializes the RF protocol stack. |
| RF_Config() | Configures the RF parameters. |
| RF_Rx() | RF receive data function: configures the RF PHY to receive state, and needs to be reconfigured after receiving data. |
| RF_Tx() | RF transmit data function. |
| RF_Shut() | Turns off the RF, stops sending or receiving. |
| RF_FrequencyHoppingTx() | RF transmitter starts frequency hopping |
| RF_FrequencyHoppingRx() | RF receiver starts frequency hopping |
| RF_FrequencyHoppingShut() | Turns off the RF frequency hopping function |

### Configuration Parameters

The RF configuration parameter rfConfig_t is described as follows:

| Parameter | Description |
|---|---|
| LLEMode | LLE_MODE_BASIC: Basic mode, enters idle mode after sending or receiving LLE_MODE_AUTO: Auto mode, automatically switches to receive mode after sending |
| Channel | RF communication channel (0-39) |
| Frequency | RF communication frequency (2400000KHz-2483500KHz), it is recommended not to use more than 24 consecutive 0s or 1s after 24 bits are flipped |
| AccessAddress | RF communication address |
| CRCInit | CRC initial value |
| RFStatusCB | RF status callback function |
| ChannelMap | Channel map, each bit corresponds to a channel. A bit value of 1 indicates that the channel is valid, otherwise it is invalid. Channels are incremented by bit and channel 0 corresponds to bit 0 |
| Resv | Reserved |
| HeartPeriod | Heartbeat packet interval, a multiple of 100ms |
| HopPeriod | Hopping period (T=32n*RTC clock), default 8 |
| HopIndex | Hopping channel interval value in data channel selection algorithm, default 17 |
| RxMaxlen | Maximum data length received in RF mode, default 251 |
| TxMaxlen | Maximum data length transmitted in RF mode, default 251 |

### Callback Function

| Function | Description |
|---|---|
| RF_2G4StatusCallBack() | RF status callback function, both send and receive will enter this callback function. Note: Do not call RF receive or send API directly in this function, you need to call it in the form of an event. |


## Revision History

| Version | Date |
|---|---|
| V1.0 | 2021/3/22 | Version released |
| V1.1 | 2021/4/19 | Added RF usage example and API |
| V1.2 | 2021/5/28 | Corrected errors and added RF description |
| V1.3 | 2021/7/3 | 1. Name adjustment; 2. Modified the preface and development platform related descriptions; 3. Figure 3.1 corrected. |
| V1.4 | 2021/11/2 | 1. Added 7.5.2.1 section, describing RF frequency hopping function; 2. Added RF frequency hopping API description; 3. Optimized code display format. |
| V1.5 | 2022/5/6 | 1. Corrected error: 7.2 section code reference error; 2. Corrected error: 5.3.2 section number error; 3. 3.3 section refines TMOS task execution structure. |
| V1.6 | 2022/8/19 | 1. Adjusted the title name of Chapter 4; 2. Added application example description; 3. Added 5.5.2 section, describing GATT service and protocol; 4. Added TMOS API description; 5. Optimized content description; 6. Optimized Figure 4.2; 7. Synchronized sample code with examples; 8. Corrected content errors. |
| V1.7 | 2022/9/30 | 1. Corrected error: 8.7.3 section crc description error 2. Header adjustment |
| V1.8 | 2024/1/3 | 1. Corrected error: Figure 1.1 error 2. Corrected error: text description |

## Version Declaration and Disclaimer

This manual is copyrighted by Nanjing Qinheng Microelectronics Co., Ltd. (Copyright © Nanjing Qinheng Microelectronics Co., Ltd. All Rights Reserved). Without the written permission of Nanjing Qinheng Microelectronics Co., Ltd., no one may use any information in this product manual for any purpose, in any form (including but not limited to copying, disclosing or distributing all or part of it to anyone).

Any unauthorized changes to the contents of this product manual are not related to Nanjing Qinheng Microelectronics Co., Ltd.

The instruction documents provided by Nanjing Qinheng Microelectronics Co., Ltd. are only for reference in the use of related products and do not contain any guarantee for special purposes. Nanjing Qinheng Microelectronics Co., Ltd. reserves the right to change and upgrade this product manual and the products or software involved in the manual.

The reference manual may contain a small number of errors due to negligence. Those found will be corrected regularly and updated and avoided in future editions.