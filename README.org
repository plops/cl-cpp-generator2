* Goal

The purpose of this Lisp package is to bring the power of Common Lisp
macros to languages of that look like C or C++. This code generator is
an incompatible successor to cl-cpp-generator. I add improvements in
the semantics that I discovered when implementing cl-py-generator and
cl-golang-generator. Most notably Common Lisp style type declarations,
Common Lisp style operator names (incf, logior, and) and implicit
function calls.

This is the tenth in a series of code generators.

- https://github.com/plops/cl-cpp-generator I tried this generator
  with C/C++/ISPC/OpenCL/Cuda. It was my first attempt. The largest
  project with this is a firmware for a microcontroller. The difficult
  part is to get placement of semicolons right. I'm not terribly happy
  with the current solution. People don't like that every function
  call has to be explicitly stated as such. Initially I thought it
  would help me to add function parameter completion in emacs. But I
  never figured out how to do that and in later code generators I
  simplified the lisp syntax.

- https://github.com/plops/cl-ada-generator (abandoned) I always
  wanted to have a VHDL code generator and thought that ADA would be a
  good target to support a similar language. Unfortunately ADA and
  VHDL have a lot of syntactic constructs which I find difficult to
  express in Lisp semantics that I can remember. So I stopped working
  in this direction.

- https://github.com/plops/cl-py-generator At a new job I generated
  LOTS of python code (75k lines) with this generator. The difficult
  part was to get indents right. It works really well. I should
  backport some features from cl-golang-generator: Variable type
  declaration, when, unless, unitary - and unitary /, logior, logand,
  incf, decf.

- https://github.com/plops/cl-js-generator I played around with webrtc
  and webgl in the browser.  I used parenscript before and I really
  like the way it upholds lisp semantics (every expression returns a
  value). However, the generated javascript can be difficult to read
  (and compare to s-expressions). For this project my goal was to have
  a very minimal mapping from s-expressions to javascript. Turns out
  converting lisp to javascript is very straightforward.

- https://github.com/plops/cl-wolfram-generator (abandoned) At some
  point I was able to download a wolfram language license. I think
  this language is very close to Lisp. I tried some code generation
  but the free license would only work on one computer which is not
  how I work.

- https://github.com/plops/cl-yasm-golang (abandoned for now, FIXME I
  accidentally called this golang and not generator). I was playing
  with the idea to program bare to the metal with either LLVM IR or
  amd64 assembly. Some prototyping indicated that this has extra
  challenges that can't be easily addressed in my
  'single-function-code-generator' approach. These are distributing
  variables on registers, memory handling. Also I'm not sure how much
  or if I could immediatly profit from existing tooling if I dump
  assembly or machine code.

- https://github.com/plops/cl-golang-generator I used this to learn a
  bit of Go.  I implemented quite a few examples of the Golang
  Programming book. In particular I like how straight forward it was
  to add common lisp type declarations. I'm very happy with how this
  experiment turned out. Golang is an expressive, simple
  language. Implementing the code generator was much faster than my C
  generator (because I don't have to think about
  semicolons). Distributing the binaries is much easier than Python
  code. They are however so large (>20Mb) that I wonder if writing
  Common Lisp directly wouldn't be the better approach.


- https://github.com/plops/cl-kotlin-generator Write Android apps. I
  implemented a sufficiently large range of examples and I am
  confident that this code generator can be useful. I don't plan to
  write any Android apps right now, though.

- https://github.com/plops/cl-swift-generator (abandoned for now)
  Fueled by the success with the kotlin generator I started
  this. However, I don't have access to xcode and iphone and currently
  no interest. So this is on hold.

* Documentation

| defun name lambda-list [declaration*] form*                     | (defun foo (a) (declare (type int a) (values int)) (return 2)) | int foo(int a){ return 2;}                               |
| let ({var \vert (var [init-form])}*) declaration* form*"        | (let (a (b 3) (c 3)) (declare (type int a b)) ...              | int a; int b=3; auto c=3;                                |
| setf {pair}*                                                    | (setf a 3)                                                     | a=3                                                      |
| + {summands}*, /, *,  -                                         | (+ a b)                                                        | a+b                                                      |
| logior {arg}*                                                   | (logior a b)                                                   | a \vert b                                                |
| logand {arg}*                                                   | (logand a b)                                                   | a & b                                                    |
| or {arg}*                                                       | (or a b)                                                       | a \vert \vert b                                          |
| and {arg}*                                                      | (and a b)                                                      | a && b                                                   |
| /= a b, *=, <=, !=, ==, ^=                                      | (/= a b)                                                       | a /= b                                                   |
| <<, >>, <                                                       | (<< a b)                                                       | a << b                                                   |
| incf a [b=1], decf                                              | (incf a 2)                                                     | a+=2                                                     |
| when                                                            | (when a b)                                                     | if(a) { b; }                                             |
| unless                                                          | (unless a b)                                                   | if(!a) { b; }                                            |
| if                                                              | (if a b c)                                                     | if(a) { b; } else {c;}                                   |
| case                                                            | (case a (b (return 3)) (t (return 4)))                         | switch a .. TBD                                          |
| string                                                          | (string "a")                                                   | "a"                                                      |
| char                                                            | (char "a")                                                     | 'a'                                                      |
| aref                                                            | (aref a 2 3)                                                   | a[2][3]                                                  |
| dot                                                             | (dot b (f 3))                                                  | b.f(3)                                                   |
| lambda                                                          | (lambda (x) y)                                                 | TBD                                                      |
| defclass  name ({superclass}*) ({slot-specifier}*) [[class-option]] | (defclass Employee (Person) ... TBD                            | class Employee : Person { ... TBD                        |
| for start end iter                                              | (for ((= a 0) (< a 12) (incf a)) ...)                          | for (a=0; a<12;a++){ ...                                 |
| dotimes i n                                                     | (dotimes (i 12) ...)                                           | for (int i=0; i<12; i++) { ...                           |
| while cond                                                      | (while (== a 1) ...)                                           | while (a==1) { ...                                       |
| foreach item collection                                         | (foreach (a data) ...)                                         | for (auto& a: data) { ...                                |
| deftype name lambda-list {form}*                                | (deftype csf64 () "complex float")                             | typedef complex float csf64                              |
| defstruct0 name {slot-description}*                             | (defstruct0 Point (x int) (y int))                             | struct { int x; int y} Point; typedef sruct Point Point; |
|                                                                 |                                                                |                                                          |
|                                                                 |                                                                |                                                          |
|                                                                 |                                                                |                                                          |




* References

- https://github.com/plops/cl-cpp-generator

- https://www.youtube.com/watch?v=ZAcavCjAhEE dynamic dispatch
- https://www.youtube.com/watch?v=RBA_q9iVhls prefetching
- https://www.youtube.com/watch?v=UNvCuYQCXAI google benchmark
- https://www.youtube.com/watch?v=9ULGJwRu0Q0 cache associativity
